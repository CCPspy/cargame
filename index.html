<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Rocket League - Ultimate Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            overflow-y: auto;
        }
        
        body.fullscreen-active { padding: 0; overflow: hidden; }

        #game-container {
            width: 100%;
            max-width: 1000px; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 1rem;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1f2937;
            transition: all 0.3s ease;
        }

        #game-container.fullscreen-active {
            width: 100vw; height: 100vh; max-width: none;
            border-radius: 0; padding: 1rem; box-sizing: border-box;
            justify-content: space-between;
        }

        #game-viewport {
            position: relative; width: 100%; display: flex;
            justify-content: center; align-items: center;
        }

        #game-container.fullscreen-active #game-viewport {
            flex-grow: 1; height: 0; min-height: 0; margin: 10px 0;
        }

        #canvas-wrapper { position: relative; width: 1000px; height: 600px; }

        #game-container.fullscreen-active #canvas-wrapper {
            width: auto; height: auto; max-width: 100%; max-height: 100%;
            aspect-ratio: 1000 / 600;
        }

        canvas {
            background-color: #2b2f3d; display: block;
            border-radius: 0.75rem; width: 100%; height: 100%;
        }

        #overlay {
            position: absolute; inset: 0; border-radius: 0.75rem;
            display: flex; align-items: center; justify-content: center;
            background-color: rgba(17, 24, 39, 0.95);
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 50;
        }
        
        #overlay.visible { opacity: 1; pointer-events: auto; }

        #ui-panel, #forever-status-panel, #forever-hud { flex-shrink: 0; width: 100%; max-width: 1000px; }

        .menu-selected {
            border: 3px solid #fcd34d;
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.6);
            transform: scale(1.02);
        }
        #menu-options > div, #upgrade-options > div, .clickable-option {
             cursor: pointer; transition: all 0.2s;
        }
        .upgrade-icon-container { position: relative; cursor: default; }
        .upgrade-tooltip {
            visibility: hidden; background-color: #1f2937; color: white;
            text-align: left; border-radius: 6px; padding: 8px 12px;
            position: absolute; z-index: 60; bottom: 125%; left: 50%;
            transform: translateX(-50%); opacity: 0; transition: opacity 0.3s;
            pointer-events: none; width: 240px; white-space: normal;
            border: 1px solid #4b5563; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .upgrade-icon-container:hover .upgrade-tooltip { visibility: visible; opacity: 1; }
        
        /* Base Tiers */
        .ability-level-bronze { background: #451a03; color: #fed7aa; border: 1px solid #92400e; }
        .ability-level-silver { background: #374151; color: #e5e7eb; border: 1px solid #6b7280; }
        .ability-level-gold { background: #854d0e; color: #fef08a; border: 1px solid #eab308; }
        .ability-level-platinum { background: #1e1b4b; color: #c7d2fe; border: 1px solid #818cf8; box-shadow: 0 0 10px #6366f1; }

        /* Evolved Tiers */
        .ability-level-bronze-evo { background: #451a03; color: #ffedd5; border: 2px solid #f97316; box-shadow: 0 0 8px #ea580c; }
        .ability-level-silver-evo { background: #1f2937; color: #f3f4f6; border: 2px solid #9ca3af; box-shadow: 0 0 8px #d1d5db; }
        .ability-level-gold-evo { background: #422006; color: #fef9c3; border: 2px solid #facc15; box-shadow: 0 0 12px #eab308; }
        .ability-level-platinum-evo { background: #312e81; color: #e0e7ff; border: 2px solid #a5b4fc; box-shadow: 0 0 15px #818cf8; }
        
        .notification-toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 15px 25px; border-radius: 10px;
            color: white; font-weight: bold; pointer-events: none;
            animation: fadeOut 3s forwards; z-index: 60;
            border: 2px solid #fcd34d; box-shadow: 0 0 15px rgba(0,0,0,0.5);
            text-align: center;
        }
        @keyframes fadeOut { 0% { opacity: 1; top: 20px; } 80% { opacity: 1; top: 20px; } 100% { opacity: 0; top: 0px; } }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .blink-active { animation: blink 1s infinite; }
        
        .score-large { font-size: 2rem; transition: font-size 0.3s; }
        .score-normal { font-size: 1.25rem; transition: font-size 0.3s; }
    </style>
</head>
<body class="bg-gray-900 text-white">

<div id="game-container" class="p-4 sm:p-6 lg:p-8">
    <div id="top-bar" class="w-full mb-2 flex justify-end space-x-2 shrink-0 max-w-[1000px]">
        <div class="flex space-x-2">
            <button id="fullscreen-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
                <span class="mr-2">üì∫</span> Fullscreen
            </button>
            <button id="pause-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
                <span class="mr-2">‚è∏Ô∏è</span> Pause (P)
            </button>
        </div>
    </div>

    <div id="game-viewport">
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="overlay"></div>
            <div id="notifications"></div>
        </div>
    </div>

    <!-- HUD for Forever Mode -->
    <div id="forever-hud" class="hidden mt-2 p-3 bg-gray-800 rounded-lg border border-cyan-500/30 shadow-lg grid grid-cols-12 gap-4 items-center">
        <!-- Speed & Status (Cols 1-5) -->
        <div class="col-span-12 md:col-span-5 flex items-center space-x-4 border-b md:border-b-0 md:border-r border-gray-700 pb-2 md:pb-0 md:pr-4">
            <div>
                <div class="text-gray-400 text-[10px] font-bold tracking-widest uppercase mb-0.5">Velocity</div>
                <div class="font-black text-5xl text-cyan-400 italic leading-none" style="text-shadow: 0 0 20px rgba(34, 211, 238, 0.3);">
                    <span id="hud-speed">0</span><span class="text-lg text-gray-500 ml-1 not-italic">km/h</span>
                </div>
            </div>
            <!-- Active Effects Beside Speed -->
            <div class="flex flex-col gap-1" id="hud-effects">
                <!-- Effects injected here via JS -->
            </div>
        </div>
        
        <!-- Stats Grid (Cols 6-12) -->
        <div class="col-span-12 md:col-span-7 grid grid-cols-4 gap-2 text-center">
             <div class="bg-gray-700/50 rounded p-1.5 border border-gray-600">
                <div class="text-[9px] text-yellow-400 font-bold tracking-wider">FUEL</div>
                <div class="font-mono text-white font-bold text-base leading-tight" id="hud-boost-cap">100</div>
             </div>
             <div class="bg-gray-700/50 rounded p-1.5 border border-gray-600">
                <div class="text-[9px] text-green-400 font-bold tracking-wider">MASS</div>
                <div class="font-mono text-white font-bold text-base leading-tight" id="hud-mass">1.0x</div>
             </div>
             <div class="bg-gray-700/50 rounded p-1.5 border border-gray-600">
                <div class="text-[9px] text-red-400 font-bold tracking-wider">POWER</div>
                <div class="font-mono text-white font-bold text-base leading-tight" id="hud-accel">100%</div>
             </div>
             <div class="bg-gray-700/50 rounded p-1.5 border border-gray-600">
                <div class="text-[9px] text-purple-400 font-bold tracking-wider">GRIP</div>
                <div class="font-mono text-white font-bold text-base leading-tight" id="hud-grip">50</div>
             </div>
        </div>
    </div>

    <div id="ui-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <div class="flex justify-between items-center text-xl font-bold">
            <div id="score-left" class="text-blue-400 score-normal">BLUE: 0</div>
            <div id="center-info" class="text-center">
                <div id="timer" class="text-white text-3xl font-mono">02:00</div>
                <div id="mode-info" class="text-sm text-gray-300 mt-1">TIME REMAINING</div>
            </div>
            <div id="score-right" class="text-red-400 score-normal">RED: 0</div>
        </div>
    </div>

    <div id="forever-status-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <div class="flex flex-wrap justify-between items-start gap-4">
            <!-- AI Intel Box -->
            <div class="w-full md:w-1/3 bg-red-900/20 p-3 rounded border border-red-500/30">
                <h4 class="font-bold text-red-400 text-sm uppercase tracking-wider mb-2 border-b border-red-500/30 pb-1">Enemy Intel</h4>
                <div class="flex justify-between items-center mb-1">
                    <span class="text-gray-300 text-sm">Threat Level:</span>
                    <span id="ai-status-lvl" class="font-mono font-bold text-white">1</span>
                </div>
                <div class="flex justify-between items-center mb-2">
                    <span class="text-gray-300 text-sm">Hostiles:</span>
                    <span id="ai-count" class="font-mono font-bold text-white">1 Car</span>
                </div>
                <div class="text-xs text-gray-400 mb-1">Active Mutators:</div>
                <div id="ai-mutators-list" class="flex flex-wrap gap-1">
                    <span class="text-gray-500 italic text-xs">None</span>
                </div>
            </div>
            
            <!-- Player Upgrades -->
            <div class="w-full md:flex-1">
                <h4 class="font-semibold text-gray-300 mb-2 text-sm uppercase tracking-wider">System Upgrades</h4>
                <div id="player-upgrades-display" class="flex flex-wrap gap-2"></div>
            </div>
        </div>
    </div>

</div>

<script>
// --- Constants ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const DEFAULT_WIDTH = 1000, DEFAULT_HEIGHT = 600; 
const CAR_WIDTH = 50, CAR_HEIGHT = 25; 
const BALL_RADIUS = 17; 
const GOAL_HEIGHT = 170; 
const GOAL_LINE_WIDTH = 7; 
const MAX_CENTER_OFFSET_FACTOR = 1 / 6;
const PHYSICS_TICK_RATE = 60; 
const COLOR_BLUE = '#0066cc';
const COLOR_RED = '#cc0000';
const COLOR_CYAN = '#00fff4';
const COLOR_FIELD = '#2b2f3d';

// --- Settings & Defaults ---
const defaultKeybinds = [
    { id: 1, up:'KeyW', down:'KeyS', left:'KeyA', right:'KeyD', boost:'ShiftLeft' },
    { id: 2, up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', boost:'ShiftRight' },
    { id: 3, up:'KeyT', down:'KeyG', left:'KeyF', right:'KeyH', boost:'Space' },
    { id: 4, up:'KeyI', down:'KeyK', left:'KeyJ', right:'KeyL', boost:'ControlRight' }
];

let playerSettings = {
    keybinds: JSON.parse(JSON.stringify(defaultKeybinds)),
    sensitivity: 1.0
};

// --- Game State ---
let gameState = 'menu';
let gameMode = '1v1 Multiplayer';
let endConditionType = 'timed';
let timeLimitSeconds = 120;
let targetScore = 5;
let gameTimer = 0;
let roundTime = 0; 
let scoreLeft = 0, scoreRight = 0;
let cars = [];
let boostPads = [];
let goaliePad = null;
let ball = null;
let foreverBalls = [];
let keys = {};
let lastTime = 0;
let animationFrameId;
let aiDifficulty = 1;
let playerUpgrades = {}; 
let playerAbilities = []; 
let playerLevel = 0;
let upgradeRerollsUsed = 0, extraUpgradePicks = 0, upgradeOptions = [];
let pendingUpgradePick = false;
let stuckBallMessage = { text: '', duration: 0 };
let currentTierChances = { bronze:0, silver:0, gold:0, platinum:0 };
let chaosRoundTimer = 0; // Tracks Chaos Mode duration (in rounds)
let aiMutators = []; // Tracks active AI buffs for display

// --- Saved Session ---
let savedForeverSession = null;

// --- Global declarations for menu state ---
let selectedMenuIndex = 0;
let selectedUpgradeIndex = 0;
let menuOptions = []; 
const fullscreenBtn = document.getElementById('fullscreen-btn');
const pauseBtn = document.getElementById('pause-btn');

// --- EXPANDED ABILITY POOLS ---

const BRONZE_UPGRADES = [
    {id:'accel',label:'Engine Chip',icon:'‚ö°',desc:'Acceleration +15%.',tier:'bronze'},
    {id:'turn',label:'Power Steering',icon:'üåÄ',desc:'Rotation speed +15%.',tier:'bronze'},
    {id:'maxBoost',label:'Extra Fuel',icon:'‚õΩ',desc:'Boost capacity +20.',tier:'bronze'},
    {id:'boostRegen',label:'Hybrid Engine',icon:'üîã',desc:'Pad refill +8.',tier:'bronze'},
    {id:'frictionFix',label:'Grip Tires',icon:'ü¶∂',desc:'Reduces drift by 15%.',tier:'bronze'},
    {id:'speed',label:'Top Gear',icon:'üöÄ',desc:'Top speed +5%.',tier:'bronze'},
    {id:'brake',label:'Ceramic Brakes',icon:'üÖøÔ∏è',desc:'Braking force +50%.',tier:'bronze'},
    {id:'kick',label:'Steel Bumper',icon:'ü¶µ',desc:'Ball hit knockback +25%.',tier:'bronze'},
    {id:'stickTires',label:'Sticky Tires',icon:'üß≤',desc:'Reduces your recoil when hitting ball.',tier:'bronze'},
    {id:'extraBoostPad',label:'Field Supply',icon:'‚ú®',desc:'Bonus boost pad on field.',tier:'bronze', permanent:true},
    {id:'bigCar',label:'Heavy Frame',icon:'üöö',desc:'Size +10%, Mass +10%.',tier:'bronze'},
    {id:'slipStream',label:'Drafting',icon:'üí®',desc:'Gain boost when near AI.',tier:'bronze'},
    {id:'reverseKing',label:'Reverse King',icon:'üîô',desc:'Drive backwards 50% faster.',tier:'bronze'},
    {id:'heavyDuty',label:'Tank Tread',icon:'üõ°Ô∏è',desc:'Mass +25%, harder to push.',tier:'bronze'},
    {id:'aerodynamics',label:'Aero Kit',icon:'üçÉ',desc:'Increased max speed.',tier:'bronze'},
    {id:'boostEfficiency',label:'Eco Boost',icon:'‚ôªÔ∏è',desc:'Boost burns 15% slower.',tier:'bronze'},
    {id:'wideBody',label:'Wide Body',icon:'‚ÜîÔ∏è',desc:'Car becomes wider.',tier:'bronze'},
    {id:'longBody',label:'Limo Build',icon:'‚ÜïÔ∏è',desc:'Car becomes longer.',tier:'bronze'},
];

const SILVER_UPGRADES = [
    {id:'miniRobot',label:'Atk Drone',icon:'ü§ñ',desc:'Spawns a friendly AI attacker.',tier:'silver', permanent:true},
    {id:'goalExpansion',label:'Open Net',icon:'ü•Ö',desc:'AI goal is 30% wider.',tier:'silver', permanent:true},
    {id:'doubleKick',label:'Power Kick',icon:'ü•ä',desc:'Doubles ball impact force.',tier:'silver'},
    {id:'ballMagnet',label:'Magnet Plate',icon:'üß≤',desc:'Ball follows you briefly after hit.',tier:'silver'},
    {id:'ghostCar',label:'Phase Shift',icon:'üëª',desc:'Boost to phase through cars (2s cooldown).',tier:'silver'},
    {id:'smolRobot',label:'Def Drone',icon:'üõ°Ô∏è',desc:'Spawns a friendly AI defender.',tier:'silver', permanent:true},
    {id:'boostRain',label:'Fuel Leak',icon:'üå¶Ô∏è',desc:'Chance to get 30 boost randomly.',tier:'silver'},
    {id:'shrinkEnemies',label:'Shrink Ray',icon:'üî¨',desc:'All Enemy AIs become 20% smaller.',tier:'silver'},
    {id:'freezeTag',label:'Cryo Bumper',icon:'‚ùÑÔ∏è',desc:'Ramming enemies slows them for 2s.',tier:'silver'},
    {id:'repelField',label:'Repulsor',icon:'üîä',desc:'Nearby enemies are pushed away.',tier:'silver'},
    {id:'oilSlick',label:'Oil System',icon:'üõ¢Ô∏è',desc:'Enemies slide more (lower friction).',tier:'silver', permanent:true},
];

const GOLD_UPGRADES = [
    {id:'superStun',label:'Thunder Hit',icon:'üí´',desc:'Scoring stuns AI on next contact.',tier:'gold'},
    {id:'extraUpgrade',label:'Double Dip',icon:'üéà',desc:'Get an extra upgrade choice next time.',tier:'gold'},
    {id:'autoGoalie',label:'Robo Goalie',icon:'üïπÔ∏è',desc:'AI goalie pad blocks your net.',tier:'gold', permanent:true},
    {id:'rerollPlus',label:'Lucky Dice',icon:'üé≤',desc:'Unlimited rerolls for this pick.',tier:'gold'},
    {id:'aiSlow',label:'System Hack',icon:'üê¢',desc:'AI speed -50% for 5s after you score.',tier:'gold'},
    {id:'timeFreeze',label:'Time Stop',icon:'‚è±Ô∏è',desc:'Freeze AI for 2s when you score.',tier:'gold'},
    {id:'freePad',label:'Mana Farm',icon:'üçÄ',desc:'Bonus boost pad spawns on enemy goal.',tier:'gold'},
    {id:'ballSplit',label:'Multiball',icon:'üé±',desc:'Scoring splits the ball (Max 5).',tier:'gold'},
    {id:'goalBlock',label:'Force Field',icon:'üöß',desc:'Your goal blocked for 5s after score.',tier:'gold'},
    {id:'gravityWell',label:'Gravity Well',icon:'üåå',desc:'Passive pull on ball towards enemy goal.',tier:'gold'},
];

const PLATINUM_UPGRADES = [
    {id:'platinumDoubleAll',label:'Chaos Mode',icon:'üåà',desc:'3 Balls for next 3 Rounds.',tier:'platinum'}, // Removed permanent:true
    {id:'platinumSuperAI',label:'Virus Upload',icon:'üëæ',desc:'AI confused for first 5s of every round.',tier:'platinum'},
    {id:'platinumStickyNet',label:'Black Hole',icon:'üï≥Ô∏è',desc:'Enemy goal sucks ball in if close.',tier:'platinum'},
    {id:'platinumOmniBoost',label:'Infinite Fuel',icon:'üî•',desc:'Boost never runs out.',tier:'platinum'},
    {id:'platinumTeleport',label:'Smart Blink',icon:'‚ú®',desc:'Teleport behind ball (Press T, 3s CD).',tier:'platinum'},
];

const EVOLUTIONS = {
    'accel': {id:'accel_evo', label:'Hyper Engine', icon:'‚ö°‚ö°', desc:'Acceleration +25%.', tier:'bronze-evo'},
    'turn': {id:'turn_evo', label:'Gyro Steering', icon:'üåÄ‚ú®', desc:'Rotation speed +30%.', tier:'bronze-evo'},
    'maxBoost': {id:'maxBoost_evo', label:'Nuclear Tank', icon:'‚õΩ‚ò¢Ô∏è', desc:'Boost capacity +50.', tier:'bronze-evo'},
    'speed': {id:'speed_evo', label:'Sonic Gear', icon:'üöÄüî•', desc:'Top speed +15%.', tier:'bronze-evo'},
    'kick': {id:'kick_evo', label:'Titanium Bumper', icon:'ü¶µüíé', desc:'Ball hit knockback +25%.', tier:'bronze-evo'},
    'bigCar': {id:'bigCar_evo', label:'Giga Frame', icon:'üööü¶ñ', desc:'Size +20%, Mass +25%.', tier:'bronze-evo'},
    'boostRegen': {id:'boostRegen_evo', label:'Fusion Core', icon:'üîã‚öõÔ∏è', desc:'Pad refill +15.', tier:'bronze-evo'},
    'frictionFix': {id:'frictionFix_evo', label:'Spider Tires', icon:'ü¶∂üï∑Ô∏è', desc:'Zero drift.', tier:'bronze-evo'},
    'brake': {id:'brake_evo', label:'Anchor Brakes', icon:'üÖøÔ∏è‚öì', desc:'Instant stop.', tier:'bronze-evo'},
    'stickTires': {id:'stickTires_evo', label:'Glue Tires', icon:'üß≤üß¥', desc:'Zero recoil.', tier:'bronze-evo'},
    'slipStream': {id:'slipStream_evo', label:'Jetstream', icon:'üí®‚úàÔ∏è', desc:'Gain massive boost near AI.', tier:'bronze-evo'},
    
    'miniRobot': {id:'miniRobot_evo', label:'Elite Drone', icon:'ü§ñüëë', desc:'Spawns a smarter, faster attacker.', tier:'silver-evo'},
    'goalExpansion': {id:'goalExpansion_evo', label:'Giant Net', icon:'ü•ÖüèüÔ∏è', desc:'AI goal is 60% wider.', tier:'silver-evo'},
    'doubleKick': {id:'doubleKick_evo', label:'One Punch', icon:'ü•äüí•', desc:'Triples ball impact force.', tier:'silver-evo'},
    'ballMagnet': {id:'ballMagnet_evo', label:'Tractor Beam', icon:'üß≤üõ∏', desc:'Ball follows you for longer.', tier:'silver-evo'},
    'shrinkEnemies': {id:'shrinkEnemies_evo', label:'Micro Ray', icon:'üî¨üß¨', desc:'Enemies become 50% size.', tier:'silver-evo'},
    
    'superStun': {id:'superStun_evo', label:'Zeus Strike', icon:'üí´‚ö°', desc:'Stun duration doubled.', tier:'gold-evo'},
    'aiSlow': {id:'aiSlow_evo', label:'System Crash', icon:'üê¢üíª', desc:'AI speed -80% after score.', tier:'gold-evo'},
    'timeFreeze': {id:'timeFreeze_evo', label:'Time Lock', icon:'‚è±Ô∏èüîí', desc:'Freeze AI for 4s.', tier:'gold-evo'},
    
    'platinumOmniBoost': {id:'platinumOmniBoost_evo', label:'Cosmic Fuel', icon:'üî•üåå', desc:'Infinite Boost + 20% Speed.', tier:'platinum-evo'},
    'platinumTeleport': {id:'platinumTeleport_evo', label:'Warp Drive', icon:'‚ú®üö™', desc:'Teleport cooldown 1s.', tier:'platinum-evo'}
};

const ALL_UPGRADES = [...BRONZE_UPGRADES, ...SILVER_UPGRADES, ...GOLD_UPGRADES, ...PLATINUM_UPGRADES];

// --- Helper Functions ---
function showNotification(text, isEvolution = false, isWarning = false) {
    const n = document.createElement('div');
    n.className = 'notification-toast';
    if(isEvolution) {
        n.style.borderColor = '#a855f7';
        n.style.boxShadow = '0 0 20px #a855f7';
        n.innerHTML = `<span class="text-2xl">üß¨</span><br>${text}`;
    } else if (isWarning) {
        n.style.borderColor = '#ef4444';
        n.style.boxShadow = '0 0 20px #ef4444';
        n.style.color = '#fca5a5';
        n.innerHTML = `<span class="text-2xl">‚ö†Ô∏è</span><br>${text}`;
    } else {
        n.innerText = text;
    }
    document.getElementById('notifications').appendChild(n);
    setTimeout(() => n.remove(), 3000);
}

function saveForeverProgress() {
    savedForeverSession = {
        playerLevel,
        scoreLeft,
        scoreRight,
        aiDifficulty,
        playerUpgrades: JSON.parse(JSON.stringify(playerUpgrades)),
        playerAbilities: JSON.parse(JSON.stringify(playerAbilities)),
        extraUpgradePicks,
        chaosRoundTimer,
        aiMutators: JSON.parse(JSON.stringify(aiMutators))
    };
    gameState = 'menu';
    drawMainMenu();
}

// --- Updated Probability Logic (Bronze Floor & Strict Hierarchy) ---
function calculateTierChances(level) {
    // Fixed probabilities for Levels 0-35
    if (level < 35) {
        let progress = level / 35.0;
        // Bronze: 90% -> 50% (Never below 50)
        let b = 90 - (40 * progress); 
        // Silver: 7% -> 45%
        let s = 7 + (38 * progress);
        // Gold: 2% -> 4%
        let g = 2 + (2 * progress);
        // Platinum: 1% -> 1%
        let p = 1;
        return { bronze: b, silver: s, gold: g, platinum: p };
    } 
    // Levels 35-50
    else if (level < 50) {
        let progress = (level - 35) / 15.0;
        // Bronze: Fixed at 50%
        let b = 50;
        // Silver: 45% -> 35%
        let s = 45 - (10 * progress);
        // Gold: 4% -> 13%
        let g = 4 + (9 * progress);
        // Platinum: 1% -> 2%
        let p = 1 + (1 * progress);
        return { bronze: b, silver: s, gold: g, platinum: p };
    } 
    // Levels 50+
    else {
        let progress = Math.min(1.0, (level - 50) / 50.0);
        // Bronze: 50%
        let b = 50;
        // Silver: 35% -> 30%
        let s = 35 - (5 * progress);
        // Gold: 13% -> 15%
        let g = 13 + (2 * progress);
        // Platinum: 2% -> 5%
        let p = 2 + (3 * progress);
        return { bronze: b, silver: s, gold: g, platinum: p };
    }
}

function getAbilityTierByWeightedChance(level) {
    const chances = calculateTierChances(level);
    currentTierChances = chances; // store for UI
    let r = Math.random() * 100;
    if (r < chances.bronze) return "bronze";
    r -= chances.bronze;
    if (r < chances.silver) return "silver";
    r -= chances.silver;
    if (r < chances.gold) return "gold";
    return "platinum";
}

function getPoolForTier(tier) {
    if (tier === "bronze") return BRONZE_UPGRADES;
    if (tier === "silver") return SILVER_UPGRADES;
    if (tier === "gold") return GOLD_UPGRADES;
    if (tier === "platinum") return PLATINUM_UPGRADES;
    if (tier.includes('evo')) return Object.values(EVOLUTIONS).filter(e => e.tier === tier);
    return BRONZE_UPGRADES;
}

function randomAbilities(amt, disallowIds=[]) {
    let chosen = [];
    currentTierChances = calculateTierChances(playerLevel); 
    for (let i = 0; i < amt; i++) {
        let tier = getAbilityTierByWeightedChance(playerLevel);
        let evoChance = Math.random();
        let attemptEvo = false;
        let evoTier = null;

        if (playerLevel >= 25 && tier === 'bronze' && evoChance < 0.1) { attemptEvo = true; evoTier = 'bronze-evo'; }
        if (playerLevel >= 50 && tier === 'silver' && evoChance < 0.1) { attemptEvo = true; evoTier = 'silver-evo'; }
        if (playerLevel >= 100 && tier === 'gold' && evoChance < 0.1) { attemptEvo = true; evoTier = 'gold-evo'; }
        if (playerLevel >= 150 && tier === 'platinum' && evoChance < 0.1) { attemptEvo = true; evoTier = 'platinum-evo'; }

        let pool;
        if (attemptEvo) {
            pool = getPoolForTier(evoTier);
            // Filter already owned EVOs (usually max 1)
            pool = pool.filter(u => !playerUpgrades[u.id]); 
        } else {
            pool = getPoolForTier(tier);
        }

        if (pool) {
            pool = pool.filter(u => {
                // 1. Filter if max stacks reached (3)
                if ((playerUpgrades[u.id] || 0) >= 3) return false;
                // 2. Filter if permanent and already owned (1)
                if (u.permanent && (playerUpgrades[u.id] || 0) >= 1) return false;
                // 3. Filter if Evolution already exists (which implies base is obsolete)
                if (playerUpgrades[u.id + '_evo']) return false;
                
                return true;
            });
        }

        if (!pool || pool.length === 0) {
            // Fallback if pool is empty
            pool = getPoolForTier('bronze');
        }
        
        const pick = pool[Math.floor(Math.random() * pool.length)];
        if (pick) chosen.push(pick);
    }
    return chosen;
}

function requestUpgradePicker() {
    gameState = 'upgrading';
    upgradeRerollsUsed = 0;
    rerollUpgradeOptions(); 
    pauseBtn.classList.add('hidden');
    fullscreenBtn.classList.add('hidden');
}

function rerollUpgradeOptions() {
    let numPicks = 3 + extraUpgradePicks;
    const excluded = []; 
    upgradeOptions = randomAbilities(numPicks, excluded);
   
    // Logic: If we have rerollPlus, ignore usage count.
    if ((upgradeRerollsUsed < 1) || playerUpgrades.rerollPlus) {
        if (playerUpgrades.rerollPlus) {
            upgradeOptions.push({id:'rerollPlus', label:'FREE REROLL', icon:'üîÑ', desc:`Unlimited rerolls.`, tier:'gold'});
        } else {
            upgradeOptions.push({id:'reroll', label:'REROLL', icon:'üîÑ', desc:`Reroll options.`, tier:'bronze'});
        }
    }
    selectedUpgradeIndex = 0;
    drawUpgradeMenu();
}

function applyUpgrade(ability) {
    if (ability.id === 'extraUpgrade') {
        extraUpgradePicks++;
    } 
    else if (ability.id === 'platinumDoubleAll') {
        // Chaos Mode Special Logic: Stacks count, but also adds temporary rounds
        let currentCount = playerUpgrades[ability.id] || 0;
        playerUpgrades[ability.id] = currentCount + 1;
        chaosRoundTimer += 3;
        if (playerAbilities.findIndex(a => a.id === ability.id) === -1) playerAbilities.push(ability);
        showNotification(`CHAOS MODE EXTENDED!<br>+3 Rounds`, true);
    }
    else {
        let currentCount = playerUpgrades[ability.id] || 0;
        let isEvo = ability.tier.includes('evo');
        
        if (isEvo) {
             playerUpgrades[ability.id] = 1;
             if (playerAbilities.findIndex(a => a.id === ability.id) === -1) playerAbilities.push(ability);
             showNotification(`ACQUIRED EVOLUTION:<br>${ability.label}`, true);
        } else {
            currentCount++;
            let evoDef = EVOLUTIONS[ability.id];
            if (currentCount >= 3 && evoDef) {
                delete playerUpgrades[ability.id];
                playerAbilities = playerAbilities.filter(a => a.id !== ability.id);
                playerUpgrades[evoDef.id] = 1;
                playerAbilities.push(evoDef);
                showNotification(`ABILITY EVOLVED!<br>${ability.label} ‚ûú ${evoDef.label}`, true);
            } else {
                playerUpgrades[ability.id] = currentCount;
                if (playerAbilities.findIndex(a => a.id === ability.id) === -1) {
                    playerAbilities.push(ability);
                }
            }
        }
    }
   
    // Apply upgrades immediately to update stats
    cars.forEach(c => {
        if(!c.ai) c.applyPlayerUpgrades(playerUpgrades);
        else if(c.ai && !c.isFriendlyAI) c.updateDifficulty(aiDifficulty); 
    });

    if (playerUpgrades['miniRobot'] && !cars.some(c => c.playerId === 1001)) addFriendlyAICar(1001, 'attacker', 1.5);
    if (playerUpgrades['smolRobot'] && !cars.some(c => c.playerId === 1002)) addFriendlyAICar(1002, 'defender', 1.0);
    if (playerUpgrades['miniRobot_evo']) {
        let old = cars.findIndex(c => c.playerId === 1001);
        if(old !== -1) cars.splice(old, 1);
        if(!cars.some(c => c.playerId === 1001)) addFriendlyAICar(1001, 'attacker', 2.0);
    }
    
    if ((playerUpgrades['autoGoalie'] || playerUpgrades['autoGoalie_evo']) && !goaliePad) { 
        goaliePad = new GoaliePad(); 
        if(playerUpgrades['autoGoalie_evo']) goaliePad.width = 20;
    }
    if (playerUpgrades.extraBoostPad && boostPads.length < 11) {
        boostPads.push(new BoostPad(canvas.width*0.35, canvas.height*0.35));
        boostPads.push(new BoostPad(canvas.width*0.65, canvas.height*0.65));
    }
    
    updateUpgradesDisplay();
    updateUI(); // Force HUD update for Mass/Stats
}

function updateUpgradesDisplay() {
    const display = document.getElementById('player-upgrades-display');
    display.innerHTML = '';
    playerAbilities.forEach(ability => {
        const count = playerUpgrades[ability.id] || 0;
        const countDisplay = (!ability.tier.includes('evo') && count > 1) ? ` (x${count})` : '';
        let extraInfo = '';
        if (ability.id === 'platinumDoubleAll') extraInfo = ` <span class="text-red-400">(${chaosRoundTimer} Rnds)</span>`;

        const item = document.createElement('div');
        item.className = `px-2 py-1 rounded text-xs font-bold flex items-center shadow-sm ability-level-${ability.tier} upgrade-icon-container`;
        item.innerHTML = `
            <span class="mr-1">${ability.icon}</span> ${ability.label}${countDisplay}${extraInfo}
            <div class="upgrade-tooltip"><h4 class="font-bold">${ability.label}</h4><p class="text-xs">${ability.desc}</p></div>
        `;
        display.appendChild(item);
    });
}

function drawField(){
    ctx.fillStyle=COLOR_FIELD; ctx.fillRect(0,0,canvas.width,canvas.height);
    let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
    let aiGoalHeight = (playerUpgrades.goalExpansion || playerUpgrades.goalExpansion_evo) ? GOAL_HEIGHT * 1.3 : GOAL_HEIGHT;
    let playerGoalTop=canvas.height/2 - goalHeight/2, playerGoalBottom=canvas.height/2 + goalHeight/2;
    let aiGoalTop=canvas.height/2 - aiGoalHeight/2, aiGoalBottom=canvas.height/2 + aiGoalHeight/2;

    ctx.fillStyle = 'rgba(0, 102, 204, 0.2)'; ctx.fillRect(0, playerGoalTop, 15, goalHeight);
    ctx.fillStyle = 'rgba(204, 0, 0, 0.2)'; ctx.fillRect(canvas.width - 15, aiGoalTop, 15, aiGoalHeight);

    ctx.strokeStyle="#dcdcdc"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(canvas.width/2,0); ctx.lineTo(canvas.width/2,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(canvas.width/2,canvas.height/2,80,0,Math.PI*2); ctx.stroke();
   
    ctx.strokeStyle=COLOR_BLUE; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(0,playerGoalTop); ctx.lineTo(0,playerGoalBottom); ctx.stroke();
    ctx.strokeStyle=COLOR_RED; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(canvas.width,aiGoalTop); ctx.lineTo(canvas.width,aiGoalBottom); ctx.stroke();
   
    boostPads.forEach(pad=>pad.draw());
    if (goaliePad) goaliePad.draw();
}

function exitUpgradePicker() {
    gameState = 'playing';
    extraUpgradePicks = 0; 
    overlay.classList.remove('visible');
    overlay.innerHTML = '';
    pauseBtn.classList.remove('hidden');
    fullscreenBtn.classList.remove('hidden');
    lastTime = performance.now(); 
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Classes --
class Car {
    constructor(x, y, color, controls, team_side, player_id, initial_angle, ai=false, difficulty=1, role="attacker") {
        this.x=x; this.y=y; this.color=color; this.team_side=team_side; this.controls=controls;
        this.playerId=player_id; this.angle=initial_angle; this.velX=0; this.velY=0; this.speed=0;
       
        this.baseAcceleration=0.3; this.baseMaxSpeed=5.0;
        this.baseRotationSpeed=4.5; this.baseSideFrictionFactor=0.05;
        this.boostPower=1.8; this.boostUsage=1.2; this.maxBoost=100; this.boost=this.maxBoost; this.boosting=false;
        this.mass = 1.0;
       
        this.throttleDirection=0;
        this.ai=ai; this.difficulty=difficulty; this.role = role;
        this.upgrades={}; this.effects={};
        this.isStunned=false; this.stunDuration=0;
       
        this.isFriendlyAI = team_side === 'left' && ai;
        this.baseColor = color;
        this.boostTimer = 0; 
        this.sizeMultiplier = 1.0;
        this.widthMultiplier = 1.0;
        this.lengthMultiplier = 1.0;
        this.teleportCooldown = 0;
        this.repelField = false;
       
        this.stuckInCornerTimer = 0;
        this.aiStuckState = 'none'; 
        this.aiStuckStateTimer = 0;
        this.stuckThresholdDist = 60 + Math.random() * 30;
       
        this.aiPredictionLead = 0; // Intelligence Factor
        
        // Initial Rotation Speed Set
        this.rotationSpeed = this.baseRotationSpeed;

        this.updateDifficulty(difficulty);
        this.resetPos={x,y,angle:initial_angle};
    }
   
    updateDifficulty(difficulty) {
        this.difficulty = difficulty;
        if (this.ai) {
            this.acceleration = this.baseAcceleration + 0.05 * (difficulty-1);
            this.maxBoost = 100 + 10 * (difficulty-1);
            
            // Fix: Reset rotation speed to base for AI, ignoring player sensitivity
            this.rotationSpeed = this.baseRotationSpeed;
            
            this.sideFrictionFactor = this.baseSideFrictionFactor;
            this.mass = 1.0;
            this.repelField = false;
            this.aiPredictionLead = 0;
            
            this.sizeMultiplier = this.isFriendlyAI ? 0.75 : 1.0; 
            
            if (!this.isFriendlyAI && (playerUpgrades.shrinkEnemies || playerUpgrades.shrinkEnemies_evo)) {
                this.sizeMultiplier *= (playerUpgrades.shrinkEnemies_evo ? 0.5 : 0.8);
            }
            if (!this.isFriendlyAI && playerUpgrades.oilSlick) {
                this.sideFrictionFactor *= 0.5;
            }
            
            // Reset global tracker
            aiMutators = [];

            // AI Level Scaling with Warnings
            if (!this.isFriendlyAI) {
                if (playerLevel >= 50) {
                     this.mass *= 1.5;
                     this.sideFrictionFactor *= 2.0; 
                     aiMutators.push("Tank Hull");
                }
                
                if (playerLevel >= 60) {
                     this.acceleration *= 1.2; 
                     aiMutators.push("Turbo Engine");
                }
                
                if (playerLevel >= 70) {
                     this.baseMaxSpeed *= 1.15;
                     aiMutators.push("Overdrive");
                }
                
                if (playerLevel >= 80) {
                     this.rotationSpeed *= 1.2;
                     aiMutators.push("Pro Handling");
                }

                if (playerLevel >= 90) {
                     this.repelField = true; 
                     aiMutators.push("Repulsor Field");
                }

                if (playerLevel > 100) {
                    let extraLevels = Math.floor((playerLevel - 100) / 10);
                    if (extraLevels > 0) {
                        this.mass += (extraLevels * 0.1); 
                        this.aiPredictionLead += (extraLevels * 0.05);
                        aiMutators.push(`Titan Scale +${extraLevels}`);
                    }
                }
            }

        } else {
            this.applyPlayerUpgrades(playerUpgrades);
        }
    }
   
    applyPlayerUpgrades(upgrades) {
        if (this.ai) return; 
        let count = (id) => (upgrades[id]||0) + (upgrades[id+'_evo'] ? 1 : 0);
        let hasEvo = (id) => !!upgrades[id+'_evo'];

        this.acceleration = this.baseAcceleration * (1 + count('accel') * (hasEvo('accel')?0.30:0.15));
        // Fix: Explicitly double check player sensitivity application
        this.rotationSpeed = this.baseRotationSpeed * playerSettings.sensitivity * (1 + count('turn') * (hasEvo('turn')?0.3:0.15));
        this.maxBoost = 100 + count('maxBoost') * (hasEvo('maxBoost')?50:20);
        
        let aeroFactor = count('aerodynamics') * 0.1; 
        this.baseMaxSpeed = 5.0 * (1 + count('speed') * (hasEvo('speed')?0.15:0.05) + aeroFactor);
        
        let frictionFactor = 1 - count('frictionFix') * (hasEvo('frictionFix')?1.0:0.15);
        this.sideFrictionFactor = this.baseSideFrictionFactor * Math.max(0.0, frictionFactor);
       
        // Mass & Size Calculations (Important for HUD)
        this.sizeMultiplier = 1.0; 
        let sizeBuff = 1.0;
        if (count('bigCar') > 0) sizeBuff *= (hasEvo('bigCar')?1.20:1.10);
        this.sizeMultiplier *= sizeBuff;

        let massBuff = 1.0;
        if (count('heavyDuty') > 0) massBuff *= 1.25; 
        if (hasEvo('bigCar')) massBuff *= 1.25; 
        // Cumulative upgrades?
        // If I have 2 heavyDuty, is it 1.25 * 1.25 or 1 + 0.25*2? Usually additive percent is safer for game balance but user asked for changes.
        // Current logic: 'heavyDuty' count > 0 gives 1.25x. 
        // Fixing to scale with count:
        if (count('heavyDuty') > 0) massBuff *= (1 + 0.25 * count('heavyDuty'));

        this.mass = 1.0 * massBuff;

        this.widthMultiplier = count('wideBody') ? 1.3 : 1.0;
        this.lengthMultiplier = count('longBody') ? 1.3 : 1.0;
        
        if (count('platinumOmniBoost') || upgrades['platinumOmniBoost_evo']) this.maxBoost = 9999;
        this.boost = Math.min(this.maxBoost,this.boost); 
    }
   
    handleInput(deltaTime) { 
        if (this.ai) { this.handleAI(deltaTime); return; }
        if (this.isStunned) return;
       
        this.throttleDirection=0; let accelerationForce = 0;
       
        if (keys[this.controls['left']]) this.angle=(this.angle+this.rotationSpeed)%360;
        if (keys[this.controls['right']]) this.angle=(this.angle-this.rotationSpeed)%360;
       
        if (keys[this.controls['up']]) {accelerationForce=this.acceleration;this.throttleDirection=1;}
        if (keys[this.controls['down']]) {
            let revMult = playerUpgrades.reverseKing ? 1.5 : 0.7; 
            let isBraking = keys[this.controls['down']] && Math.abs(this.speed) > 0.1;
            let brakePower = (playerUpgrades.brake_evo ? 50.0 : (playerUpgrades.brake ? 4.0 : 1.0)); 
            
            if (isBraking && this.speed > 0.1) {
                 accelerationForce = -this.acceleration * brakePower;
            } else {
                 accelerationForce = -this.acceleration * revMult;
            }
            this.throttleDirection=-1;
        }
        
        let tpTime = playerUpgrades.platinumTeleport_evo ? 1.0 : 3.0; 
        if ((playerUpgrades.platinumTeleport || playerUpgrades.platinumTeleport_evo) && keys['KeyT'] && this.teleportCooldown <= 0) {
            const target = foreverBalls[0]; 
            const enemyGoalX = canvas.width; 
            const enemyGoalY = canvas.height/2;
            
            let vBx = enemyGoalX - target.x;
            let vBy = enemyGoalY - target.y;
            let mag = Math.hypot(vBx, vBy);
            let uBx = vBx / mag;
            let uBy = vBy / mag;
            
            let tX = target.x - (uBx * 60);
            let tY = target.y - (uBy * 60);
            tX = Math.max(50, Math.min(canvas.width-50, tX));
            tY = Math.max(50, Math.min(canvas.height-50, tY));

            this.x = tX;
            this.y = tY;
            
            let angleToGoal = Math.atan2(vBy, vBx);
            this.angle = (-angleToGoal * 180 / Math.PI); 

            this.velX = target.velX; 
            this.velY = target.velY;
            
            this.teleportCooldown = tpTime;
            showNotification("SMART BLINK!");
        }
        if (this.teleportCooldown > 0) this.teleportCooldown -= deltaTime;
       
        if (accelerationForce!==0) {
            let rad=Math.PI*this.angle/180;
            this.velX+=Math.cos(rad)*accelerationForce; this.velY-=Math.sin(rad)*accelerationForce;
        }
       
        let boostActive = keys[this.controls['boost']];
        if (gameMode === 'Vs Computer' && this.playerId === 1) {
            if (keys['ShiftLeft'] || keys['ShiftRight']) boostActive = true;
        }
        if (playerUpgrades.platinumOmniBoost || playerUpgrades.platinumOmniBoost_evo) this.boost = 9999;
        this.boosting = boostActive && this.boost > 0;
       
        if (this.boosting) {
             this.boostTimer += deltaTime;
             if (playerUpgrades.ghostCar && this.boostTimer > 0.8 && !this.effects.ghost) {
                 this.effects.ghost = { duration: 1.5 }; this.boostTimer = -2.0; 
             }
        } else {
            this.boostTimer = Math.max(0, this.boostTimer); 
        }

        if (playerUpgrades.slipStream || playerUpgrades.slipStream_evo) {
             let range = 250;
             let nearAI = cars.some(c => c.ai && Math.hypot(c.x - this.x, c.y - this.y) < range);
             if (nearAI) {
                 this.refillBoost(playerUpgrades.slipStream_evo ? 1.0 : 0.5);
             }
        }
    }

    handleAI(deltaTime) {
        if (!ball || this.isStunned) {
            if(this.isStunned) {
                // Force Stop for Time Stop
                this.velX = 0; this.velY = 0;
            }
            return;
        }
        
        // STUCK LOGIC
        if (this.aiStuckState !== 'none') {
            this.aiStuckStateTimer -= deltaTime;
            if (this.aiStuckState === 'reversing') {
                this.throttleDirection = -1;
                let rad=Math.PI*this.angle/180;
                this.velX-=Math.cos(rad)*this.acceleration; this.velY+=Math.sin(rad)*this.acceleration;
                if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'wall_seek'; this.aiStuckStateTimer = 0.5; }
            } else if (this.aiStuckState === 'wall_seek') {
                let dists = [{w:'left', d:this.x}, {w:'right', d:canvas.width-this.x}, {w:'top', d:this.y}, {w:'bottom', d:canvas.height-this.y}];
                dists.sort((a,b) => a.d - b.d);
                let targetWall = dists[1]; 
                let tx=this.x, ty=this.y;
                if(targetWall.w==='left') tx=0; else if(targetWall.w==='right') tx=canvas.width; else if(targetWall.w==='top') ty=0; else if(targetWall.w==='bottom') ty=canvas.height;
                const dx=tx-this.x, dy=ty-this.y;
                const targetAngleRad=Math.atan2(-dy,dx); let targetAngle=(targetAngleRad*180/Math.PI+360)%360;
                let angleDiff = targetAngle-this.angle; if(angleDiff>180)angleDiff-=360;if(angleDiff<-180)angleDiff+=360;
                if(angleDiff>this.rotationSpeed){this.angle=(this.angle+this.rotationSpeed)%360;}
                else if(angleDiff<-this.rotationSpeed){this.angle=(this.angle-this.rotationSpeed)%360;}
                this.throttleDirection = 1;
                let rad=Math.PI*this.angle/180;
                this.velX+=Math.cos(rad)*this.acceleration; this.velY-=Math.sin(rad)*this.acceleration;
                if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'turn_ball'; this.aiStuckStateTimer = 0.4; }
            } else if (this.aiStuckState === 'turn_ball') {
                let targetBall = foreverBalls[0];
                const dx=targetBall.x-this.x, dy=targetBall.y-this.y;
                const targetAngleRad=Math.atan2(-dy,dx); let targetAngle=(targetAngleRad*180/Math.PI+360)%360;
                let angleDiff = targetAngle-this.angle; if(angleDiff>180)angleDiff-=360;if(angleDiff<-180)angleDiff+=360;
                if(angleDiff>this.rotationSpeed){this.angle=(this.angle+this.rotationSpeed)%360;}
                else if(angleDiff<-this.rotationSpeed){this.angle=(this.angle-this.rotationSpeed)%360;}
                if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'hit_ball'; this.aiStuckStateTimer = 0.4; }
            } else if (this.aiStuckState === 'hit_ball') {
                this.throttleDirection = 1;
                let rad=Math.PI*this.angle/180;
                this.velX+=Math.cos(rad)*this.acceleration; this.velY-=Math.sin(rad)*this.acceleration;
                if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'reversing_small'; this.aiStuckStateTimer = 0.3; }
            } else if (this.aiStuckState === 'reversing_small') {
                this.throttleDirection = -1;
                let rad=Math.PI*this.angle/180;
                this.velX-=Math.cos(rad)*this.acceleration; this.velY+=Math.sin(rad)*this.acceleration;
                if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'none'; this.stuckInCornerTimer = 0; }
            }
            return;
        }
        
        let thresh = this.stuckThresholdDist;
        if ((this.x < thresh || this.x > canvas.width - thresh || this.y < thresh || this.y > canvas.height - thresh) && this.speed < 2.0) {
             this.stuckInCornerTimer += deltaTime;
             if (this.stuckInCornerTimer > 1.5) { this.aiStuckState = 'reversing'; this.aiStuckStateTimer = 0.4; return; }
        } else {
            this.stuckInCornerTimer = 0;
        }
       
        // Standard AI Logic
        cars.forEach(otherCar => {
            if (otherCar === this || !otherCar.ai || otherCar.isFriendlyAI !== this.isFriendlyAI) return;
            let dxAI = this.x - otherCar.x;
            let dyAI = this.y - otherCar.y;
            let distAI = Math.hypot(dxAI, dyAI);
            let avoidRadius = (CAR_WIDTH * this.sizeMultiplier) * 1.5;
            if (distAI < avoidRadius && distAI > 0) {
                let separationForce = 0.3 * (avoidRadius - distAI) / avoidRadius;
                this.velX += (dxAI / distAI) * separationForce;
                this.velY += (dyAI / distAI) * separationForce;
            }
        });
       
        let targetBall = foreverBalls[0];
        let minBallDist = Infinity;
        foreverBalls.forEach(b => {
            let dist = Math.hypot(b.x - this.x, b.y - this.y);
            if (dist < minBallDist) { minBallDist = dist; targetBall = b; }
        });
       
        let teammates = cars.filter(c => c.ai && c.team_side === this.team_side);
        teammates.sort((a, b) => Math.hypot(a.x-targetBall.x, a.y-targetBall.y) - Math.hypot(b.x-targetBall.x, b.y-targetBall.y));
        let closestTeammate = teammates[0];
        let amIClosest = (closestTeammate === this);

        let targetX, targetY;

        if (amIClosest) {
             targetX = targetBall.x; targetY = targetBall.y;
        } else {
            if (this.role === 'attacker') {
                targetX = canvas.width / 2; 
                targetY = targetBall.y > canvas.height/2 ? canvas.height * 0.3 : canvas.height * 0.7;
            } else if (this.role === 'mid') {
                let myGoalX = this.team_side === 'right' ? canvas.width : 0;
                targetX = (targetBall.x + myGoalX) / 2;
                targetY = (targetBall.y + canvas.height/2) / 2;
            } else {
                 targetX = targetBall.x; targetY = targetBall.y;
            }
        }

        switch(this.role){
            case "defender":
                let gLineX = this.isFriendlyAI ? BALL_RADIUS*3 : canvas.width - BALL_RADIUS*3;
                if (!amIClosest) {
                    targetX = gLineX;
                    targetY = Math.max(canvas.height/2-GOAL_HEIGHT/2+BALL_RADIUS, Math.min(targetBall.y,canvas.height/2+GOAL_HEIGHT/2-BALL_RADIUS));
                } else {
                    if (Math.abs(targetBall.x - gLineX) < 400) {
                         targetX = targetBall.x; targetY = targetBall.y;
                    } else {
                         targetX = gLineX;
                         targetY = Math.max(canvas.height/2-GOAL_HEIGHT/2+BALL_RADIUS, Math.min(targetBall.y,canvas.height/2+GOAL_HEIGHT/2-BALL_RADIUS));
                    }
                }
                break;
            case "mid":
                if (amIClosest) { targetX = targetBall.x; targetY = targetBall.y; }
                break;
            case "attacker":
                if (amIClosest) { targetX = targetBall.x; targetY = targetBall.y; }
                break;
        }
        
        if (this.isFriendlyAI) {
            if (this.role === 'attacker') targetX = Math.max(canvas.width/2 + 20, targetX); 
            else if (this.role === 'defender') targetX = Math.min(canvas.width/2 - 20, targetX);
        }

        // Intelligent Prediction Scaling
        let smartFactor = 0;
        if (playerLevel > 50 && (this.role === 'attacker' || (this.role === 'mid' && amIClosest))) {
            smartFactor = Math.min(1.0, (playerLevel - 50) / 50.0) + this.aiPredictionLead;
            let leadTime = 0.5 * smartFactor;
            targetX += targetBall.velX * leadTime;
            targetY += targetBall.velY * leadTime;
        }

        const dx=targetX-this.x,dy=targetY-this.y;
        const targetAngleRad=Math.atan2(-dy,dx); 
        let targetAngle=(targetAngleRad*180/Math.PI+360)%360;
        
        let angleDiff = targetAngle-this.angle; if(angleDiff>180)angleDiff-=360;if(angleDiff<-180)angleDiff+=360;
        const dist = Math.hypot(dx,dy);
       
        // NEW VIRUS LOGIC: Triggers at start of round (first 5 seconds)
        let isRoundStartVirus = playerUpgrades.platinumSuperAI && roundTime < 5.0 && !this.isFriendlyAI;
        
        if(this.effects.confused || isRoundStartVirus) {
            if(Math.random() < 0.1) this.throttleDirection = (Math.random() > 0.5 ? 1 : -1);
            this.angle = (this.angle + (Math.random() > 0.5 ? 15 : -15)) % 360;
        } else {
            if(angleDiff>this.rotationSpeed){this.angle=(this.angle+this.rotationSpeed)%360;}
            else if(angleDiff<-this.rotationSpeed){this.angle=(this.angle-this.rotationSpeed)%360;}
            else{this.angle=targetAngle;}
           
            this.throttleDirection=0;
            if(Math.abs(angleDiff)<32) {
                let rad=Math.PI*this.angle/180;
                this.velX+=Math.cos(rad)*this.acceleration;
                this.velY-=Math.sin(rad)*this.acceleration;
                this.throttleDirection=1;
            }
        }
       
        let canBoost = false;
        if (endConditionType === 'forever' && playerLevel >= 45) {
             if (Math.abs(angleDiff) < 10 && dist > 150 && this.boost > 20) canBoost = true;
             if (this.role === 'defender' && dist > 300) canBoost = true;
        } else if (gameMode === 'Vs Computer' && endConditionType !== 'forever' && aiDifficulty > 5) {
             if (Math.abs(angleDiff) < 10 && dist > 150 && this.boost > 20) canBoost = true;
        }
        this.boosting = canBoost;
    }
   
    move(deltaTime) {
        if(this.isStunned){
            this.stunDuration -= deltaTime;
            if(this.stunDuration <= 0) {
                this.isStunned=false;
                this.stunDuration = 0;
            }
            // Don't return here, move() needs to process position for stuck check etc, 
            // but velocity was zeroed in handleAI for stuns
        }
       
        ["slow","confused","forceField","invincible","goalBlock","ring","ghost"].forEach(eff=>{
            if(this.effects[eff]) {
                this.effects[eff].duration -= deltaTime;
                if(this.effects[eff].duration <=0) delete this.effects[eff];
            }
        });
       
        let rad=Math.PI*this.angle/180;
        let fVel=this.velX*Math.cos(rad)-this.velY*Math.sin(rad);
        let sVel=this.velX*Math.sin(rad)+this.velY*Math.cos(rad);
        
        let driftReduc = this.sideFrictionFactor;
        sVel*=(1-driftReduc); 
        fVel*=0.96; 
       
        if(this.boosting && this.boost>0 && this.throttleDirection!==0) {
            let boostForce=this.acceleration*this.boostPower*1.5;
            fVel+=boostForce*this.throttleDirection;
            if(!playerUpgrades.platinumOmniBoost && !playerUpgrades.platinumOmniBoost_evo && !this.effects.invincible) 
                this.boost -= this.boostUsage * deltaTime * PHYSICS_TICK_RATE;
            if(this.boost<0){this.boost=0;this.boosting=false;}
        }
        if ((playerUpgrades.boostEfficiency || playerUpgrades.boostEfficiency_evo) && !this.ai) {
             if (this.boosting) this.boost += 0.15 * deltaTime * PHYSICS_TICK_RATE;
        }
       
        this.velX= fVel*Math.cos(rad)+sVel*Math.sin(rad);
        this.velY= -fVel*Math.sin(rad)+sVel*Math.cos(rad);

        let speedMultiplier = 1;
        if(this.effects.slow) speedMultiplier = this.effects.slow.factor;
       
        this.speed = Math.hypot(this.velX,this.velY);
        let maxSpeed = this.baseMaxSpeed*(this.boosting?this.boostPower:1);
        if(this.speed>maxSpeed){let sc=maxSpeed/this.speed;this.velX*=sc;this.velY*=sc;}
       
        this.x += this.velX * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
       
        let w = CAR_WIDTH * this.sizeMultiplier * this.lengthMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier * this.widthMultiplier;
        let marginW = w / 2; let marginH = h / 2;

        if (this.x < marginW) { this.x = marginW; this.velX *= -0.5; }
        if (this.x > canvas.width - marginW) { this.x = canvas.width - marginW; this.velX *= -0.5; }
        if (this.y < marginH) { this.y = marginH; this.velY *= -0.5; }
        if (this.y > canvas.height - marginH) { this.y = canvas.height - marginH; this.velY *= -0.5; }
        
        // Repel Field Logic (Player or AI)
        if ((!this.ai && playerUpgrades.repelField) || (this.ai && this.repelField)) {
            cars.forEach(c => {
               if (c !== this && c.team_side !== this.team_side) { // Affects enemies
                   let d = Math.hypot(c.x - this.x, c.y - this.y);
                   if (d < 200) { 
                       let angle = Math.atan2(c.y - this.y, c.x - this.x);
                       let push = 2.0; 
                       c.velX += Math.cos(angle) * push;
                       c.velY += Math.sin(angle) * push;
                   }
               } 
            });
        }
    }
   
    draw() {
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(-Math.PI*this.angle/180);
       
        let w = CAR_WIDTH * this.sizeMultiplier * this.lengthMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier * this.widthMultiplier;
       
        let displayColor = this.color;
        if(this.isFriendlyAI) displayColor = '#00cccc';
        if(this.isStunned) displayColor = '#aaaaaa';
        if(this.effects.ring) displayColor = '#fcd34d';
        if(this.effects.forceField) displayColor = '#00ff00';
        if(this.effects.ghost) displayColor = 'rgba(255,255,255,0.5)';
       
        ctx.fillStyle=displayColor;
        ctx.beginPath(); ctx.roundRect(-w/2,-h/2, w, h, 8 * this.sizeMultiplier); ctx.fill();
       
        ctx.fillStyle='yellow';
        ctx.beginPath(); ctx.roundRect(w/2-(10*this.sizeMultiplier),-h/2+(5*this.sizeMultiplier), 8*this.sizeMultiplier, h-(10*this.sizeMultiplier), 2*this.sizeMultiplier); ctx.fill();
       
        if(this.boosting){
            ctx.fillStyle="#ffaa00";
            ctx.beginPath(); ctx.moveTo(-w/2,0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),-h/4);
            ctx.lineTo(-w/2-(20*this.sizeMultiplier),0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),h/4); ctx.closePath(); ctx.fill();
        }
        ctx.restore();
       
        if(this.effects.ring || this.effects.forceField || this.repelField){
            ctx.save();
            ctx.beginPath();
            let style = "#00fff4";
            if (this.effects.ring) style = "#fcd34d";
            if (this.effects.forceField) style = "#00ff00";
            if (this.repelField) style = "#ef4444"; // Red for AI repel
            
            ctx.strokeStyle = style;
            ctx.globalAlpha = 0.6; ctx.lineWidth=4;
            let radius = (CAR_WIDTH * this.sizeMultiplier) * 1.7;
            if(this.effects.forceField) radius = (CAR_WIDTH * this.sizeMultiplier) * 2.5;
            ctx.arc(this.x,this.y,radius,0,Math.PI*2); ctx.stroke();
            ctx.restore();
        }
       
        const isHuman=!this.ai;
        const label = isHuman?`P${this.playerId}`:`AI Lv.${this.difficulty} (${this.role.charAt(0).toUpperCase()})`;
        const labelY=this.y-h/2-15, barWidth=40, barHeight=6, bpct=this.boost/this.maxBoost;
        ctx.fillStyle=isHuman?COLOR_BLUE:(this.isFriendlyAI ? '#00cccc' : COLOR_RED);
        ctx.font='12px Inter'; ctx.textAlign='center';
        ctx.fillText(label,this.x,labelY-5);
        ctx.fillStyle='#1f2937';
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth,barHeight,3); ctx.fill();
        let grad = ctx.createLinearGradient(this.x-barWidth/2,0,this.x-barWidth/2+barWidth,0);
        grad.addColorStop(0,bpct<0.3?'#ef4444':'#f97316'); grad.addColorStop(1,'#f97316');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth*bpct,barHeight,3); ctx.fill();
    }
   
    refillBoost(amount) {
        this.boost = Math.min(this.maxBoost,this.boost+amount);
    }
   
    reset() {
        this.x=this.resetPos.x; this.y=this.resetPos.y; this.angle=this.resetPos.angle;
        this.velX=0; this.velY=0; this.speed=0; this.boost=this.maxBoost;
        this.isStunned=false; this.stunDuration=0; this.effects={};
        this.stuckInCornerTimer = 0;
        this.aiStuckState = 'none';
    }
}

// ... Ball, BoostPad, GoaliePad classes are same ...
class Ball {
    constructor(x, y, radius, pointType=1) {
        this.x=x;this.y=y;this.radius=radius;this.color=COLOR_CYAN;
        this.velX=0;this.velY=0;this.maxSpeed=35; this.pointType=pointType; this.effects = {};
        this.stuckTimer = 0; this.ballStuckCountdown = 0;
    }
    move(deltaTime) {
        if (playerUpgrades.ballMagnet || playerUpgrades.ballMagnet_evo) {
             let p = cars[0];
             if (p && !p.ai) {
                 let d = Math.hypot(p.x-this.x, p.y-this.y);
                 if (d < 250) { // Increased range slightly
                     let pullStr = playerUpgrades.ballMagnet_evo ? 0.006 : 0.003;
                     this.velX += (p.x - this.x) * pullStr * PHYSICS_TICK_RATE;
                     this.velY += (p.y - this.y) * pullStr * PHYSICS_TICK_RATE;
                 }
             }
        }
        if (playerUpgrades.gravityWell) {
             // Stronger pull to enemy goal
             let targetX = canvas.width; let targetY = canvas.height/2;
             this.velX += (targetX - this.x) * 0.0015 * PHYSICS_TICK_RATE;
             this.velY += (targetY - this.y) * 0.0015 * PHYSICS_TICK_RATE;
        }
        this.velX *= 0.98; this.velY *= 0.98;
        let speed = Math.hypot(this.velX, this.velY);
        if(speed > this.maxSpeed){ let sc = this.maxSpeed / speed; this.velX *= sc; this.velY *= sc; }
        this.x += this.velX * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * deltaTime * PHYSICS_TICK_RATE;
        let bMargin = this.radius;
        if (this.x < bMargin) { this.x = bMargin; this.velX *= -0.8; }
        else if (this.x > canvas.width - bMargin) { this.x = canvas.width - bMargin; this.velX *= -0.8; }
        if (this.y < bMargin) { this.y = bMargin; this.velY *= -0.8; }
        else if (this.y > canvas.height - bMargin) { this.y = canvas.height - bMargin; this.velY *= -0.8; }
        
        // Platinum Sticky Net (Black Hole)
        if(playerUpgrades.platinumStickyNet || playerUpgrades.platinumStickyNet_evo) {
            let aiGoalTop=canvas.height/2-GOAL_HEIGHT/2, aiGoalBottom=canvas.height/2+GOAL_HEIGHT/2;
            let triggerDist = 140; // Reduced range from 200
            if(this.x > canvas.width - triggerDist && this.y > aiGoalTop - 50 && this.y < aiGoalBottom + 50) {
                 let goalCX = canvas.width + 20; 
                 let goalCY = canvas.height/2;
                 let dx = goalCX - this.x;
                 let dy = goalCY - this.y;
                 let d = Math.hypot(dx, dy);
                 let pull = 2000 / (d * d + 1); 
                 this.velX += (dx/d) * pull;
                 this.velY += (dy/d) * pull;
            }
        }

        const cornerCheckSize = 150; 
        const ballInCorner = (this.y < cornerCheckSize || this.y > canvas.height - cornerCheckSize) && (this.x < cornerCheckSize || this.x > canvas.width - cornerCheckSize);
        if (speed < 0.8 && ballInCorner) { 
            this.stuckTimer += deltaTime;
            if (this.stuckTimer > 2.0) {
                this.ballStuckCountdown = Math.ceil(5.0 - (this.stuckTimer - 2.0));
                if (this.ballStuckCountdown < 1) { 
                    this.reset(); stuckBallMessage = { text: 'Ball stuck! Resetting...', duration: 2.0 };
                }
            }
        } else {
            this.stuckTimer = 0; this.ballStuckCountdown = 0;
        }
    }
    draw() {
        ctx.fillStyle=this.pointType===1?this.color:(this.pointType===2?'#ffe066':'#ff92c6');
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,0.5)';
        ctx.beginPath(); ctx.arc(this.x-5,this.y-5,this.radius/2,0,Math.PI*2); ctx.fill();
        if(this.pointType>1){
            ctx.save(); ctx.font='bold 13px Inter'; ctx.globalAlpha=0.90;
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillStyle=(this.pointType===2?'#fcad03':'#ed1b90'); ctx.strokeStyle='#fff';
            ctx.fillText((this.pointType===2?'2x':'3x'),this.x,this.y-this.radius+10);
            ctx.restore();
        }
    }
    reset() {
        let maxOffset=canvas.height*MAX_CENTER_OFFSET_FACTOR, randomYOffset=Math.random()*2*maxOffset-maxOffset;
        this.x=canvas.width/2; this.y=canvas.height/2+randomYOffset; this.velX=0;this.velY=0;
        this.stuckTimer = 0; this.ballStuckCountdown = 0;
        
        // Modified Chaos Mode Spawn Logic
        // Active only if timer > 0.
        let chaosActive = chaosRoundTimer > 0;
        if(chaosActive && this !== foreverBalls[0]) {
             // Base offset toward enemy. 
             let count = playerUpgrades['platinumDoubleAll'] || 1;
             let baseOffset = 200;
             // Area increases with multiple stacks
             let extraOffset = (count - 1) * 80;
             let totalOffset = baseOffset + extraOffset;
             
             // "Chance only a little" - Add some randomness to the x position
             let randFactor = (Math.random() * 100) - 50; // +/- 50 variation
             
             this.x = Math.min(canvas.width - 150, (canvas.width/2) + totalOffset + randFactor); 
        }
        
        let r=Math.random();
        if(chaosActive) {
            if(r<0.10) this.pointType=3; else if(r<0.30) this.pointType=2; else this.pointType=1;
        } else if(r<0.03) this.pointType=3; else if(r<0.13) this.pointType=2; else this.pointType=1;
    }
}

class BoostPad {
    constructor(x,y,radius=12){ this.x=x;this.y=y;this.radius=radius; this.active = true; this.cooldownTimer = 0; }
    update(deltaTime) { if (!this.active) { this.cooldownTimer -= deltaTime; if (this.cooldownTimer <= 0) this.active = true; } }
    draw() {
        ctx.save();
        if (!this.active) ctx.globalAlpha = 0.3; 
        ctx.strokeStyle="#fbbf24"; ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle="#f59e42"; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius-7,0,Math.PI*2); ctx.fill();
        ctx.restore();
    }
    checkCollision(car){
        if (!this.active) return false; 
        return Math.hypot(this.x-car.x,this.y-car.y) < this.radius+(CAR_WIDTH*car.sizeMultiplier/2);
    }
    consume(car) {
        if (!this.active) return;
        this.active = false; this.cooldownTimer = 3.0;
        let refill = 25 + (playerUpgrades.boostRegen ? 8 : 0) + (playerUpgrades.boostRegen_evo ? 15 : 0);
        car.refillBoost(refill);
    }
}

class GoaliePad {
    constructor() { this.width = 14; this.height = GOAL_HEIGHT * 0.20; this.x = 7; this.y = canvas.height / 2; this.speed = 400; }
    update(deltaTime) {
        let targetBall = foreverBalls[0];
        if (foreverBalls.length > 1) {
             let minX = Infinity;
             foreverBalls.forEach(b => { if(b.x < minX) { minX = b.x; targetBall = b; } });
        }
        let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
        let playerGoalTop = canvas.height/2 - goalHeight/2;
        let playerGoalBottom = canvas.height/2 + goalHeight/2;
        let targetCenter = Math.max(playerGoalTop + this.height/2, Math.min(targetBall.y, playerGoalBottom - this.height/2));
        let moveDist = this.speed * deltaTime;
        if (this.y < targetCenter) this.y = Math.min(this.y + moveDist, targetCenter);
        else if (this.y > targetCenter) this.y = Math.max(this.y - moveDist, targetCenter);
    }
    draw() {
        ctx.fillStyle = '#00cccc'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height, 4);
        ctx.fill(); ctx.stroke();
    }
    checkCollision(ball) {
        let top = this.y - this.height/2; let bottom = this.y + this.height/2;
        let right = this.x + this.width/2;
        if (ball.x - ball.radius < right && ball.x + ball.radius > 0 && ball.y > top && ball.y < bottom) {
            if (ball.velX < 0) { ball.velX *= -1.5; ball.x = right + ball.radius + 2; }
        }
    }
}

function getInitialAngle(x1,y1,x2,y2){
    let angleRad=Math.atan2(y1-y2,x2-x1);
    return (angleRad*180/Math.PI+360)%360;
}
function getNumberOfAICars(){return cars.filter(c=>c.ai&&!c.isFriendlyAI).length;}

function addFriendlyAICar(playerId, role, difficultyMultiplier) {
    const P1_X=100+CAR_WIDTH/2, center_y=canvas.height/2;
    let newAI = new Car(P1_X + 20, center_y + (Math.random() * 100 - 50),
                        '#00cccc', {}, 'left', playerId,
                        getInitialAngle(P1_X, center_y, canvas.width/2, center_y),
                        true, aiDifficulty * difficultyMultiplier, role);
    newAI.sizeMultiplier = 0.75;
    cars.push(newAI);
}

function addEnemyAICar() {
    let center_x=canvas.width/2, center_y=canvas.height/2;
    let P2_X=canvas.width-100-CAR_WIDTH/2;
    let P1_Y_OFFSET=CAR_HEIGHT*2;
    let aiY=center_y+((Math.random() > 0.5)?P1_Y_OFFSET*(Math.random()*2):-P1_Y_OFFSET*Math.random()*2);
    let effectiveDiff = aiDifficulty;
    let newAI = new Car(P2_X,aiY,COLOR_RED,{},'right',2+getNumberOfAICars(),getInitialAngle(P2_X,aiY,center_x,center_y),true,effectiveDiff);
    cars.push(newAI);
    assignAIRoles(cars.filter(c => c.ai && !c.isFriendlyAI));
}

function assignAIRoles(aiCars){
    const roleOrder = ["attacker", "defender", "mid", "attacker", "mid", "defender"];
    aiCars.sort((a, b) => a.playerId - b.playerId).forEach((ai, index) => {
        ai.role = roleOrder[index % roleOrder.length] || "attacker";
    });
}

function setupGameObjects(mode,initialAICount=1){
    canvas.width = DEFAULT_WIDTH; canvas.height = DEFAULT_HEIGHT;
    let center_x=canvas.width/2, center_y=canvas.height/2;
    foreverBalls = [];
    
    // Chaos Mode logic for setup (checks duration)
    let chaosActive = chaosRoundTimer > 0;
    let count = chaosActive ? 3 : 1;
    
    for(let i=0;i<count;i++) {
        let b=new Ball(center_x, center_y, BALL_RADIUS); 
        b.reset(); 
        foreverBalls.push(b);
    }
    ball = foreverBalls[0];
   
    cars=[];
    let P1_X=100+CAR_WIDTH/2, P2_X=canvas.width-100-CAR_WIDTH/2;
    
    cars.push(new Car(P1_X,center_y,COLOR_BLUE, playerSettings.keybinds[0],'left',1,0));

    if(mode==="1v1 Multiplayer") {
        cars.push(new Car(P2_X,center_y,COLOR_RED, playerSettings.keybinds[1],'right',2,180));
    } else if(mode==="2v2 Multiplayer") {
        cars = []; 
        cars.push(new Car(P1_X, center_y+50, COLOR_BLUE, playerSettings.keybinds[0], 'left', 1, 0));
        cars.push(new Car(P1_X, center_y-50, COLOR_BLUE, playerSettings.keybinds[2], 'left', 3, 0)); 
        cars.push(new Car(P2_X, center_y-50, COLOR_RED, playerSettings.keybinds[1], 'right', 2, 180));
        cars.push(new Car(P2_X, center_y+50, COLOR_RED, playerSettings.keybinds[3], 'right', 4, 180)); 
    } else if(mode==="Vs Computer"){
        for(let i=0; i<initialAICount;i++){
            let aiY=center_y+((i%2===0)?50*(i/2):-50*Math.ceil(i/2));
            cars.push(new Car(P2_X,aiY,COLOR_RED,{},'right',2+i,180,true,aiDifficulty));
        }
        assignAIRoles(cars.filter(c=>c.ai&&!c.isFriendlyAI));
    }
    cars[0].applyPlayerUpgrades(playerUpgrades);
    goaliePad = playerUpgrades.autoGoalie ? new GoaliePad() : null;
   
    boostPads=[
        new BoostPad(canvas.width*0.5,canvas.height*0.25), new BoostPad(canvas.width*0.5,canvas.height*0.75),
        new BoostPad(canvas.width*0.25,canvas.height*0.5), new BoostPad(canvas.width*0.75,canvas.height*0.5),
        new BoostPad(canvas.width*0.5,canvas.height*0.5),
        new BoostPad(canvas.width*0.1,canvas.height*0.12), new BoostPad(canvas.width*0.9,canvas.height*0.12),
        new BoostPad(canvas.width*0.1,canvas.height*0.88), new BoostPad(canvas.width*0.9,canvas.height*0.88),
    ];
    if(playerUpgrades.extraBoostPad) {
        boostPads.push(new BoostPad(canvas.width*0.35, canvas.height*0.35));
        boostPads.push(new BoostPad(canvas.width*0.65, canvas.height*0.65));
    }
    if(playerUpgrades.freePad) boostPads.push(new BoostPad(canvas.width/2, canvas.height/2, 20));
}

function checkCarBallCollision(car, ball){
    let dx=ball.x-car.x, dy=ball.y-car.y;
    let collisionRadius=BALL_RADIUS+(CAR_WIDTH * car.sizeMultiplier * 0.5);
    let dist=Math.hypot(dx,dy);
    if(dist<collisionRadius){
        let impulseAngle=Math.atan2(dy,dx), carSpeed=car.speed, baseForce=1.0;
        let force=baseForce+carSpeed*1.5*(car.boosting?car.boostPower:1);
        
        if (!car.ai) {
            force *= (1 + (playerUpgrades.kick ? 0.1 : 0) + (playerUpgrades.kick_evo ? 0.25 : 0));
            if (playerUpgrades.doubleKick) force *= 2;
            if (playerUpgrades.doubleKick_evo) force *= 3;
        }
        
        force *= car.mass;
        ball.velX+=Math.cos(impulseAngle)*force; ball.velY+=Math.sin(impulseAngle)*force;
        
        let recoil = 1.0 / car.mass;
        if (!car.ai && (playerUpgrades.stickTires || playerUpgrades.stickTires_evo)) recoil *= 0.0;
        car.velX -= Math.cos(impulseAngle) * force * 0.5 * recoil;
        car.velY -= Math.sin(impulseAngle) * force * 0.5 * recoil;

        let overlap=collisionRadius-dist;
        if(overlap>0){ ball.x+=Math.cos(impulseAngle)*overlap; ball.y+=Math.sin(impulseAngle)*overlap; }
       
        if (!car.ai) {
             if (playerUpgrades.superStun || playerUpgrades.superStun_evo) {
                 let dur = playerUpgrades.superStun_evo ? 3.0 : 1.5;
                 cars.filter(c=>c.ai&&!c.isFriendlyAI).forEach(c => {
                     if(Math.hypot(c.x-ball.x, c.y-ball.y) < 150) { c.isStunned=true; c.stunDuration=dur; }
                 });
             }
             if (playerUpgrades.freezeTag) {
                  cars.filter(c=>c.ai&&!c.isFriendlyAI).forEach(c => {
                     if(Math.hypot(c.x-car.x, c.y-car.y) < 100) { c.effects.slow = {duration:2.0, factor:0.5}; }
                 });
             }
        }
    }
}

function checkCarCarCollision(car1, car2) {
    if ((!car1.ai && car1.effects.ghost && car2.ai) || (!car2.ai && car2.effects.ghost && car1.ai)) return;
    let radius1 = (CAR_WIDTH * car1.sizeMultiplier / 2) * 0.9;
    let radius2 = (CAR_WIDTH * car2.sizeMultiplier / 2) * 0.9;
    let collisionDistance = radius1 + radius2;
    let dx = car2.x - car1.x, dy = car2.y - car1.y;
    let dist = Math.hypot(dx, dy);
   
    if (dist < collisionDistance) {
        let angle = Math.atan2(dy, dx);
        let overlap = collisionDistance - dist;
        let sepX = Math.cos(angle)*(overlap/2 + 0.5), sepY = Math.sin(angle)*(overlap/2 + 0.5);
        car1.x-=sepX; car1.y-=sepY; car2.x+=sepX; car2.y+=sepY;
       
        let v1 = car1.velX*Math.cos(angle) + car1.velY*Math.sin(angle);
        let v2 = car2.velX*Math.cos(angle) + car2.velY*Math.sin(angle);
        let m1 = car1.mass, m2 = car2.mass;
        let v1Final = (v1 * (m1 - m2) + 2 * m2 * v2) / (m1 + m2);
        let v2Final = (v2 * (m2 - m1) + 2 * m1 * v1) / (m1 + m2);
        
        car1.velX += (v1Final - v1) * Math.cos(angle); car1.velY += (v1Final - v1) * Math.sin(angle);
        car2.velX += (v2Final - v2) * Math.cos(angle); car2.velY += (v2Final - v2) * Math.sin(angle);
    }
}

function checkGoal(ball) {
    let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
    let aiGoalHeight = (playerUpgrades.goalExpansion || playerUpgrades.goalExpansion_evo) ? GOAL_HEIGHT * 1.3 : GOAL_HEIGHT;
    if(ball.y>canvas.height/2-goalHeight/2 && ball.y<canvas.height/2+goalHeight/2 && ball.x-ball.radius<=0) return 'right'; 
    if(ball.y>canvas.height/2-aiGoalHeight/2 && ball.y<canvas.height/2+aiGoalHeight/2 && ball.x+ball.radius>=canvas.width) {
         if(cars[0].effects.goalBlock) return null;
         return 'left'; 
    }
    return null;
}

function handleGoal(scoringTeam, scoredBall) {
    if (scoringTeam === 'left') { 
        let oldLevel = playerLevel;
        scoreLeft += scoredBall.pointType;
        playerLevel += scoredBall.pointType;
        
        // Reduce Chaos Mode Duration
        if (chaosRoundTimer > 0) chaosRoundTimer--;
        updateUpgradesDisplay();

        if (endConditionType === 'forever') {
            if (Math.floor(playerLevel / 5) > Math.floor(oldLevel / 5)) pendingUpgradePick = true;
            
            if (getNumberOfAICars() < 3) {
                if (playerLevel >= 15 && getNumberOfAICars() < 2) addEnemyAICar();
                if (playerLevel >= 30 && getNumberOfAICars() < 3) addEnemyAICar();
            }

            if (playerLevel <= 100) {
                 aiDifficulty = Math.min(100, Math.floor(playerLevel / 2) + 1);
                 cars.forEach(c => { if(c.ai && !c.isFriendlyAI) c.updateDifficulty(aiDifficulty); });
            }
            
            // Warning Notification for new AI Abilities
            if (playerLevel % 10 === 0 && playerLevel >= 50) {
                showNotification("WARNING: AI MUTATION DETECTED!", false, true);
            }
        }
       
        cars[0].effects.goalBlock = { duration: 3.0 };
        cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => {
            if (playerUpgrades.aiSlow || playerUpgrades.aiSlow_evo) ai.effects.slow = { duration: 5.0, factor: (playerUpgrades.aiSlow_evo?0.2:0.5) };
            if (playerUpgrades.timeFreeze || playerUpgrades.timeFreeze_evo) { 
                ai.isStunned = true; 
                ai.stunDuration = (playerUpgrades.timeFreeze_evo?4.0:2.0); 
                ai.velX = 0; ai.velY = 0; // Force stop logic for clarity
            }
        });
       
        if(playerUpgrades.ballSplit && foreverBalls.length < 5) {
             let b = new Ball(scoredBall.x, scoredBall.y, BALL_RADIUS, 1);
             b.velX = Math.random() > 0.5 ? 10 : -10; b.velY = Math.random() > 0.5 ? 10 : -10;
             foreverBalls.push(b);
        }
    }
    else if (scoringTeam === 'right') { 
        scoreRight += scoredBall.pointType;
        if (playerUpgrades.freePad) boostPads.push(new BoostPad(canvas.width/2, canvas.height/2, 20));
        if (endConditionType === 'forever' && scoreRight >= scoreLeft + 5) {
             gameState = 'finished'; drawGameOver('ai_won'); return;
        }
    }
   
    // Reset Balls Logic (Respecting Chaos Mode)
    // Standard reset clears everything. 
    // We call reset on all cars.
    cars.forEach(c => c.reset());
    
    // If multiple balls existed (Chaos/Multiball), destroy them unless Chaos timer is active
    // Actually, easier: Nuke balls, respawn appropriate count
    foreverBalls = [];
    let chaosActive = chaosRoundTimer > 0;
    let count = chaosActive ? 3 : 1;
    
    // If score triggered multiball split, we might want to keep those? 
    // Standard game logic: Goal resets everything to center.
    for(let i=0; i<count; i++) {
        let b = new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS);
        b.reset(); // Applies chaos offsets
        foreverBalls.push(b);
    }
    
    roundTime = 0; // Reset round timer
   
    if (gameState === 'playing') {
        if (endConditionType === 'points' && (scoreLeft >= targetScore || scoreRight >= targetScore) ||
            endConditionType === 'timed' && gameTimer <= 0) {
            gameState = 'finished'; drawGameOver();
        } else if (pendingUpgradePick) {
            requestUpgradePicker(); pendingUpgradePick = false;
        }
    }
}

function update(deltaTime) {
    if (playerUpgrades.boostRain && Math.random() < 0.001) { cars[0].refillBoost(30); showNotification("Boost Leak!"); }
    if (endConditionType === 'timed') gameTimer=Math.max(0,gameTimer-deltaTime);
    
    roundTime += deltaTime; // Track round time
   
    cars.forEach(car => { car.handleInput(deltaTime); car.move(deltaTime); });
    foreverBalls.forEach(ball => ball.move(deltaTime));
    boostPads.forEach(pad => pad.update(deltaTime));
    if (goaliePad) goaliePad.update(deltaTime);

    cars.forEach(car => foreverBalls.forEach(ball => checkCarBallCollision(car, ball)));
    for(let i=0; i<cars.length; i++) for(let j=i+1; j<cars.length; j++) checkCarCarCollision(cars[i], cars[j]);
   
    cars.forEach(car => { boostPads.forEach(pad => { if (pad.checkCollision(car)) pad.consume(car); }); });
   
    let scored = [];
    foreverBalls.forEach(ball => {
        if (goaliePad) goaliePad.checkCollision(ball);
        let team = checkGoal(ball);
        if (team) scored.push({ball, team});
    });
    if (scored.length > 0) handleGoal(scored[0].team, scored[0].ball);
   
    updateUI();
}

function gameLoop(currentTime) {
    if (!['playing', 'paused', 'finished', 'upgrading'].includes(gameState)) { cancelAnimationFrame(animationFrameId); return; }
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
   
    if (gameState === 'playing') {
        update(deltaTime);
        drawField(); cars.forEach(car => car.draw()); foreverBalls.forEach(ball => ball.draw());
    } else {
        drawField(); cars.forEach(car => car.draw()); foreverBalls.forEach(ball => ball.draw());
    }
    
    if (stuckBallMessage.duration > 0) {
        ctx.save(); ctx.fillStyle = 'white'; ctx.font = 'bold 24px Inter'; ctx.textAlign = 'center';
        ctx.fillText(stuckBallMessage.text, canvas.width/2, 50); ctx.restore();
        if(gameState==='playing') stuckBallMessage.duration -= deltaTime;
    }
    if (gameState === 'playing' || gameState === 'paused' || gameState === 'finished') animationFrameId = requestAnimationFrame(gameLoop);
}

function updateUI(){
    const sLeft = document.getElementById('score-left');
    const sRight = document.getElementById('score-right');
    sLeft.textContent=`BLUE: ${scoreLeft}`;
    sRight.textContent=`RED: ${scoreRight}`;

    const foreverHud = document.getElementById('forever-hud');

    if (endConditionType === 'points') {
        document.getElementById('center-info').style.visibility = 'hidden';
        if (scoreLeft > scoreRight) { sLeft.className='text-blue-400 score-large'; sRight.className='text-red-400 score-normal'; } 
        else if (scoreRight > scoreLeft) { sRight.className='text-red-400 score-large'; sLeft.className='text-blue-400 score-normal'; } 
        else { sLeft.className='text-blue-400 score-normal'; sRight.className='text-red-400 score-normal'; }
        document.getElementById('ui-panel').classList.remove('hidden');
        document.getElementById('forever-status-panel').classList.add('hidden');
        foreverHud.classList.add('hidden');
    } 
    else if (endConditionType === 'timed') {
        document.getElementById('center-info').style.visibility = 'visible';
        let min=Math.floor(gameTimer/60), sec=Math.floor(gameTimer%60);
        const timerEl = document.getElementById('timer');
        timerEl.textContent=`${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
        document.getElementById('mode-info').textContent=`TIME`;
        if (gameTimer <= 30) timerEl.classList.add('blink-active'); else timerEl.classList.remove('blink-active');
        if (gameTimer <= 10) timerEl.classList.add('text-red-500'); else timerEl.classList.remove('text-red-500');
        document.getElementById('ui-panel').classList.remove('hidden');
        document.getElementById('forever-status-panel').classList.add('hidden');
        foreverHud.classList.add('hidden');
    } 
    else if (endConditionType === 'forever'){
        sLeft.className='text-blue-400 score-large'; sRight.className='text-red-400 score-large';
        document.getElementById('center-info').style.visibility = 'visible';
        document.getElementById('timer').textContent=`${playerLevel}`;
        document.getElementById('mode-info').textContent=`PLAYER LEVEL`;
        
        // AI Intel Update
        let numAI = getNumberOfAICars();
        document.getElementById('ai-status-lvl').textContent = aiDifficulty;
        document.getElementById('ai-count').textContent = `${numAI} Car${numAI>1?'s':''}`;
        
        const mutatorList = document.getElementById('ai-mutators-list');
        if (aiMutators.length === 0) {
            mutatorList.innerHTML = '<span class="text-gray-500 italic text-xs">None</span>';
        } else {
            mutatorList.innerHTML = aiMutators.map(m => `<span class="px-1.5 py-0.5 bg-red-900 text-red-200 text-[10px] rounded border border-red-700 font-bold">${m}</span>`).join('');
        }

        document.getElementById('ui-panel').classList.remove('hidden');
        document.getElementById('forever-status-panel').classList.remove('hidden');
        
        // New HUD Updates
        if (cars && cars[0]) {
            foreverHud.classList.remove('hidden');
            const p1 = cars[0];
            
            // Speed (Scaled to look like km/h)
            const speedKm = Math.round(p1.speed * 18); 
            const speedEl = document.getElementById('hud-speed');
            speedEl.textContent = speedKm;
            
            // Color speed based on intensity
            if (speedKm > 100) speedEl.className = 'text-purple-400 font-black text-6xl italic leading-none';
            else if (speedKm > 60) speedEl.className = 'text-yellow-400 font-black text-6xl italic leading-none';
            else speedEl.className = 'text-cyan-400 font-black text-6xl italic leading-none';

            // Stats
            document.getElementById('hud-boost-cap').textContent = p1.maxBoost >= 9999 ? '‚àû' : `${Math.round(p1.boost)}/${Math.round(p1.maxBoost)}`;
            document.getElementById('hud-mass').textContent = p1.mass.toFixed(2) + 'x';
            
            // Power (Relative to base 0.3)
            const powerPct = Math.round((p1.acceleration / 0.3) * 100);
            document.getElementById('hud-accel').textContent = powerPct + '%';

            // Grip (Side Friction x 1000 for readability)
            const gripScore = Math.round(p1.sideFrictionFactor * 1000);
            document.getElementById('hud-grip').textContent = gripScore;
            
            let fxHtml = '';
            if(p1.effects.ghost) fxHtml += '<span class="px-2 py-0.5 bg-indigo-900 text-indigo-200 text-[10px] rounded border border-indigo-500 font-bold">üëª GHOST</span>';
            if(p1.effects.invincible) fxHtml += '<span class="px-2 py-0.5 bg-yellow-900 text-yellow-200 text-[10px] rounded border border-yellow-500 font-bold">üõ°Ô∏è SHIELD</span>';
            if(p1.effects.slow) fxHtml += '<span class="px-2 py-0.5 bg-blue-900 text-blue-200 text-[10px] rounded border border-blue-500 font-bold">‚ùÑÔ∏è SLOWED</span>';
            document.getElementById('hud-effects').innerHTML = fxHtml;
        }
    }
}

function updateMenuSelectionUI(containerId, selectedIndex, type = 'menu') {
    if (type === 'menu') selectedMenuIndex = selectedIndex; else selectedUpgradeIndex = selectedIndex;
    let optionsToUpdate = (type === 'upgrade' && containerId) ? document.getElementById(containerId).children : menuOptions;
    Array.from(optionsToUpdate).forEach((child, index) => {
        child.classList.remove('menu-selected');
        if (index === selectedIndex) child.classList.add('menu-selected');
    });
}

// --- MENUS ---
function drawMainMenu() {
    gameState = 'menu';
    const overlay = document.getElementById('overlay');
    overlay.classList.add('visible'); 
    pauseBtn.classList.add('hidden');
    fullscreenBtn.classList.add('hidden');
    
    // Continue Button logic removed from here and moved to Vs Computer menu

    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-8 text-yellow-400">2D ROCKET LEAGUE<br><span class="text-sm text-white tracking-widest">MADE BY ERIC</span></h1>
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="select-mode-1v1">1v1 Multiplayer</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="select-mode-2v2">2v2 Multiplayer</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="select-mode-vs-computer">Vs Computer</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="play-online">Play Online</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="settings">Settings</div>
            </div>
        </div>
    `;
    menuOptions = document.querySelectorAll('#menu-options .clickable-option');
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}

function drawSettingsMenu() {
    gameState = 'menu'; 
    const overlay = document.getElementById('overlay');
    overlay.classList.add('visible');
    const k = (p, action) => playerSettings.keybinds[p-1][action];
    const originalSettings = JSON.parse(JSON.stringify(playerSettings));

    overlay.innerHTML = `
        <div class="text-center bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-4xl pointer-events-auto border border-gray-600 overflow-y-auto max-h-[90vh]">
            <h1 class="text-3xl font-bold mb-4 text-white">Settings</h1>
            <div class="flex flex-col md:flex-row gap-8 text-left">
                <div class="flex-1 bg-gray-700 p-4 rounded-lg">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-yellow-400">Car Sensitivity</h2>
                        <button id="reset-sens-btn" class="text-xs bg-red-600 hover:bg-red-500 px-2 py-1 rounded">Reset</button>
                    </div>
                    <div class="mb-4">
                        <label class="block mb-2">Rotation Speed: <span id="rot-val">${playerSettings.sensitivity.toFixed(1)}</span>x</label>
                        <input type="range" min="0.5" max="3.0" step="0.1" value="${playerSettings.sensitivity}" class="w-full" id="rot-slider">
                        <input type="number" min="0.5" max="3.0" step="0.1" value="${playerSettings.sensitivity}" class="w-full mt-2 bg-gray-900 border border-gray-600 rounded p-1" id="rot-input">
                    </div>
                    <div class="mt-4">
                        <p class="text-sm text-gray-400 mb-2">Test Area (Use A/D)</p>
                        <canvas id="testCanvas" width="300" height="200" class="bg-gray-900 rounded border border-gray-600"></canvas>
                    </div>
                </div>
                <div class="flex-1 bg-gray-700 p-4 rounded-lg">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-yellow-400">Controls</h2>
                        <button id="reset-keys-btn" class="text-xs bg-red-600 hover:bg-red-500 px-2 py-1 rounded">Reset All</button>
                    </div>
                    <div class="flex space-x-2 mb-4 border-b border-gray-600 pb-2 overflow-x-auto">
                        <button class="px-3 py-1 bg-blue-600 rounded text-sm tab-btn" data-tab="1">P1</button>
                        <button class="px-3 py-1 bg-gray-600 rounded text-sm tab-btn" data-tab="2">P2</button>
                        <button class="px-3 py-1 bg-gray-600 rounded text-sm tab-btn" data-tab="3">P3</button>
                        <button class="px-3 py-1 bg-gray-600 rounded text-sm tab-btn" data-tab="4">P4</button>
                    </div>
                    <div id="keybind-container"></div>
                </div>
            </div>
            <div class="mt-6 flex justify-center gap-4">
                <button id="discard-settings-btn" class="px-6 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg">Discard & Close</button>
                <button id="close-settings-btn" class="px-6 py-2 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg">Save & Close</button>
            </div>
        </div>
    `;

    const testC = document.getElementById('testCanvas');
    const testCtx = testC.getContext('2d');
    let testCarAngle = 0;
    let testLoopId;
    function runTestLoop() {
        if(!document.getElementById('testCanvas')) return;
        testCtx.clearRect(0,0,300,200);
        testCtx.fillStyle = '#111827'; testCtx.fillRect(0,0,300,200);
        let rotSpeed = 4.5 * playerSettings.sensitivity;
        if(keys['KeyA']) testCarAngle = (testCarAngle + rotSpeed) % 360;
        if(keys['KeyD']) testCarAngle = (testCarAngle - rotSpeed) % 360;
        testCtx.save(); testCtx.translate(150, 100); testCtx.rotate(-Math.PI * testCarAngle / 180);
        testCtx.fillStyle = '#0066cc'; testCtx.beginPath(); testCtx.roundRect(-25, -12.5, 50, 25, 4); testCtx.fill();
        testCtx.fillStyle = 'yellow'; testCtx.beginPath(); testCtx.roundRect(25-10, -12.5+5, 8, 15, 2); testCtx.fill();
        testCtx.restore();
        testLoopId = requestAnimationFrame(runTestLoop);
    }
    runTestLoop();

    const slider = document.getElementById('rot-slider');
    const input = document.getElementById('rot-input');
    const valDisplay = document.getElementById('rot-val');
    function updateSens(v) {
        playerSettings.sensitivity = parseFloat(v);
        slider.value = v; input.value = v; valDisplay.innerText = parseFloat(v).toFixed(1);
    }
    slider.oninput = (e) => updateSens(e.target.value);
    input.onchange = (e) => updateSens(e.target.value);
    document.getElementById('reset-sens-btn').onclick = () => updateSens(1.0);

    let activeTab = 1;
    const container = document.getElementById('keybind-container');
    const tabs = document.querySelectorAll('.tab-btn');
    function renderKeybinds(pid) {
        activeTab = pid;
        tabs.forEach(t => t.classList.replace('bg-blue-600', 'bg-gray-600'));
        document.querySelector(`.tab-btn[data-tab="${pid}"]`).classList.replace('bg-gray-600', 'bg-blue-600');
        const binds = playerSettings.keybinds[pid-1];
        container.innerHTML = Object.entries(binds).map(([action, key]) => `
            <div class="flex justify-between items-center mb-2 bg-gray-900 p-2 rounded">
                <span class="capitalize font-bold text-gray-300">${action}</span>
                <button class="key-bind-btn px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm font-mono min-w-[80px]" data-p="${pid}" data-a="${action}">${key}</button>
            </div>
        `).join('');
        document.querySelectorAll('.key-bind-btn').forEach(btn => {
            btn.onclick = () => {
                btn.innerText = '...'; btn.classList.add('bg-yellow-600');
                const handler = (e) => {
                    e.preventDefault(); const code = e.code;
                    playerSettings.keybinds[pid-1][btn.dataset.a] = code;
                    renderKeybinds(pid); window.removeEventListener('keydown', handler);
                };
                window.addEventListener('keydown', handler, {once:true});
            };
        });
    }
    tabs.forEach(t => t.onclick = () => renderKeybinds(parseInt(t.dataset.tab)));
    renderKeybinds(1);

    document.getElementById('reset-keys-btn').onclick = () => {
        playerSettings.keybinds = JSON.parse(JSON.stringify(defaultKeybinds));
        renderKeybinds(activeTab);
    };
    document.getElementById('close-settings-btn').onclick = () => { cancelAnimationFrame(testLoopId); drawMainMenu(); };
    document.getElementById('discard-settings-btn').onclick = () => {
        playerSettings = JSON.parse(JSON.stringify(originalSettings)); cancelAnimationFrame(testLoopId); drawMainMenu();
    };
}

function drawGameSettingsMenu(mode) {
    const overlay = document.getElementById('overlay');
    
    // Updated Forever Mode Logic for Vs Computer Menu
    let foreverModeSection = '';
    if (mode === 'Vs Computer') {
        let continueBtn = '';
        if (savedForeverSession) {
            continueBtn = `
                <div class="w-full p-3 bg-green-600 rounded-lg hover:bg-green-500 clickable-option border-2 border-green-400" data-action="continue-forever">
                    <span class="font-bold">CONTINUE RUN</span> <span class="text-sm block">(Level ${savedForeverSession.playerLevel})</span>
                </div>
            `;
        }
        
        foreverModeSection = `
            <h2 class="text-2xl font-bold mb-3 text-white mt-6">Forever Mode</h2>
            <div class="flex flex-col gap-4 mb-6">
                ${continueBtn}
                <div class="p-3 bg-cyan-600 rounded-lg hover:bg-cyan-500 clickable-option" data-action="start-forever">Start New Forever Run</div>
            </div>
        `;
    }

    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-lg pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">${mode}</h1>
            <div id="menu-options">
                <h2 class="text-2xl font-bold mb-3 text-white">Time Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="start-timed-1">1 Min</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="start-timed-2">2 Min</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="start-timed-5">5 Min</div>
                </div>
                <h2 class="text-2xl font-bold mb-3 text-white">Score Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="start-points-3">3 Pts</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="start-points-5">5 Pts</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="start-points-10">10 Pts</div>
                </div>
                ${foreverModeSection}
                <hr class="border-gray-500 my-6">
                <div><div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="main-menu">Back</div></div>
            </div>
        </div>
    `;
    window.currentGameModeSelection = mode;
    menuOptions = document.querySelectorAll('#menu-options .clickable-option');
    menuOptions.forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}

function drawUpgradeMenu() {
    const overlay = document.getElementById('overlay');
    overlay.classList.add('visible'); 
    drawField(); cars.forEach(car => car.draw()); foreverBalls.forEach(ball => ball.draw());
    
    const chances = currentTierChances;
    const tierText = `
        <div class="flex justify-center gap-4 mb-4 text-sm font-mono">
            <span class="text-[#fed7aa]">Bronze: ${Math.round(chances.bronze)}%</span>
            <span class="text-[#e5e7eb]">Silver: ${Math.round(chances.silver)}%</span>
            <span class="text-[#fef08a]">Gold: ${Math.round(chances.gold)}%</span>
            <span class="text-[#c7d2fe]">Plat: ${Math.round(chances.platinum)}%</span>
        </div>
    `;

    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-5xl pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-2 text-green-400">LEVEL UP! (Lvl ${playerLevel})</h1>
            ${tierText}
            <div id="upgrade-options" class="flex flex-wrap justify-center gap-6 mt-4">
                ${upgradeOptions.map((opt, index) => `
                    <div id="upgrade-${index}" data-index="${index}" class="upgrade-option-card p-4 rounded-xl w-64 text-left shadow-lg border-2 border-transparent bg-gray-600 hover:bg-gray-500 ability-level-${opt.tier}">
                        <p class="text-xl font-bold mb-1 flex items-center justify-between">
                            <span class="text-2xl mr-2">${opt.icon}</span>
                            <span class="font-mono text-xs px-2 py-1 rounded bg-black bg-opacity-20">${opt.tier.toUpperCase()}</span>
                        </p>
                        <h2 class="text-xl font-bold mb-2 text-white">${opt.label}</h2>
                        <p class="text-sm text-white opacity-90">${opt.desc}</p>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    menuOptions = document.getElementById('upgrade-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleUpgradeSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('upgrade-options', index, 'upgrade'));
    });
    selectedUpgradeIndex = 0; updateMenuSelectionUI('upgrade-options', selectedUpgradeIndex, 'upgrade');
}

function drawGameOver(reason = null) {
    const overlay = document.getElementById('overlay');
    pauseBtn.classList.add('hidden');
    fullscreenBtn.classList.add('hidden');
    overlay.classList.add('visible'); 
    let message = reason === 'ai_won' ? 'YOU LOSE!' : (scoreLeft > scoreRight ? 'BLUE TEAM WINS!' : (scoreRight > scoreLeft ? 'RED TEAM WINS!' : 'DRAW!'));
    let color = reason === 'ai_won' ? 'text-red-400' : 'text-yellow-300';
    
    // Clear save if game over in forever mode
    if (endConditionType === 'forever') savedForeverSession = null;

    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-4 text-pink-400">GAME OVER</h1>
            <p class="text-3xl font-bold mb-6 ${color}">${message}</p>
            <p class="text-xl text-gray-300 mb-6">Level: ${playerLevel} | Score: ${scoreLeft}-${scoreRight}</p>
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="restart">Play Again</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="main-menu">Main Menu</div>
            </div>
        </div>
    `;
    menuOptions = document.getElementById('menu-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI('menu-options', selectedMenuIndex);
}

function handleMenuSelection(index) {
    if (!menuOptions[index]) return;
    const selection = menuOptions[index].getAttribute('data-action');
    const mode = window.currentGameModeSelection;
    const overlay = document.getElementById('overlay');
    
    if (selection.includes('select-mode')) drawGameSettingsMenu(selection.replace('select-mode-', '').replace('vs-computer', 'Vs Computer').replace('1v1', '1v1 Multiplayer').replace('2v2', '2v2 Multiplayer'));
    else if (selection === 'start-forever') startGame('Vs Computer', 'forever');
    else if (selection === 'continue-forever') startGame('Vs Computer', 'forever', true);
    else if (selection.includes('start-timed')) { timeLimitSeconds = parseInt(selection.split('-')[2])*60; startGame(mode, 'timed'); }
    else if (selection.includes('start-points')) { targetScore = parseInt(selection.split('-')[2]); startGame(mode, 'points'); }
    else if (selection === 'play-online') window.location.href = "https://ccpspy.github.io/onlinecargame";
    else if (selection === 'restart') startGame(gameMode, endConditionType);
    else if (selection === 'main-menu') drawMainMenu();
    else if (selection === 'resume') togglePause();
    else if (selection === 'settings') drawSettingsMenu();
    else if (selection === 'save-exit') saveForeverProgress();
}

function handleUpgradeSelection(index) {
    if (!upgradeOptions[index]) return;
    const upgrade = upgradeOptions[index];
    if (upgrade.id === 'reroll' || upgrade.id === 'rerollPlus') {
        if (upgrade.id === 'reroll') upgradeRerollsUsed++;
        rerollUpgradeOptions();
    } else { applyUpgrade(upgrade); exitUpgradePicker(); }
}

function startGame(mode, endType='timed', loadSave = false) {
    gameMode = mode; endConditionType = endType; scoreLeft = 0; scoreRight = 0; aiDifficulty = 1;
    const overlay = document.getElementById('overlay');
    
    if(endType === 'forever') {
        if (loadSave && savedForeverSession) {
            // Load Save Data
            const s = savedForeverSession;
            playerLevel = s.playerLevel;
            scoreLeft = s.scoreLeft;
            scoreRight = s.scoreRight;
            aiDifficulty = s.aiDifficulty;
            playerUpgrades = JSON.parse(JSON.stringify(s.playerUpgrades));
            playerAbilities = JSON.parse(JSON.stringify(s.playerAbilities));
            extraUpgradePicks = s.extraUpgradePicks;
            chaosRoundTimer = s.chaosRoundTimer || 0;
            aiMutators = s.aiMutators || [];
            timeLimitSeconds = 99999; targetScore = 999;
            pendingUpgradePick = false;
        } else {
            // New Game
            timeLimitSeconds = 99999; targetScore = 999; playerLevel = 0; playerUpgrades = {}; playerAbilities = []; pendingUpgradePick = false;
            chaosRoundTimer = 0; aiMutators = [];
        }
    } else {
        playerUpgrades = {}; playerAbilities = []; chaosRoundTimer = 0; aiMutators = [];
    }
    
    gameTimer = timeLimitSeconds;
    roundTime = 0; // Reset round timer on start
    
    // Setup Logic
    setupGameObjects(mode, (mode === 'Vs Computer' ? 1 : 0));
    
    if (loadSave && endType === 'forever') {
        // Re-apply spawn logic for loaded upgrades (since setupGameObjects only does base cars)
        if (playerUpgrades['miniRobot'] || playerUpgrades['miniRobot_evo']) {
             let pId = 1001;
             if (!cars.some(c => c.playerId === pId)) addFriendlyAICar(pId, 'attacker', playerUpgrades['miniRobot_evo'] ? 2.0 : 1.5);
        }
        if (playerUpgrades['smolRobot']) {
             let pId = 1002;
             if (!cars.some(c => c.playerId === pId)) addFriendlyAICar(pId, 'defender', 1.0);
        }
        if ((playerUpgrades['autoGoalie'] || playerUpgrades['autoGoalie_evo']) && !goaliePad) { 
            goaliePad = new GoaliePad(); 
            if(playerUpgrades['autoGoalie_evo']) goaliePad.width = 20;
        }
        if (playerUpgrades.extraBoostPad && boostPads.length < 11) {
            boostPads.push(new BoostPad(canvas.width*0.35, canvas.height*0.35));
            boostPads.push(new BoostPad(canvas.width*0.65, canvas.height*0.65));
        }
        // Apply difficulty to pre-spawned AI
        cars.forEach(c => { if(c.ai && !c.isFriendlyAI) c.updateDifficulty(aiDifficulty); });
        
        // Add extra AI if difficulty warrants it (simple check)
        if (playerLevel >= 15 && getNumberOfAICars() < 2) addEnemyAICar();
        if (playerLevel >= 30 && getNumberOfAICars() < 3) addEnemyAICar();
    }

    updateUI(); updateUpgradesDisplay();
    
    if (endType === 'forever' && !loadSave) { 
        gameState = 'upgrading'; overlay.classList.remove('visible'); overlay.innerHTML = ''; requestUpgradePicker(); 
    } else {
        gameState = 'playing'; 
        overlay.classList.remove('visible'); 
        overlay.innerHTML = ''; 
        pauseBtn.classList.remove('hidden');
        fullscreenBtn.classList.remove('hidden');
        lastTime = performance.now();
        if (animationFrameId) cancelAnimationFrame(animationFrameId); 
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

function togglePause() {
    const overlay = document.getElementById('overlay');
    if (gameState === 'playing') {
        gameState = 'paused'; pauseBtn.innerHTML = '<span class="mr-2">‚ñ∂Ô∏è</span> Resume (P)'; overlay.classList.add('visible');
        
        let exitButton = '<div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="main-menu">Main Menu</div>';
        if (endConditionType === 'forever') {
            exitButton = '<div class="p-3 bg-purple-600 rounded-lg hover:bg-purple-500 clickable-option border-2 border-purple-400 font-bold" data-action="save-exit">Save & Exit</div>';
        }

        overlay.innerHTML = `
            <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
                <h1 class="text-5xl font-extrabold mb-8 text-red-400">PAUSED</h1>
                <div id="menu-options" class="space-y-4 text-xl">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="resume">Resume</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 clickable-option" data-action="restart">Restart</div>
                    ${exitButton}
                </div>
            </div>
        `;
        menuOptions = document.getElementById('menu-options').children;
        Array.from(menuOptions).forEach((option, index) => {
            option.addEventListener('click', () => handleMenuSelection(index));
            option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
        });
        selectedMenuIndex = 0; updateMenuSelectionUI('menu-options', selectedMenuIndex);
    } else if (gameState === 'paused') {
        gameState = 'playing'; 
        overlay.classList.remove('visible'); 
        overlay.innerHTML = ''; 
        pauseBtn.innerHTML = '<span class="mr-2">‚è∏Ô∏è</span> Pause (P)';
        
        // FIX: Do NOT start a new animation frame loop here. 
        // The game loop keeps running in the background even when paused (to draw paused state).
        // By setting gameState to 'playing', the existing loop will resume logic updates on the next frame.
    }
}

function toggleFullScreen() {
    const gc = document.getElementById('game-container');
    if (!document.fullscreenElement) gc.requestFullscreen(); else document.exitFullscreen();
}
document.addEventListener('fullscreenchange', () => {
    const gc = document.getElementById('game-container');
    const isFs = !!document.fullscreenElement;
    if (isFs) { gc.classList.add('fullscreen-active'); document.body.classList.add('fullscreen-active'); fullscreenBtn.innerHTML = 'Exit'; }
    else { gc.classList.remove('fullscreen-active'); document.body.classList.remove('fullscreen-active'); fullscreenBtn.innerHTML = 'üì∫ Fullscreen'; }
});
fullscreenBtn.addEventListener('click', toggleFullScreen);
pauseBtn.addEventListener('click', togglePause);

window.addEventListener('keydown', (e) => {
    if(e.target.tagName === 'INPUT') return;
    
    keys[e.code] = true;
    if (gameState === 'menu' || gameState === 'paused' || gameState === 'finished') {
        if (e.code === 'ArrowDown') selectedMenuIndex = (selectedMenuIndex + 1) % menuOptions.length;
        else if (e.code === 'ArrowUp') selectedMenuIndex = (selectedMenuIndex - 1 + menuOptions.length) % menuOptions.length;
        else if (e.code === 'Enter') if (menuOptions[selectedMenuIndex]) menuOptions[selectedMenuIndex].click();
        updateMenuSelectionUI(null, selectedMenuIndex); e.preventDefault();
    } else if (gameState === 'upgrading') {
        if (e.code === 'ArrowRight') selectedUpgradeIndex = (selectedUpgradeIndex + 1) % menuOptions.length;
        else if (e.code === 'ArrowLeft') selectedUpgradeIndex = (selectedUpgradeIndex - 1 + menuOptions.length) % menuOptions.length;
        else if (e.code === 'Enter') if (menuOptions[selectedUpgradeIndex]) menuOptions[selectedUpgradeIndex].click();
        updateMenuSelectionUI('upgrade-options', selectedUpgradeIndex, 'upgrade'); e.preventDefault();
    } else if (gameState === 'playing' && e.code === 'KeyP') togglePause();
});
window.addEventListener('keyup', (e) => keys[e.code] = false);

window.onload = function () { canvas.width = DEFAULT_WIDTH; canvas.height = DEFAULT_HEIGHT; drawMainMenu(); }
</script>
</body>
</html>
