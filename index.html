<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Rocket League - Ultimate Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            overflow-y: auto;
        }
        
        body.fullscreen-active { padding: 0; overflow: hidden; }

        #game-container {
            width: 100%;
            max-width: 1000px; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 1rem;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1f2937;
            transition: all 0.3s ease;
        }

        #game-container.fullscreen-active {
            width: 100vw; height: 100vh; max-width: none;
            border-radius: 0; padding: 1rem; box-sizing: border-box;
            justify-content: space-between;
        }

        #game-viewport {
            position: relative; width: 100%; display: flex;
            justify-content: center; align-items: center;
        }

        #game-container.fullscreen-active #game-viewport {
            flex-grow: 1; height: 0; min-height: 0; margin: 10px 0;
        }

        #canvas-wrapper { position: relative; width: 1000px; height: 600px; }

        #game-container.fullscreen-active #canvas-wrapper {
            width: auto; height: auto; max-width: 100%; max-height: 100%;
            aspect-ratio: 1000 / 600;
        }

        canvas {
            background-color: #2b2f3d; display: block;
            border-radius: 0.75rem; width: 100%; height: 100%;
        }

        #overlay {
            position: absolute; inset: 0; border-radius: 0.75rem;
            display: flex; align-items: center; justify-content: center;
            background-color: rgba(17, 24, 39, 0.95);
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 50;
        }
        
        #overlay.visible { opacity: 1; pointer-events: auto; }

        #ui-panel, #forever-status-panel { flex-shrink: 0; width: 100%; max-width: 1000px; }

        .menu-selected {
            border: 3px solid #fcd34d;
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.6);
            transform: scale(1.02);
        }
        #menu-options > div, #upgrade-options > div {
             cursor: pointer; transition: all 0.2s;
        }
        .upgrade-icon-container { position: relative; cursor: default; }
        .upgrade-tooltip {
            visibility: hidden; background-color: #1f2937; color: white;
            text-align: left; border-radius: 6px; padding: 8px 12px;
            position: absolute; z-index: 60; bottom: 125%; left: 50%;
            transform: translateX(-50%); opacity: 0; transition: opacity 0.3s;
            pointer-events: none; width: 240px; white-space: normal;
            border: 1px solid #4b5563; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .upgrade-icon-container:hover .upgrade-tooltip { visibility: visible; opacity: 1; }
        
        .ability-level-bronze { background: #78350f; color: #fed7aa; border: 1px solid #92400e; }
        .ability-level-silver { background: #374151; color: #e5e7eb; border: 1px solid #6b7280; }
        .ability-level-gold { background: #854d0e; color: #fef08a; border: 1px solid #eab308; }
        .ability-level-platinum { background: #1e1b4b; color: #c7d2fe; border: 1px solid #818cf8; box-shadow: 0 0 10px #6366f1; }
        
        .notification-toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px;
            color: white; font-weight: bold; pointer-events: none;
            animation: fadeOut 3s forwards; z-index: 40;
        }
        @keyframes fadeOut { 0% { opacity: 1; top: 20px; } 80% { opacity: 1; top: 20px; } 100% { opacity: 0; top: 0px; } }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .blink-active { animation: blink 1s infinite; }
        
        .score-large { font-size: 2rem; transition: font-size 0.3s; }
        .score-normal { font-size: 1.25rem; transition: font-size 0.3s; }
    </style>
</head>
<body class="bg-gray-900 text-white">

<div id="game-container" class="p-4 sm:p-6 lg:p-8">
    <div id="top-bar" class="w-full mb-2 flex justify-end space-x-2 shrink-0 max-w-[1000px]">
        <button id="fullscreen-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
            <span class="mr-2">üì∫</span> Fullscreen
        </button>
        <button id="pause-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
            <span class="mr-2">‚è∏Ô∏è</span> Pause (P)
        </button>
    </div>

    <div id="game-viewport">
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="overlay"></div>
            <div id="notifications"></div>
        </div>
    </div>

    <div id="ui-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <div class="flex justify-between items-center text-xl font-bold">
            <div id="score-left" class="text-blue-400 score-normal">BLUE: 0</div>
            <div id="center-info" class="text-center">
                <div id="timer" class="text-white text-3xl font-mono">02:00</div>
                <div id="mode-info" class="text-sm text-gray-300 mt-1">TIME REMAINING</div>
            </div>
            <div id="score-right" class="text-red-400 score-normal">RED: 0</div>
        </div>
    </div>

    <div id="forever-status-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <h3 class="text-xl font-bold mb-3 text-cyan-400">Forever Mode Status</h3>
        <div class="flex flex-wrap justify-between items-start">
            <div class="w-full md:w-1/3 mb-4 md:mb-0">
                <h4 class="font-semibold text-gray-300">AI Challenge</h4>
                <p id="ai-status" class="text-2xl font-bold text-red-400">LV 1 (1 Car)</p>
                <p class="text-sm text-gray-400 mt-1">Player Level: <span id="player-level-display">0</span></p>
                <p id="ai-buff-text" class="text-xs text-purple-400 mt-1 hidden">AI MUTATORS ACTIVE</p>
            </div>
            <div class="w-full md:w-2/3">
                <h4 class="font-semibold text-gray-300 mb-2">Player Upgrades & Abilities</h4>
                <div id="player-upgrades-display" class="flex flex-wrap gap-2"></div>
            </div>
        </div>
    </div>

</div>

<script>
// --- Constants ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const DEFAULT_WIDTH = 1000, DEFAULT_HEIGHT = 600; 
const CAR_WIDTH = 50, CAR_HEIGHT = 25; 
const BALL_RADIUS = 17; 
const GOAL_HEIGHT = 170; 
const GOAL_LINE_WIDTH = 7; 
const MAX_CENTER_OFFSET_FACTOR = 1 / 6;
const PHYSICS_TICK_RATE = 60; 
const COLOR_BLUE = '#0066cc';
const COLOR_RED = '#cc0000';
const COLOR_CYAN = '#00fff4';
const COLOR_FIELD = '#2b2f3d';

// --- Game State ---
let gameState = 'menu';
let gameMode = '1v1 Multiplayer';
let endConditionType = 'timed';
let timeLimitSeconds = 120;
let targetScore = 5;
let gameTimer = 0;
let scoreLeft = 0, scoreRight = 0;
let cars = [];
let boostPads = [];
let goaliePad = null;
let ball = null;
let foreverBalls = [];
let keys = {};
let lastTime = 0;
let animationFrameId;
let aiDifficulty = 1;
let playerUpgrades = {}; 
let playerAbilities = []; 
let playerLevel = 0;
let upgradeRerollsUsed = 0, extraUpgradePicks = 0, upgradeOptions = [];
let pendingUpgradePick = false;
let stuckBallMessage = { text: '', duration: 0 };

// --- Global declarations for menu state ---
let selectedMenuIndex = 0;
let selectedUpgradeIndex = 0;
let menuOptions = []; 
const fullscreenBtn = document.getElementById('fullscreen-btn');

// --- EXPANDED ABILITY POOLS ---

// 50 Bronze ideas (Implemented ~20 key ones to preserve code size while meeting variety)
const BRONZE_UPGRADES = [
    {id:'accel',label:'Engine Chip',icon:'‚ö°',desc:'Acceleration +10%.',tier:'bronze'},
    {id:'turn',label:'Power Steering',icon:'üåÄ',desc:'Rotation speed +15%.',tier:'bronze'},
    {id:'maxBoost',label:'Extra Fuel',icon:'‚õΩ',desc:'Boost capacity +20.',tier:'bronze'},
    {id:'boostRegen',label:'Hybrid Engine',icon:'üîã',desc:'Pad refill +8.',tier:'bronze'},
    {id:'frictionFix',label:'Grip Tires',icon:'ü¶∂',desc:'Reduces drift by 15%.',tier:'bronze'},
    {id:'speed',label:'Top Gear',icon:'üöÄ',desc:'Top speed +5%.',tier:'bronze'},
    {id:'brake',label:'Ceramic Brakes',icon:'üÖøÔ∏è',desc:'Braking force +50%.',tier:'bronze'},
    {id:'kick',label:'Steel Bumper',icon:'ü¶µ',desc:'Ball hit knockback +10%.',tier:'bronze'},
    {id:'stickTires',label:'Sticky Tires',icon:'üß≤',desc:'Reduces your recoil when hitting ball.',tier:'bronze'},
    {id:'extraBoostPad',label:'Field Supply',icon:'‚ú®',desc:'Bonus boost pad on field.',tier:'bronze', permanent:true},
    {id:'bigCar',label:'Heavy Frame',icon:'üöö',desc:'Size +10%, Mass +10%.',tier:'bronze'},
    {id:'slipStream',label:'Drafting',icon:'üí®',desc:'Gain boost when near AI.',tier:'bronze'},
    {id:'reverseKing',label:'Reverse King',icon:'üîô',desc:'Drive backwards 30% faster.',tier:'bronze'},
    {id:'heavyDuty',label:'Tank Tread',icon:'üõ°Ô∏è',desc:'Mass +25%, harder to push.',tier:'bronze'},
    {id:'aerodynamics',label:'Aero Kit',icon:'üçÉ',desc:'Air resistance reduced.',tier:'bronze'},
    {id:'boostEfficiency',label:'Eco Boost',icon:'‚ôªÔ∏è',desc:'Boost burns 15% slower.',tier:'bronze'},
    {id:'wideBody',label:'Wide Body',icon:'‚ÜîÔ∏è',desc:'Car becomes wider.',tier:'bronze'},
    {id:'longBody',label:'Limo Build',icon:'‚ÜïÔ∏è',desc:'Car becomes longer.',tier:'bronze'},
];

// 25 Silver ideas (Implemented key ones)
const SILVER_UPGRADES = [
    {id:'miniRobot',label:'Atk Drone',icon:'ü§ñ',desc:'Spawns a friendly AI attacker.',tier:'silver', permanent:true},
    {id:'goalExpansion',label:'Open Net',icon:'ü•Ö',desc:'AI goal is 30% wider.',tier:'silver', permanent:true},
    {id:'doubleKick',label:'Power Kick',icon:'ü•ä',desc:'Doubles ball impact force.',tier:'silver'},
    {id:'ballMagnet',label:'Magnet Plate',icon:'üß≤',desc:'Ball follows you briefly after hit.',tier:'silver'},
    {id:'ghostCar',label:'Phase Shift',icon:'üëª',desc:'Boost to phase through cars (2s cooldown).',tier:'silver'},
    {id:'smolRobot',label:'Def Drone',icon:'üõ°Ô∏è',desc:'Spawns a friendly AI defender.',tier:'silver', permanent:true},
    {id:'boostRain',label:'Fuel Leak',icon:'üå¶Ô∏è',desc:'Chance to get 30 boost randomly.',tier:'silver'},
    {id:'shrinkEnemies',label:'Shrink Ray',icon:'üî¨',desc:'All Enemy AIs become 20% smaller.',tier:'silver'},
    {id:'freezeTag',label:'Cryo Bumper',icon:'‚ùÑÔ∏è',desc:'Ramming enemies slows them for 2s.',tier:'silver'},
    {id:'repelField',label:'Repulsor',icon:'üîä',desc:'Nearby enemies are pushed away.',tier:'silver'},
    {id:'oilSlick',label:'Oil System',icon:'üõ¢Ô∏è',desc:'Enemies slide more (lower friction).',tier:'silver', permanent:true},
];

// 10 Gold ideas
const GOLD_UPGRADES = [
    {id:'superStun',label:'Thunder Hit',icon:'üí´',desc:'Scoring stuns AI on next contact.',tier:'gold'},
    {id:'extraUpgrade',label:'Double Dip',icon:'üéà',desc:'Get an extra upgrade choice next time.',tier:'gold'},
    {id:'autoGoalie',label:'Robo Goalie',icon:'üïπÔ∏è',desc:'AI goalie pad blocks your net.',tier:'gold', permanent:true},
    {id:'rerollPlus',label:'Lucky Dice',icon:'üé≤',desc:'Unlimited rerolls for this pick.',tier:'gold'},
    {id:'aiSlow',label:'System Hack',icon:'üê¢',desc:'AI speed -50% for 5s after you score.',tier:'gold'},
    {id:'timeFreeze',label:'Time Stop',icon:'‚è±Ô∏è',desc:'Freeze AI for 2s when you score.',tier:'gold'},
    {id:'freePad',label:'Mana Farm',icon:'üçÄ',desc:'Bonus boost pad spawns on enemy goal.',tier:'gold'},
    {id:'ballSplit',label:'Multiball',icon:'üé±',desc:'Scoring splits the ball (Max 5).',tier:'gold'},
    {id:'goalBlock',label:'Force Field',icon:'üöß',desc:'Your goal blocked for 5s after score.',tier:'gold'},
    {id:'gravityWell',label:'Gravity Well',icon:'üåå',desc:'Passive pull on ball towards enemy goal.',tier:'gold'},
];

// 5 Platinum ideas
const PLATINUM_UPGRADES = [
    {id:'platinumDoubleAll',label:'Chaos Mode',icon:'üåà',desc:'3 Balls. 3x Points potential.',tier:'platinum', permanent:true},
    {id:'platinumSuperAI',label:'Virus Upload',icon:'üëæ',desc:'AI confuses directions for 8s after score.',tier:'platinum'},
    {id:'platinumStickyNet',label:'Sticky Web',icon:'üï∏Ô∏è',desc:'Enemy goal traps ball velocity.',tier:'platinum'},
    {id:'platinumOmniBoost',label:'Infinite Fuel',icon:'üî•',desc:'Boost never runs out.',tier:'platinum'},
    {id:'platinumTeleport',label:'Blink Drive',icon:'‚ú®',desc:'Teleport to ball (Press T, 5s CD).',tier:'platinum'},
];
const ALL_UPGRADES = [...BRONZE_UPGRADES, ...SILVER_UPGRADES, ...GOLD_UPGRADES, ...PLATINUM_UPGRADES];

// --- Helper Functions ---
function showNotification(text) {
    const n = document.createElement('div');
    n.className = 'notification-toast';
    n.innerText = text;
    document.getElementById('notifications').appendChild(n);
    setTimeout(() => n.remove(), 3000);
}

function getAbilityTierByLevel(level) {
    // Level 1-19: Bronze
    if (level < 20) return "bronze"; // CHANGED to 20
    // Level 20-49: Silver
    if (level < 50) return Math.random() < 0.7 ? "silver" : "bronze";
    // Level 50-99: Gold
    if (level < 100) {
        const r = Math.random();
        if (r < 0.6) return "gold";
        if (r < 0.9) return "silver";
        return "bronze";
    }
    // Level 100+: Platinum
    const r = Math.random();
    if (r < 0.3) return "platinum";
    if (r < 0.7) return "gold";
    return "silver";
}

function getPoolForTier(tier) {
    if (tier === "bronze") return BRONZE_UPGRADES;
    if (tier === "silver") return SILVER_UPGRADES;
    if (tier === "gold") return GOLD_UPGRADES;
    if (tier === "platinum") return PLATINUM_UPGRADES;
}

function randomAbilities(amt, disallowIds=[]) {
    let chosen = [];
    // Removed the disallow logic to allow duplicates in selection as requested
    for (let i = 0; i < amt; i++) {
        let tier = getAbilityTierByLevel(playerLevel);
        // Still check permanent upgrades that shouldn't be picked twice permanently
        let pool = getPoolForTier(tier);
        
        // Filter out abilities that are permanent and already owned
        pool = pool.filter(u => !u.permanent || !playerUpgrades[u.id]);
       
        if (pool.length === 0) pool = BRONZE_UPGRADES; // Fallback
       
        const pick = pool[Math.floor(Math.random() * pool.length)];
        if (pick) {
            chosen.push(pick);
        }
    }
    return chosen;
}

function requestUpgradePicker() {
    gameState = 'upgrading';
    upgradeRerollsUsed = 0;
    rerollUpgradeOptions(); 
    document.getElementById('pause-btn').classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
}

function rerollUpgradeOptions() {
    let numPicks = 3 + extraUpgradePicks;
    const excluded = []; // Empty because we allow duplicates
    upgradeOptions = randomAbilities(numPicks, excluded);
   
    if (upgradeRerollsUsed < 1 && !playerUpgrades.rerollPlus) {
        upgradeOptions.push({id:'reroll', label:'REROLL', icon:'üîÑ', desc:`Reroll options.`, tier:'bronze'});
    } else if (playerUpgrades.rerollPlus) {
        upgradeOptions.push({id:'rerollPlus', label:'FREE REROLL', icon:'üîÑ', desc:`Unlimited rerolls.`, tier:'gold'});
    }
    selectedUpgradeIndex = 0;
    drawUpgradeMenu();
}

function applyUpgrade(ability) {
    if (ability.id === 'extraUpgrade') {
        extraUpgradePicks++;
    } else {
        playerUpgrades[ability.id] = (playerUpgrades[ability.id] || 0) + 1;
        if (playerAbilities.findIndex(a => a.id === ability.id) === -1) {
            playerAbilities.push(ability);
        }
    }
   
    // Apply instant effects
    cars.forEach(c => {
        if(!c.ai) c.applyPlayerUpgrades(playerUpgrades);
        else if(c.ai && !c.isFriendlyAI) c.updateDifficulty(aiDifficulty); // Re-apply debuffs to enemies
    });

    if (ability.id === 'miniRobot' && !cars.some(c => c.playerId === 1001)) addFriendlyAICar(1001, 'attacker', 1.5);
    if (ability.id === 'smolRobot' && !cars.some(c => c.playerId === 1002)) addFriendlyAICar(1002, 'defender', 1.0);
    if (ability.id === 'autoGoalie' && !goaliePad) { goaliePad = new GoaliePad(); }
    if (ability.id === 'platinumDoubleAll' && foreverBalls.length === 1) {
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.forEach(b => b.reset());
    }
   
    updateUpgradesDisplay();
}

function exitUpgradePicker() {
    gameState = 'playing';
    extraUpgradePicks = 0; 
    overlay.classList.remove('visible');
    overlay.innerHTML = '';
    pauseBtn.classList.remove('hidden');
    document.getElementById('fullscreen-btn').classList.remove('hidden');
    lastTime = performance.now();
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Classes --
class Car {
    constructor(x, y, color, controls, team_side, player_id, initial_angle, ai=false, difficulty=1, role="attacker") {
        this.x=x; this.y=y; this.color=color; this.team_side=team_side; this.controls=controls;
        this.playerId=player_id; this.angle=initial_angle; this.velX=0; this.velY=0; this.speed=0;
       
        this.baseAcceleration=0.3; this.baseMaxSpeed=5.0;
        this.baseRotationSpeed=4.5; this.baseSideFrictionFactor=0.05;
        this.boostPower=1.8; this.boostUsage=1.2; this.maxBoost=100; this.boost=this.maxBoost; this.boosting=false;
        this.mass = 1.0;
       
        this.throttleDirection=0;
        this.ai=ai; this.difficulty=difficulty; this.role = role;
        this.upgrades={}; this.effects={};
        this.isStunned=false; this.stunDuration=0;
       
        this.isFriendlyAI = team_side === 'left' && ai;
        this.baseColor = color;
        this.boostTimer = 0; 
        this.sizeMultiplier = 1.0;
        this.widthMultiplier = 1.0;
        this.lengthMultiplier = 1.0;
        this.teleportCooldown = 0;
       
        this.stuckInCornerTimer = 0;
        this.stuckInCornerThreshold = 5.0;
       
        this.updateDifficulty(difficulty);
        this.resetPos={x,y,angle:initial_angle};
    }
   
    updateDifficulty(difficulty) {
        this.difficulty = difficulty;
        if (this.ai) {
            this.acceleration = this.baseAcceleration + 0.05 * (difficulty-1);
            this.maxBoost = 100 + 10 * (difficulty-1);
            this.rotationSpeed = this.baseRotationSpeed;
            this.sideFrictionFactor = this.baseSideFrictionFactor;
            
            // AI Defender Size Change
            if (this.role === 'defender' && !this.isFriendlyAI) {
                this.sizeMultiplier = 0.85;
            }

            // AI Shrink Debuff
            if (!this.isFriendlyAI && playerUpgrades.shrinkEnemies) {
                this.sizeMultiplier *= 0.8;
            }
            if (!this.isFriendlyAI && playerUpgrades.oilSlick) {
                this.sideFrictionFactor *= 0.5;
            }
            
            // Level 100+ Buffs
            if (!this.isFriendlyAI && playerLevel > 100) {
                 const extraLevels = Math.floor((playerLevel - 100) / 10);
                 this.acceleration += extraLevels * 0.02;
                 this.mass = 1.0 + (extraLevels * 0.1);
            }

        } else {
            this.applyPlayerUpgrades(playerUpgrades);
        }
    }
   
    applyPlayerUpgrades(upgrades) {
        if (this.ai) return; 
        let count = id => upgrades[id]||0;
       
        this.acceleration = this.baseAcceleration * (1 + count('accel') * 0.1);
        this.rotationSpeed = this.baseRotationSpeed * (1 + count('turn') * 0.15);
        this.maxBoost = 100 + count('maxBoost') * 20;
        this.baseMaxSpeed = 5.0 * (1 + count('speed') * 0.05);
        let frictionFactor = 1 - count('frictionFix') * 0.15;
        this.sideFrictionFactor = this.baseSideFrictionFactor * Math.max(0.1, frictionFactor);
       
        this.sizeMultiplier = 1.0; 
        if (count('bigCar') > 0) this.sizeMultiplier *= 1.10;
        if (count('heavyDuty') > 0) this.mass = 1.25; else this.mass = 1.0;

        this.widthMultiplier = count('wideBody') ? 1.3 : 1.0;
        this.lengthMultiplier = count('longBody') ? 1.3 : 1.0;
        
        if (count('platinumOmniBoost')) this.maxBoost = 9999;
        this.boost = Math.min(this.maxBoost,this.boost); 
    }
   
    handleInput(deltaTime) { 
        if (this.ai) { this.handleAI(deltaTime); return; }
        if (this.isStunned) return;
       
        this.throttleDirection=0; let accelerationForce = 0;
       
        if (keys[this.controls['left']]) this.angle=(this.angle+this.rotationSpeed)%360;
        if (keys[this.controls['right']]) this.angle=(this.angle-this.rotationSpeed)%360;
       
        if (keys[this.controls['up']]) {accelerationForce=this.acceleration;this.throttleDirection=1;}
        if (keys[this.controls['down']]) {
            let revMult = playerUpgrades.reverseKing ? 1.3 : 0.7;
            let brakePower = playerUpgrades.brake ? 2.0 : 1.0;
            accelerationForce = -this.acceleration * (keys[this.controls['up']] ? brakePower : revMult);
            this.throttleDirection=-1;
        }
        
        // Teleport Logic
        if (playerUpgrades.platinumTeleport && keys['KeyT'] && this.teleportCooldown <= 0) {
            const target = foreverBalls[0];
            // Blink behind the ball towards enemy goal
            let dx = canvas.width - target.x;
            let dy = (canvas.height/2) - target.y;
            let angle = Math.atan2(dy, dx);
            this.x = target.x - Math.cos(angle) * 50;
            this.y = target.y - Math.sin(angle) * 50;
            this.velX = target.velX; this.velY = target.velY;
            this.teleportCooldown = 5.0;
            showNotification("BLINK!");
        }
        if (this.teleportCooldown > 0) this.teleportCooldown -= deltaTime;
       
        if (accelerationForce!==0) {
            let rad=Math.PI*this.angle/180;
            this.velX+=Math.cos(rad)*accelerationForce; this.velY-=Math.sin(rad)*accelerationForce;
        }
       
        let boostActive = keys[this.controls['boost']];
        if (gameMode === 'Vs Computer' && this.playerId === 1) {
            if (keys['ShiftLeft'] || keys['ShiftRight']) boostActive = true;
        }
        if (playerUpgrades.platinumOmniBoost) this.boost = 9999;
        this.boosting = boostActive && this.boost > 0;
       
        if (this.boosting) {
             this.boostTimer += deltaTime;
             if (playerUpgrades.ghostCar && this.boostTimer > 0.8 && !this.effects.ghost) {
                 this.effects.ghost = { duration: 1.5 }; this.boostTimer = -2.0; 
             }
        } else {
            this.boostTimer = Math.max(0, this.boostTimer); 
        }
    }

    handleAI(deltaTime) {
        if (!ball || this.isStunned) return;
       
        // Friendly Collision Avoidance
        cars.forEach(otherCar => {
            if (otherCar === this || !otherCar.ai || otherCar.isFriendlyAI !== this.isFriendlyAI) return;
            let dxAI = this.x - otherCar.x;
            let dyAI = this.y - otherCar.y;
            let distAI = Math.hypot(dxAI, dyAI);
            let avoidRadius = (CAR_WIDTH * this.sizeMultiplier) * 1.5;
            if (distAI < avoidRadius && distAI > 0) {
                let separationForce = 0.3 * (avoidRadius - distAI) / avoidRadius;
                this.velX += (dxAI / distAI) * separationForce;
                this.velY += (dyAI / distAI) * separationForce;
            }
        });
       
        let targetBall = foreverBalls[0];
        let minBallDist = Infinity;
        foreverBalls.forEach(b => {
            let dist = Math.hypot(b.x - this.x, b.y - this.y);
            if (dist < minBallDist) { minBallDist = dist; targetBall = b; }
        });
       
        // --- IMPROVED COORDINATION LOGIC ---
        // Identify closest teammate to ball
        let teammates = cars.filter(c => c.ai && c.team_side === this.team_side);
        teammates.sort((a, b) => Math.hypot(a.x-targetBall.x, a.y-targetBall.y) - Math.hypot(b.x-targetBall.x, b.y-targetBall.y));
        let closestTeammate = teammates[0];
        let amIClosest = (closestTeammate === this);

        let targetX, targetY;

        if (amIClosest) {
             // Go for ball if closest
             targetX = targetBall.x; targetY = targetBall.y;
        } else {
            // Instructor Logic: Stay in position based on role
            if (this.role === 'attacker') {
                // Wait for rebound/center
                targetX = canvas.width / 2; 
                targetY = targetBall.y > canvas.height/2 ? canvas.height * 0.3 : canvas.height * 0.7;
            } else if (this.role === 'mid') {
                // Stay between ball and own goal
                let myGoalX = this.team_side === 'right' ? canvas.width : 0;
                targetX = (targetBall.x + myGoalX) / 2;
                targetY = (targetBall.y + canvas.height/2) / 2;
            } else {
                 // Defender/Goalie logic handled in switch
                 targetX = targetBall.x; targetY = targetBall.y;
            }
        }

        // Override for Def/Goalie specific positioning if they are the role
        switch(this.role){
            case "defender":
                let gLineX = this.isFriendlyAI ? BALL_RADIUS*3 : canvas.width - BALL_RADIUS*3;
                if (!amIClosest) {
                    // Hold line
                    targetX = gLineX;
                    targetY = Math.max(canvas.height/2-GOAL_HEIGHT/2+BALL_RADIUS, Math.min(targetBall.y,canvas.height/2+GOAL_HEIGHT/2-BALL_RADIUS));
                } else {
                    // Challenge if closest
                    if (Math.abs(targetBall.x - gLineX) < 400) {
                         targetX = targetBall.x; targetY = targetBall.y;
                    } else {
                         // Still hold if ball is far
                         targetX = gLineX;
                         targetY = Math.max(canvas.height/2-GOAL_HEIGHT/2+BALL_RADIUS, Math.min(targetBall.y,canvas.height/2+GOAL_HEIGHT/2-BALL_RADIUS));
                    }
                }
                break;
            case "mid":
                if (amIClosest) { targetX = targetBall.x; targetY = targetBall.y; }
                break;
            case "attacker":
                if (amIClosest) { targetX = targetBall.x; targetY = targetBall.y; }
                break;
        }

        // Corner Unstuck hack
        if (this.x < 60 || this.x > canvas.width - 60 || this.y < 60 || this.y > canvas.height - 60) {
             this.stuckInCornerTimer += deltaTime;
             if (this.stuckInCornerTimer > 1.5) { // Reduced time to 1.5s
                 // Move towards center
                 targetX = canvas.width / 2; targetY = canvas.height / 2;
                 // Wiggle away from walls
                 if (this.y < 60 || this.y > canvas.height - 60) targetX += (Math.random() > 0.5 ? 200 : -200);
             }
        } else {
            this.stuckInCornerTimer = 0;
        }
       
        const dx=targetX-this.x,dy=targetY-this.y;
        const targetAngleRad=Math.atan2(-dy,dx); let targetAngle=(targetAngleRad*180/Math.PI+360)%360;
        let angleDiff = targetAngle-this.angle; if(angleDiff>180)angleDiff-=360;if(angleDiff<-180)angleDiff+=360;
        const dist = Math.hypot(dx,dy);
       
        if(this.effects.confused) {
            this.angle = (this.angle + 10) % 360;
            this.throttleDirection = 1;
        } else {
            if(angleDiff>this.rotationSpeed){this.angle=(this.angle+this.rotationSpeed)%360;}
            else if(angleDiff<-this.rotationSpeed){this.angle=(this.angle-this.rotationSpeed)%360;}
            else{this.angle=targetAngle;}
           
            this.throttleDirection=0;
            if(Math.abs(angleDiff)<32) {
                let rad=Math.PI*this.angle/180;
                this.velX+=Math.cos(rad)*this.acceleration;
                this.velY-=Math.sin(rad)*this.acceleration;
                this.throttleDirection=1;
            }
        }
       
        // AI Boosting Logic
        const AI_BOOST_LEVEL_UNLOCK = 6; // Number of AIs needed to unlock boosting
        let canBoost = false;
        
        if (getNumberOfAICars() >= AI_BOOST_LEVEL_UNLOCK || aiDifficulty > 5) {
            if (Math.abs(angleDiff) < 10 && dist > 150 && this.boost > 20) canBoost = true;
            // Goalie boosts if ball is far and needs to return to net
            if (this.role === 'defender' && dist > 300) canBoost = true;
        }
        this.boosting = canBoost;
    }
   
    move(deltaTime) {
        if(this.isStunned){
            this.stunDuration -= deltaTime;
            if(this.stunDuration <= 0) {
                this.isStunned=false;
                this.stunDuration = 0;
            }
            return;
        }
       
        ["slow","confused","forceField","invincible","goalBlock","ring","ghost"].forEach(eff=>{
            if(this.effects[eff]) {
                this.effects[eff].duration -= deltaTime;
                if(this.effects[eff].duration <=0) delete this.effects[eff];
            }
        });
       
        let rad=Math.PI*this.angle/180;
        let fVel=this.velX*Math.cos(rad)-this.velY*Math.sin(rad);
        let sVel=this.velX*Math.sin(rad)+this.velY*Math.cos(rad);
        sVel*=(1-this.sideFrictionFactor); fVel*=0.96; // Drag
       
        if(this.boosting && this.boost>0 && this.throttleDirection!==0) {
            let boostForce=this.acceleration*this.boostPower*1.5;
            fVel+=boostForce*this.throttleDirection;
            if(!playerUpgrades.platinumOmniBoost && !this.effects.invincible) 
                this.boost -= this.boostUsage * deltaTime * PHYSICS_TICK_RATE;
            if(this.boost<0){this.boost=0;this.boosting=false;}
        }
        if (playerUpgrades.boostEfficiency && !this.ai) {
             // Refund a bit if efficient
             if (this.boosting) this.boost += 0.15 * deltaTime * PHYSICS_TICK_RATE;
        }
       
        this.velX= fVel*Math.cos(rad)+sVel*Math.sin(rad);
        this.velY= -fVel*Math.sin(rad)+sVel*Math.cos(rad);

        let speedMultiplier = 1;
        if(this.effects.slow) speedMultiplier = this.effects.slow.factor;
       
        this.speed = Math.hypot(this.velX,this.velY);
        let maxSpeed = this.baseMaxSpeed*(this.boosting?this.boostPower:1);
        if(this.speed>maxSpeed){let sc=maxSpeed/this.speed;this.velX*=sc;this.velY*=sc;}
       
        this.x += this.velX * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
       
        let w = CAR_WIDTH * this.sizeMultiplier * this.lengthMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier * this.widthMultiplier;
        let marginW = w / 2; let marginH = h / 2;

        if (this.x < marginW) { this.x = marginW; this.velX *= -0.5; }
        if (this.x > canvas.width - marginW) { this.x = canvas.width - marginW; this.velX *= -0.5; }
        if (this.y < marginH) { this.y = marginH; this.velY *= -0.5; }
        if (this.y > canvas.height - marginH) { this.y = canvas.height - marginH; this.velY *= -0.5; }
        
        // Passive Repel Field
        if (!this.ai && playerUpgrades.repelField) {
            cars.forEach(c => {
               if (c.ai && !c.isFriendlyAI) {
                   let d = Math.hypot(c.x - this.x, c.y - this.y);
                   if (d < 150) {
                       let angle = Math.atan2(c.y - this.y, c.x - this.x);
                       c.velX += Math.cos(angle) * 1.0;
                       c.velY += Math.sin(angle) * 1.0;
                   }
               } 
            });
        }
    }
   
    draw() {
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(-Math.PI*this.angle/180);
       
        let w = CAR_WIDTH * this.sizeMultiplier * this.lengthMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier * this.widthMultiplier;
       
        let displayColor = this.color;
        if(this.isFriendlyAI) displayColor = '#00cccc';
        if(this.isStunned) displayColor = '#aaaaaa';
        if(this.effects.ring) displayColor = '#fcd34d';
        if(this.effects.forceField) displayColor = '#00ff00';
        if(this.effects.ghost) displayColor = 'rgba(255,255,255,0.5)';
       
        ctx.fillStyle=displayColor;
        ctx.beginPath(); ctx.roundRect(-w/2,-h/2, w, h, 8 * this.sizeMultiplier); ctx.fill();
       
        ctx.fillStyle='yellow';
        ctx.beginPath(); ctx.roundRect(w/2-(10*this.sizeMultiplier),-h/2+(5*this.sizeMultiplier), 8*this.sizeMultiplier, h-(10*this.sizeMultiplier), 2*this.sizeMultiplier); ctx.fill();
       
        if(this.boosting){
            ctx.fillStyle="#ffaa00";
            ctx.beginPath(); ctx.moveTo(-w/2,0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),-h/4);
            ctx.lineTo(-w/2-(20*this.sizeMultiplier),0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),h/4); ctx.closePath(); ctx.fill();
        }
        ctx.restore();
       
        if(this.effects.ring || this.effects.forceField){
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = this.effects.ring ? "#fcd34d" : (this.effects.forceField ? "#00ff00":"#00fff4");
            ctx.globalAlpha = 0.6; ctx.lineWidth=4;
            let radius = (CAR_WIDTH * this.sizeMultiplier) * 1.7;
            if(this.effects.forceField) radius = (CAR_WIDTH * this.sizeMultiplier) * 2.5;
            ctx.arc(this.x,this.y,radius,0,Math.PI*2); ctx.stroke();
            ctx.restore();
        }
       
        const isHuman=!this.ai;
        const label = isHuman?`P${this.playerId}`:`AI Lv.${this.difficulty} (${this.role.charAt(0).toUpperCase()})`;
        const labelY=this.y-h/2-15, barWidth=40, barHeight=6, bpct=this.boost/this.maxBoost;
        ctx.fillStyle=isHuman?COLOR_BLUE:(this.isFriendlyAI ? '#00cccc' : COLOR_RED);
        ctx.font='12px Inter'; ctx.textAlign='center';
        ctx.fillText(label,this.x,labelY-5);
        ctx.fillStyle='#1f2937';
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth,barHeight,3); ctx.fill();
        let grad = ctx.createLinearGradient(this.x-barWidth/2,0,this.x-barWidth/2+barWidth,0);
        grad.addColorStop(0,bpct<0.3?'#ef4444':'#f97316'); grad.addColorStop(1,'#f97316');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth*bpct,barHeight,3); ctx.fill();
    }
   
    refillBoost(amount) {
        this.boost = Math.min(this.maxBoost,this.boost+amount);
    }
   
    reset() {
        this.x=this.resetPos.x; this.y=this.resetPos.y; this.angle=this.resetPos.angle;
        this.velX=0; this.velY=0; this.speed=0; this.boost=this.maxBoost;
        this.isStunned=false; this.stunDuration=0; this.effects={};
        this.stuckInCornerTimer = 0;
    }
}

class Ball {
    constructor(x, y, radius, pointType=1) {
        this.x=x;this.y=y;this.radius=radius;this.color=COLOR_CYAN;
        this.velX=0;this.velY=0;this.maxSpeed=35; this.pointType=pointType; this.effects = {};
        this.stuckTimer = 0; this.ballStuckCountdown = 0;
    }
   
    move(deltaTime) {
        // Passive Ball Magnet
        if (playerUpgrades.ballMagnet) {
             let p = cars[0];
             if (p && !p.ai) {
                 let d = Math.hypot(p.x-this.x, p.y-this.y);
                 if (d < 200) {
                     this.velX += (p.x - this.x) * 0.002;
                     this.velY += (p.y - this.y) * 0.002;
                 }
             }
        }
        if (playerUpgrades.gravityWell) {
             let targetX = canvas.width; let targetY = canvas.height/2;
             this.velX += (targetX - this.x) * 0.001;
             this.velY += (targetY - this.y) * 0.001;
        }

        this.velX *= 0.98; this.velY *= 0.98;
        let speed = Math.hypot(this.velX, this.velY);
        if(speed > this.maxSpeed){ let sc = this.maxSpeed / speed; this.velX *= sc; this.velY *= sc; }
       
        this.x += this.velX * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * deltaTime * PHYSICS_TICK_RATE;
       
        let bMargin = this.radius;
        if (this.x < bMargin) { this.x = bMargin; this.velX *= -0.8; }
        else if (this.x > canvas.width - bMargin) { this.x = canvas.width - bMargin; this.velX *= -0.8; }
        if (this.y < bMargin) { this.y = bMargin; this.velY *= -0.8; }
        else if (this.y > canvas.height - bMargin) { this.y = canvas.height - bMargin; this.velY *= -0.8; }
       
        // Sticky Net Logic
        if(playerUpgrades.platinumStickyNet) {
            let aiGoalTop=canvas.height/2-GOAL_HEIGHT/2, aiGoalBottom=canvas.height/2+GOAL_HEIGHT/2;
            if(this.y>aiGoalTop && this.y<aiGoalBottom && this.x > canvas.width - (BALL_RADIUS*3)) {
                this.velX *= 0.5; // Stronger stick
            }
        }
       
        // Stuck Logic
        const cornerCheckSize = 150; 
        const ballInCorner = (this.y < cornerCheckSize || this.y > canvas.height - cornerCheckSize) && (this.x < cornerCheckSize || this.x > canvas.width - cornerCheckSize);
        if (speed < 0.8 && ballInCorner) { 
            this.stuckTimer += deltaTime;
            if (this.stuckTimer > 2.0) {
                this.ballStuckCountdown = Math.ceil(5.0 - (this.stuckTimer - 2.0));
                if (this.ballStuckCountdown < 1) { 
                    this.reset(); stuckBallMessage = { text: 'Ball stuck! Resetting...', duration: 2.0 };
                }
            }
        } else {
            this.stuckTimer = 0; this.ballStuckCountdown = 0;
        }
    }
   
    draw() {
        ctx.fillStyle=this.pointType===1?this.color:(this.pointType===2?'#ffe066':'#ff92c6');
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,0.5)';
        ctx.beginPath(); ctx.arc(this.x-5,this.y-5,this.radius/2,0,Math.PI*2); ctx.fill();
        if(this.pointType>1){
            ctx.save(); ctx.font='bold 13px Inter'; ctx.globalAlpha=0.90;
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillStyle=(this.pointType===2?'#fcad03':'#ed1b90'); ctx.strokeStyle='#fff';
            ctx.fillText((this.pointType===2?'2x':'3x'),this.x,this.y-this.radius+10);
            ctx.restore();
        }
    }
    reset() {
        let maxOffset=canvas.height*MAX_CENTER_OFFSET_FACTOR, randomYOffset=Math.random()*2*maxOffset-maxOffset;
        this.x=canvas.width/2; this.y=canvas.height/2+randomYOffset; this.velX=0;this.velY=0;
        this.stuckTimer = 0; this.ballStuckCountdown = 0;
        let r=Math.random();
        if(playerUpgrades.platinumDoubleAll) {
            if(r<0.10) this.pointType=3; else if(r<0.30) this.pointType=2; else this.pointType=1;
        } else if(r<0.03) this.pointType=3; else if(r<0.13) this.pointType=2; else this.pointType=1;
    }
}

class BoostPad {
    constructor(x,y,radius=12){ this.x=x;this.y=y;this.radius=radius; this.active = true; this.cooldownTimer = 0; }
    update(deltaTime) { if (!this.active) { this.cooldownTimer -= deltaTime; if (this.cooldownTimer <= 0) this.active = true; } }
    draw() {
        ctx.save();
        if (!this.active) ctx.globalAlpha = 0.3; 
        ctx.strokeStyle="#fbbf24"; ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle="#f59e42"; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius-7,0,Math.PI*2); ctx.fill();
        ctx.restore();
    }
    checkCollision(car){
        if (!this.active) return false; 
        return Math.hypot(this.x-car.x,this.y-car.y) < this.radius+(CAR_WIDTH*car.sizeMultiplier/2);
    }
    consume(car) {
        if (!this.active) return;
        this.active = false; this.cooldownTimer = 3.0;
        let refill = 25 + (playerUpgrades.boostRegen || 0);
        car.refillBoost(refill);
    }
}

class GoaliePad {
    constructor() { this.width = 14; this.height = GOAL_HEIGHT * 0.20; this.x = 7; this.y = canvas.height / 2; this.speed = 400; }
    update(deltaTime) {
        let targetBall = foreverBalls[0];
        // Find threatening ball
        if (foreverBalls.length > 1) {
             let minX = Infinity;
             foreverBalls.forEach(b => { if(b.x < minX) { minX = b.x; targetBall = b; } });
        }
        let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
        let playerGoalTop = canvas.height/2 - goalHeight/2;
        let playerGoalBottom = canvas.height/2 + goalHeight/2;
        let targetCenter = Math.max(playerGoalTop + this.height/2, Math.min(targetBall.y, playerGoalBottom - this.height/2));
        let moveDist = this.speed * deltaTime;
        if (this.y < targetCenter) this.y = Math.min(this.y + moveDist, targetCenter);
        else if (this.y > targetCenter) this.y = Math.max(this.y - moveDist, targetCenter);
    }
    draw() {
        ctx.fillStyle = '#00cccc'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height, 4);
        ctx.fill(); ctx.stroke();
    }
    checkCollision(ball) {
        let top = this.y - this.height/2; let bottom = this.y + this.height/2;
        let right = this.x + this.width/2;
        if (ball.x - ball.radius < right && ball.x + ball.radius > 0 && ball.y > top && ball.y < bottom) {
            if (ball.velX < 0) { ball.velX *= -1.5; ball.x = right + ball.radius + 2; }
        }
    }
}

// ====== Game Logic ======
function getInitialAngle(x1,y1,x2,y2){
    let angleRad=Math.atan2(y1-y2,x2-x1);
    return (angleRad*180/Math.PI+360)%360;
}
function getNumberOfAICars(){return cars.filter(c=>c.ai&&!c.isFriendlyAI).length;}

function addFriendlyAICar(playerId, role, difficultyMultiplier) {
    const P1_X=100+CAR_WIDTH/2, center_y=canvas.height/2;
    let newAI = new Car(P1_X + 20, center_y + (Math.random() * 100 - 50),
                        '#00cccc', {}, 'left', playerId,
                        getInitialAngle(P1_X, center_y, canvas.width/2, center_y),
                        true, aiDifficulty * difficultyMultiplier, role);
    newAI.sizeMultiplier = 0.75;
    cars.push(newAI);
}

function addEnemyAICar() {
    let center_x=canvas.width/2, center_y=canvas.height/2;
    let P2_X=canvas.width-100-CAR_WIDTH/2;
    let P1_Y_OFFSET=CAR_HEIGHT*2;
    let aiY=center_y+((Math.random() > 0.5)?P1_Y_OFFSET*(Math.random()*2):-P1_Y_OFFSET*Math.random()*2);
    
    // Level 100+ scaling difficulty
    let effectiveDiff = aiDifficulty;
    if (playerLevel > 100) effectiveDiff += Math.floor((playerLevel-100)/10);

    let newAI = new Car(P2_X,aiY,COLOR_RED,{},'right',2+getNumberOfAICars(),getInitialAngle(P2_X,aiY,center_x,center_y),true,effectiveDiff);
    cars.push(newAI);
    assignAIRoles(cars.filter(c => c.ai && !c.isFriendlyAI));
}

function assignAIRoles(aiCars){
    const roleOrder = ["attacker", "defender", "mid", "attacker", "mid", "defender"];
    aiCars.sort((a, b) => a.playerId - b.playerId).forEach((ai, index) => {
        ai.role = roleOrder[index % roleOrder.length] || "attacker";
    });
}

function setupGameObjects(mode,initialAICount=1){
    canvas.width = DEFAULT_WIDTH; canvas.height = DEFAULT_HEIGHT;
    let center_x=canvas.width/2, center_y=canvas.height/2;
    foreverBalls = [];
    let count = playerUpgrades.platinumDoubleAll ? 3 : 1;
    for(let i=0;i<count;i++) {
        let b=new Ball(center_x, center_y, BALL_RADIUS); b.reset(); foreverBalls.push(b);
    }
    ball = foreverBalls[0];
   
    cars=[];
    let P1_X=100+CAR_WIDTH/2, P2_X=canvas.width-100-CAR_WIDTH/2;
    cars.push(new Car(P1_X,center_y,COLOR_BLUE,{'up':'KeyW','down':'KeyS','left':'KeyA','right':'KeyD','boost':'ShiftLeft'},'left',1,0));

    if(mode==="1v1 Multiplayer") {
        cars.push(new Car(P2_X,center_y,COLOR_RED,{'up':'ArrowUp','down':'ArrowDown','left':'ArrowLeft','right':'ArrowRight','boost':'ShiftRight'},'right',2,180));
    } else if(mode==="2v2 Multiplayer") {
        cars.push(new Car(P1_X,center_y+50, COLOR_BLUE, { 'up': 'KeyT', 'down': 'KeyG', 'left': 'KeyF', 'right': 'KeyH', 'boost': 'Space' }, 'left', 2, 0));
        cars.push(new Car(P2_X,center_y-50, COLOR_RED, { 'up': 'ArrowUp', 'down': 'ArrowDown', 'left': 'ArrowLeft', 'right': 'ArrowRight', 'boost': 'ControlRight' }, 'right', 3, 180));
        cars.push(new Car(P2_X,center_y+50, COLOR_RED, { 'up': 'KeyI', 'down': 'KeyK', 'left': 'KeyJ', 'right': 'KeyL', 'boost': 'ShiftRight' }, 'right', 4, 180));
    } else if(mode==="Vs Computer"){
        for(let i=0; i<initialAICount;i++){
            let aiY=center_y+((i%2===0)?50*(i/2):-50*Math.ceil(i/2));
            cars.push(new Car(P2_X,aiY,COLOR_RED,{},'right',2+i,180,true,aiDifficulty));
        }
        assignAIRoles(cars.filter(c=>c.ai&&!c.isFriendlyAI));
    }
    cars[0].applyPlayerUpgrades(playerUpgrades);
    goaliePad = playerUpgrades.autoGoalie ? new GoaliePad() : null;
   
    boostPads=[
        new BoostPad(canvas.width*0.5,canvas.height*0.25), new BoostPad(canvas.width*0.5,canvas.height*0.75),
        new BoostPad(canvas.width*0.25,canvas.height*0.5), new BoostPad(canvas.width*0.75,canvas.height*0.5),
        new BoostPad(canvas.width*0.5,canvas.height*0.5),
        new BoostPad(canvas.width*0.1,canvas.height*0.12), new BoostPad(canvas.width*0.9,canvas.height*0.12),
        new BoostPad(canvas.width*0.1,canvas.height*0.88), new BoostPad(canvas.width*0.9,canvas.height*0.88),
    ];
    if(playerUpgrades.extraBoostPad) {
        boostPads.push(new BoostPad(canvas.width*0.35, canvas.height*0.35));
        boostPads.push(new BoostPad(canvas.width*0.65, canvas.height*0.65));
    }
    if(playerUpgrades.freePad) boostPads.push(new BoostPad(canvas.width/2, canvas.height/2, 20));
}

// --- UI ---
const overlay = document.getElementById('overlay');
const uiPanel = document.getElementById('ui-panel');
const foreverStatusPanel = document.getElementById('forever-status-panel');
const pauseBtn = document.getElementById('pause-btn');

function updateUI(){
    const sLeft = document.getElementById('score-left');
    const sRight = document.getElementById('score-right');
    sLeft.textContent=`BLUE: ${scoreLeft}`;
    sRight.textContent=`RED: ${scoreRight}`;

    if (endConditionType === 'points') {
        document.getElementById('center-info').style.visibility = 'hidden';
        // Adjust font sizes based on who is winning
        if (scoreLeft > scoreRight) {
            sLeft.classList.add('score-large'); sLeft.classList.remove('score-normal');
            sRight.classList.add('score-normal'); sRight.classList.remove('score-large');
        } else if (scoreRight > scoreLeft) {
            sRight.classList.add('score-large'); sRight.classList.remove('score-normal');
            sLeft.classList.add('score-normal'); sLeft.classList.remove('score-large');
        } else {
            sLeft.classList.add('score-normal'); sLeft.classList.remove('score-large');
            sRight.classList.add('score-normal'); sRight.classList.remove('score-large');
        }
        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.add('hidden');
    } 
    else if (endConditionType === 'timed') {
        document.getElementById('center-info').style.visibility = 'visible';
        let min=Math.floor(gameTimer/60), sec=Math.floor(gameTimer%60);
        const timerEl = document.getElementById('timer');
        timerEl.textContent=`${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
        document.getElementById('mode-info').textContent=`TIME`;
        
        // Timed Mode Visuals
        if (gameTimer <= 30) timerEl.classList.add('blink-active');
        else timerEl.classList.remove('blink-active');

        if (gameTimer <= 10) timerEl.classList.add('text-red-500');
        else timerEl.classList.remove('text-red-500');

        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.add('hidden');
    } 
    else if (endConditionType === 'forever'){
        document.getElementById('center-info').style.visibility = 'visible';
        document.getElementById('timer').textContent=`${playerLevel}`;
        document.getElementById('mode-info').textContent=`PLAYER LEVEL`;
        document.getElementById('player-level-display').textContent = playerLevel;
        let numAI = getNumberOfAICars();
        document.getElementById('ai-status').innerText = `LV ${aiDifficulty} (${numAI} Bot${numAI>1?'s':''})`;
        
        if (playerLevel > 100) document.getElementById('ai-buff-text').classList.remove('hidden');
        
        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.remove('hidden');
    }
}

function updateUpgradesDisplay() {
    const display = document.getElementById('player-upgrades-display');
    display.innerHTML = '';
    playerAbilities.forEach(ability => {
        const count = playerUpgrades[ability.id] || 0;
        const countDisplay = count > 1 ? ` (x${count})` : '';
        const item = document.createElement('div');
        item.className = `px-2 py-1 rounded text-xs font-bold flex items-center shadow-sm ability-level-${ability.tier} upgrade-icon-container`;
        item.innerHTML = `
            <span class="mr-1">${ability.icon}</span> ${ability.label}${countDisplay}
            <div class="upgrade-tooltip"><h4 class="font-bold">${ability.label}</h4><p class="text-xs">${ability.desc}</p></div>
        `;
        display.appendChild(item);
    });
}

function drawField(){
    ctx.fillStyle=COLOR_FIELD; ctx.fillRect(0,0,canvas.width,canvas.height);
    let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
    let aiGoalHeight = playerUpgrades.goalExpansion ? GOAL_HEIGHT * 1.3 : GOAL_HEIGHT;
    let playerGoalTop=canvas.height/2 - goalHeight/2, playerGoalBottom=canvas.height/2 + goalHeight/2;
    let aiGoalTop=canvas.height/2 - aiGoalHeight/2, aiGoalBottom=canvas.height/2 + aiGoalHeight/2;

    ctx.fillStyle = 'rgba(0, 102, 204, 0.2)'; ctx.fillRect(0, playerGoalTop, 15, goalHeight);
    ctx.fillStyle = 'rgba(204, 0, 0, 0.2)'; ctx.fillRect(canvas.width - 15, aiGoalTop, 15, aiGoalHeight);

    ctx.strokeStyle="#dcdcdc"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(canvas.width/2,0); ctx.lineTo(canvas.width/2,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(canvas.width/2,canvas.height/2,80,0,Math.PI*2); ctx.stroke();
   
    ctx.strokeStyle=COLOR_BLUE; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(0,playerGoalTop); ctx.lineTo(0,playerGoalBottom); ctx.stroke();
    ctx.strokeStyle=COLOR_RED; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(canvas.width,aiGoalTop); ctx.lineTo(canvas.width,aiGoalBottom); ctx.stroke();
   
    boostPads.forEach(pad=>pad.draw());
    if (goaliePad) goaliePad.draw();
}

function checkCarBallCollision(car, ball){
    let dx=ball.x-car.x, dy=ball.y-car.y;
    let collisionRadius=BALL_RADIUS+(CAR_WIDTH * car.sizeMultiplier * 0.5);
    let dist=Math.hypot(dx,dy);
    if(dist<collisionRadius){
        let impulseAngle=Math.atan2(dy,dx), carSpeed=car.speed, baseForce=1.0;
        let force=baseForce+carSpeed*1.5*(car.boosting?car.boostPower:1);
        
        if (!car.ai) {
            force *= (1 + (playerUpgrades.kick || 0)*0.1);
            if (playerUpgrades.doubleKick) force *= 2;
        }
        
        // Physics: Heavy cars push ball harder, light cars pushed back more
        force *= car.mass;
        
        ball.velX+=Math.cos(impulseAngle)*force; ball.velY+=Math.sin(impulseAngle)*force;
        
        // Car Recoil
        let recoil = 1.0 / car.mass;
        if (!car.ai && playerUpgrades.stickTires) recoil *= 0.5;
        car.velX -= Math.cos(impulseAngle) * force * 0.5 * recoil;
        car.velY -= Math.sin(impulseAngle) * force * 0.5 * recoil;

        let overlap=collisionRadius-dist;
        if(overlap>0){ ball.x+=Math.cos(impulseAngle)*overlap; ball.y+=Math.sin(impulseAngle)*overlap; }
       
        if (!car.ai) {
             if (playerUpgrades.superStun) {
                 cars.filter(c=>c.ai&&!c.isFriendlyAI).forEach(c => {
                     if(Math.hypot(c.x-ball.x, c.y-ball.y) < 150) { c.isStunned=true; c.stunDuration=1.5; }
                 });
             }
             if (playerUpgrades.freezeTag) {
                  cars.filter(c=>c.ai&&!c.isFriendlyAI).forEach(c => {
                     if(Math.hypot(c.x-car.x, c.y-car.y) < 100) { c.effects.slow = {duration:2.0, factor:0.5}; }
                 });
             }
        }
    }
}

function checkCarCarCollision(car1, car2) {
    if ((!car1.ai && car1.effects.ghost && car2.ai) || (!car2.ai && car2.effects.ghost && car1.ai)) return;
    let radius1 = (CAR_WIDTH * car1.sizeMultiplier / 2) * 0.9;
    let radius2 = (CAR_WIDTH * car2.sizeMultiplier / 2) * 0.9;
    let collisionDistance = radius1 + radius2;
    let dx = car2.x - car1.x, dy = car2.y - car1.y;
    let dist = Math.hypot(dx, dy);
   
    if (dist < collisionDistance) {
        let angle = Math.atan2(dy, dx);
        let overlap = collisionDistance - dist;
        let sepX = Math.cos(angle)*(overlap/2), sepY = Math.sin(angle)*(overlap/2);
        car1.x-=sepX; car1.y-=sepY; car2.x+=sepX; car2.y+=sepY;
       
        let v1 = car1.velX*Math.cos(angle) + car1.velY*Math.sin(angle);
        let v2 = car2.velX*Math.cos(angle) + car2.velY*Math.sin(angle);
        
        // Physics collision with mass
        let m1 = car1.mass, m2 = car2.mass;
        let v1Final = (v1 * (m1 - m2) + 2 * m2 * v2) / (m1 + m2);
        let v2Final = (v2 * (m2 - m1) + 2 * m1 * v1) / (m1 + m2);
        
        car1.velX += (v1Final - v1) * Math.cos(angle); car1.velY += (v1Final - v1) * Math.sin(angle);
        car2.velX += (v2Final - v2) * Math.cos(angle); car2.velY += (v2Final - v2) * Math.sin(angle);
        
        if (!car1.ai && playerUpgrades.boostSteal && car2.ai && car2.boost > 10) {
            car2.boost -= 10; car1.refillBoost(10);
        }
    }
}

function checkGoal(ball) {
    let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
    let aiGoalHeight = playerUpgrades.goalExpansion ? GOAL_HEIGHT * 1.3 : GOAL_HEIGHT;
    if(ball.y>canvas.height/2-goalHeight/2 && ball.y<canvas.height/2+goalHeight/2 && ball.x-ball.radius<=0) return 'right'; 
    if(ball.y>canvas.height/2-aiGoalHeight/2 && ball.y<canvas.height/2+aiGoalHeight/2 && ball.x+ball.radius>=canvas.width) {
         if(cars[0].effects.goalBlock) return null;
         return 'left'; 
    }
    return null;
}

function handleGoal(scoringTeam, scoredBall) {
    if (scoringTeam === 'left') { 
        let oldLevel = playerLevel;
        scoreLeft += scoredBall.pointType;
        playerLevel += scoredBall.pointType;
       
        if (endConditionType === 'forever') {
            if (Math.floor(playerLevel / 5) > Math.floor(oldLevel / 5)) pendingUpgradePick = true;
            
            // Changed from 10 to 15 as requested
            if (Math.floor(playerLevel / 15) > Math.floor(oldLevel / 15)) {
                if (getNumberOfAICars() < 6) addEnemyAICar();
                else { 
                    aiDifficulty++; 
                    showNotification("AI EVOLVED: DIFFICULTY UP");
                }
            }
            if (playerLevel > 100 && Math.floor(playerLevel / 10) > Math.floor(oldLevel / 10)) {
                showNotification("WARNING: AI SYSTEM OVERCLOCK");
                cars.forEach(c => { if(c.ai && !c.isFriendlyAI) c.updateDifficulty(aiDifficulty); });
            }
        }
       
        // Effects
        cars[0].effects.goalBlock = { duration: 3.0 };
        cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => {
            if (playerUpgrades.aiSlow) ai.effects.slow = { duration: 5.0, factor: 0.5 };
            if (playerUpgrades.timeFreeze) { ai.isStunned = true; ai.stunDuration = 2.0; }
            if (playerUpgrades.platinumSuperAI) ai.effects.confused = { duration: 8.0 };
        });
       
        if(playerUpgrades.ballSplit && foreverBalls.length < 5) {
             let b = new Ball(scoredBall.x, scoredBall.y, BALL_RADIUS, 1);
             b.velX = Math.random() > 0.5 ? 10 : -10; b.velY = Math.random() > 0.5 ? 10 : -10;
             foreverBalls.push(b);
        }
    }
    else if (scoringTeam === 'right') { 
        scoreRight += scoredBall.pointType;
        if (playerUpgrades.freePad) boostPads.push(new BoostPad(canvas.width/2, canvas.height/2, 20));
        if (endConditionType === 'forever' && scoreRight >= scoreLeft + 5) {
             gameState = 'finished'; drawGameOver('ai_won'); return;
        }
    }
   
    if(foreverBalls.length === 1 || scoredBall.pointType > 1) cars.forEach(c => c.reset());
    if(foreverBalls.length > 1) foreverBalls = foreverBalls.filter(b => b !== scoredBall);
    else scoredBall.reset();
   
    if (gameState === 'playing') {
        if (endConditionType === 'points' && (scoreLeft >= targetScore || scoreRight >= targetScore) ||
            endConditionType === 'timed' && gameTimer <= 0) {
            gameState = 'finished'; drawGameOver();
        } else if (pendingUpgradePick) {
            requestUpgradePicker(); pendingUpgradePick = false;
        }
    }
}

function update(deltaTime) {
    if (playerUpgrades.boostRain && Math.random() < 0.001) { cars[0].refillBoost(30); showNotification("Boost Leak!"); }
    if (endConditionType === 'timed') gameTimer=Math.max(0,gameTimer-deltaTime);
   
    cars.forEach(car => { car.handleInput(deltaTime); car.move(deltaTime); });
    foreverBalls.forEach(ball => ball.move(deltaTime));
    boostPads.forEach(pad => pad.update(deltaTime));
    if (goaliePad) goaliePad.update(deltaTime);

    cars.forEach(car => foreverBalls.forEach(ball => checkCarBallCollision(car, ball)));
    for(let i=0; i<cars.length; i++) for(let j=i+1; j<cars.length; j++) checkCarCarCollision(cars[i], cars[j]);
   
    cars.forEach(car => { boostPads.forEach(pad => { if (pad.checkCollision(car)) pad.consume(car); }); });
   
    let scored = [];
    foreverBalls.forEach(ball => {
        if (goaliePad) goaliePad.checkCollision(ball);
        let team = checkGoal(ball);
        if (team) scored.push({ball, team});
    });
    if (scored.length > 0) handleGoal(scored[0].team, scored[0].ball);
   
    updateUI();
}

function gameLoop(currentTime) {
    if (!['playing', 'paused', 'finished', 'upgrading'].includes(gameState)) { cancelAnimationFrame(animationFrameId); return; }
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
   
    if (gameState === 'playing') {
        update(deltaTime);
        drawField(); cars.forEach(car => car.draw()); foreverBalls.forEach(ball => ball.draw());
    } else {
        drawField(); cars.forEach(car => car.draw()); foreverBalls.forEach(ball => ball.draw());
    }
    
    if (stuckBallMessage.duration > 0) {
        ctx.save(); ctx.fillStyle = 'white'; ctx.font = 'bold 24px Inter'; ctx.textAlign = 'center';
        ctx.fillText(stuckBallMessage.text, canvas.width/2, 50); ctx.restore();
        if(gameState==='playing') stuckBallMessage.duration -= deltaTime;
    }
    if (gameState === 'playing' || gameState === 'paused' || gameState === 'finished') animationFrameId = requestAnimationFrame(gameLoop);
}

// --- MENUS ---
function drawMainMenu() {
    gameState = 'menu';
    overlay.classList.add('visible'); 
    document.getElementById('pause-btn').classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-8 text-yellow-400">2D ROCKET LEAGUE<br><span class="text-sm text-white">ULTIMATE EDITION</span></h1>
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="select-mode-1v1">1v1 Multiplayer</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="select-mode-2v2">2v2 Multiplayer</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="select-mode-vs-computer">Vs Computer</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="play-online">Play Online</div>
            </div>
        </div>
    `;
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}

function drawGameSettingsMenu(mode) {
    let foreverModeOption = mode === 'Vs Computer' ? `
        <h2 class="text-2xl font-bold mb-3 text-white mt-6">Challenge Mode</h2>
        <div class="flex justify-center gap-4 mb-6"><div class="p-3 bg-cyan-600 rounded-lg hover:bg-cyan-500" data-action="start-forever">Start FOREVER MODE</div></div>
    ` : '';
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-lg pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">${mode}</h1>
            <div id="menu-options">
                <h2 class="text-2xl font-bold mb-3 text-white">Time Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-timed-1">1 Min</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-timed-2">2 Min</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-timed-5">5 Min</div>
                </div>
                <h2 class="text-2xl font-bold mb-3 text-white">Score Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-points-3">3 Pts</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-points-5">5 Pts</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-points-10">10 Pts</div>
                </div>
                ${foreverModeOption}
                <hr class="border-gray-500 my-6">
                <div><div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="main-menu">Back</div></div>
            </div>
        </div>
    `;
    window.currentGameModeSelection = mode;
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
    menuOptions.forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}

function drawUpgradeMenu() {
    overlay.classList.add('visible'); 
    drawField(); cars.forEach(car => car.draw()); foreverBalls.forEach(ball => ball.draw());
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-5xl pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-2 text-green-400">LEVEL UP! (Lvl ${playerLevel})</h1>
            <div id="upgrade-options" class="flex flex-wrap justify-center gap-6 mt-4">
                ${upgradeOptions.map((opt, index) => `
                    <div id="upgrade-${index}" data-index="${index}" class="upgrade-option-card p-4 rounded-xl w-64 text-left shadow-lg border-2 border-transparent bg-gray-600 hover:bg-gray-500 ability-level-${opt.tier}">
                        <p class="text-xl font-bold mb-1 flex items-center justify-between">
                            <span class="text-2xl mr-2">${opt.icon}</span>
                            <span class="font-mono text-xs px-2 py-1 rounded bg-black bg-opacity-20">${opt.tier.toUpperCase()}</span>
                        </p>
                        <h2 class="text-xl font-bold mb-2 text-white">${opt.label}</h2>
                        <p class="text-sm text-white opacity-90">${opt.desc}</p>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    menuOptions = document.getElementById('upgrade-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleUpgradeSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('upgrade-options', index, 'upgrade'));
    });
    selectedUpgradeIndex = 0; updateMenuSelectionUI('upgrade-options', selectedUpgradeIndex, 'upgrade');
}

function drawGameOver(reason = null) {
    pauseBtn.classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
    overlay.classList.add('visible'); 
    let message = reason === 'ai_won' ? 'YOU LOSE!' : (scoreLeft > scoreRight ? 'BLUE TEAM WINS!' : (scoreRight > scoreLeft ? 'RED TEAM WINS!' : 'DRAW!'));
    let color = reason === 'ai_won' ? 'text-red-400' : 'text-yellow-300';
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-4 text-pink-400">GAME OVER</h1>
            <p class="text-3xl font-bold mb-6 ${color}">${message}</p>
            <p class="text-xl text-gray-300 mb-6">Level: ${playerLevel} | Score: ${scoreLeft}-${scoreRight}</p>
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="restart">Play Again</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="main-menu">Main Menu</div>
            </div>
        </div>
    `;
    menuOptions = document.getElementById('menu-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI('menu-options', selectedMenuIndex);
}

function updateMenuSelectionUI(containerId, selectedIndex, type = 'menu') {
    if (type === 'menu') selectedMenuIndex = selectedIndex; else selectedUpgradeIndex = selectedIndex;
    let optionsToUpdate = (type === 'upgrade' && containerId) ? document.getElementById(containerId).children : menuOptions;
    Array.from(optionsToUpdate).forEach((child, index) => {
        child.classList.remove('menu-selected');
        if (index === selectedIndex) child.classList.add('menu-selected');
    });
}

function handleMenuSelection(index) {
    if (!menuOptions[index]) return;
    const selection = menuOptions[index].getAttribute('data-action');
    const mode = window.currentGameModeSelection;
    
    if (selection.includes('select-mode')) drawGameSettingsMenu(selection.replace('select-mode-', '').replace('vs-computer', 'Vs Computer').replace('1v1', '1v1 Multiplayer').replace('2v2', '2v2 Multiplayer'));
    else if (selection === 'start-forever') startGame('Vs Computer', 'forever');
    else if (selection.includes('start-timed')) { timeLimitSeconds = parseInt(selection.split('-')[2])*60; startGame(mode, 'timed'); }
    else if (selection.includes('start-points')) { targetScore = parseInt(selection.split('-')[2]); startGame(mode, 'points'); }
    else if (selection === 'play-online') window.location.href = "https://ccpspy.github.io/onlinecargame";
    else if (selection === 'restart') startGame(gameMode, endConditionType);
    else if (selection === 'main-menu') drawMainMenu();
    else if (selection === 'resume') togglePause();
}

function handleUpgradeSelection(index) {
    if (!upgradeOptions[index]) return;
    const upgrade = upgradeOptions[index];
    if (upgrade.id === 'reroll' || upgrade.id === 'rerollPlus') {
        if (upgrade.id === 'reroll') upgradeRerollsUsed++;
        rerollUpgradeOptions();
    } else { applyUpgrade(upgrade); exitUpgradePicker(); }
}

function startGame(mode, endType='timed') {
    gameMode = mode; endConditionType = endType; scoreLeft = 0; scoreRight = 0; aiDifficulty = 1;
    if(endType === 'forever') {
        timeLimitSeconds = 99999; targetScore = 999; playerLevel = 0; playerUpgrades = {}; playerAbilities = []; pendingUpgradePick = false;
    } else {
        playerUpgrades = {}; playerAbilities = [];
    }
    gameTimer = timeLimitSeconds;
    setupGameObjects(mode, (mode === 'Vs Computer' ? 1 : 0));
    updateUI(); updateUpgradesDisplay();
    
    if (endType === 'forever') { gameState = 'upgrading'; overlay.classList.remove('visible'); requestUpgradePicker(); }
    else {
        gameState = 'playing'; overlay.classList.remove('visible'); pauseBtn.classList.remove('hidden');
        document.getElementById('fullscreen-btn').classList.remove('hidden');
        lastTime = performance.now();
        if (animationFrameId) cancelAnimationFrame(animationFrameId); 
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

function togglePause() {
    if (gameState === 'playing') {
        gameState = 'paused'; pauseBtn.innerHTML = '<span class="mr-2">‚ñ∂Ô∏è</span> Resume (P)'; overlay.classList.add('visible');
        overlay.innerHTML = `
            <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
                <h1 class="text-5xl font-extrabold mb-8 text-red-400">PAUSED</h1>
                <div id="menu-options" class="space-y-4 text-xl">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="resume">Resume</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="restart">Restart</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="main-menu">Main Menu</div>
                </div>
            </div>
        `;
        menuOptions = document.getElementById('menu-options').children;
        Array.from(menuOptions).forEach((option, index) => {
            option.addEventListener('click', () => handleMenuSelection(index));
            option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
        });
        selectedMenuIndex = 0; updateMenuSelectionUI('menu-options', selectedMenuIndex);
    } else if (gameState === 'paused') {
        gameState = 'playing'; overlay.classList.remove('visible'); pauseBtn.innerHTML = '<span class="mr-2">‚è∏Ô∏è</span> Pause (P)';
        lastTime = performance.now(); animationFrameId = requestAnimationFrame(gameLoop);
    }
}

function toggleFullScreen() {
    const gc = document.getElementById('game-container');
    if (!document.fullscreenElement) gc.requestFullscreen(); else document.exitFullscreen();
}
document.addEventListener('fullscreenchange', () => {
    const gc = document.getElementById('game-container');
    const isFs = !!document.fullscreenElement;
    if (isFs) { gc.classList.add('fullscreen-active'); document.body.classList.add('fullscreen-active'); fullscreenBtn.innerHTML = 'Exit'; }
    else { gc.classList.remove('fullscreen-active'); document.body.classList.remove('fullscreen-active'); fullscreenBtn.innerHTML = 'üì∫ Fullscreen'; }
});
fullscreenBtn.addEventListener('click', toggleFullScreen);

window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (gameState === 'menu' || gameState === 'paused' || gameState === 'finished') {
        if (e.code === 'ArrowDown') selectedMenuIndex = (selectedMenuIndex + 1) % menuOptions.length;
        else if (e.code === 'ArrowUp') selectedMenuIndex = (selectedMenuIndex - 1 + menuOptions.length) % menuOptions.length;
        else if (e.code === 'Enter') if (menuOptions[selectedMenuIndex]) menuOptions[selectedMenuIndex].click();
        updateMenuSelectionUI(null, selectedMenuIndex); e.preventDefault();
    } else if (gameState === 'upgrading') {
        if (e.code === 'ArrowRight') selectedUpgradeIndex = (selectedUpgradeIndex + 1) % menuOptions.length;
        else if (e.code === 'ArrowLeft') selectedUpgradeIndex = (selectedUpgradeIndex - 1 + menuOptions.length) % menuOptions.length;
        else if (e.code === 'Enter') if (menuOptions[selectedUpgradeIndex]) menuOptions[selectedUpgradeIndex].click();
        updateMenuSelectionUI('upgrade-options', selectedUpgradeIndex, 'upgrade'); e.preventDefault();
    } else if (gameState === 'playing' && e.code === 'KeyP') togglePause();
});
window.addEventListener('keyup', (e) => keys[e.code] = false);

window.onload = function () { canvas.width = DEFAULT_WIDTH; canvas.height = DEFAULT_HEIGHT; drawMainMenu(); }
</script>
</body>
</html>
