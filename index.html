<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Rocket League - Enhanced Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            overflow-y: auto; /* Allow scroll if window is tiny */
        }
        
        /* Hide scrollbar when in fullscreen to look cleaner */
        body.fullscreen-active {
            padding: 0;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            max-width: 1000px; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 1rem;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1f2937; /* bg-gray-800 */
            transition: all 0.3s ease;
        }

        /* --- FULLSCREEN SPECIFIC CSS --- */
        #game-container.fullscreen-active {
            width: 100vw;
            height: 100vh;
            max-width: none; /* Remove width limit */
            border-radius: 0;
            padding: 1rem;
            box-sizing: border-box;
            justify-content: space-between; /* Distribute space */
        }

        #game-viewport {
            position: relative;
            width: 100%;
            /* Default non-fullscreen behavior */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* In fullscreen, viewport takes all available space minus the bars */
        #game-container.fullscreen-active #game-viewport {
            flex-grow: 1;
            height: 0; /* Flexbox hack to allow content to shrink */
            min-height: 0;
            margin: 10px 0;
        }

        /* New Wrapper to maintain Aspect Ratio (1000/600 = 1.666) */
        #canvas-wrapper {
            position: relative;
            width: 1000px;
            height: 600px;
        }

        /* In fullscreen, the wrapper scales but keeps ratio */
        #game-container.fullscreen-active #canvas-wrapper {
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1000 / 600;
        }

        canvas {
            background-color: #2b2f3d;
            display: block;
            border-radius: 0.75rem;
            /* Canvas fills the wrapper */
            width: 100%;
            height: 100%;
        }

        /* Ensure Overlay matches the canvas size exactly */
        #overlay {
            position: absolute;
            inset: 0;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(17, 24, 39, 0.9);
            opacity: 0;
            pointer-events: none; /* Let clicks pass through when hidden */
            transition: opacity 0.3s;
            z-index: 50;
        }
        
        /* Toggle class to show overlay */
        #overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Ensure bottom panels don't get squashed in flex layout */
        #ui-panel, #forever-status-panel {
            flex-shrink: 0;
            width: 100%;
            max-width: 1000px; /* Keep UI from getting too wide in fullscreen */
        }

        /* --- EXISTING STYLES --- */
        .boost-bar { transition: width 0.1s ease-out; }
        .menu-selected {
            border: 3px solid #fcd34d;
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.6);
            padding: 0.5rem 1rem;
            border-radius: 10px;
            color: #fcd34d;
            transform: translateY(-2px);
        }
        #menu-options > div, #upgrade-options > div, #menu-options > a {
             cursor: pointer;
             transition: transform 0.2s, box-shadow 0.2s;
        }
        .upgrade-icon-container { position: relative; cursor: default; }
        .upgrade-tooltip {
            visibility: hidden;
            background-color: #1f2937;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 60;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            width: 220px;
            white-space: normal;
        }
        .upgrade-icon-container:hover .upgrade-tooltip { visibility: visible; opacity: 1; }
        .ability-level-bronze { background: #cd7f32; color: #ffffff; }
        .ability-level-silver { background: #c0c0c0; color: #393939; }
        .ability-level-gold { background: linear-gradient(90deg,#ffd700,#fae360); color: #625002; }
        .ability-level-platinum { background: linear-gradient(90deg,#e5e4e2,#b9f2ff); color: #234d5f; border: 2px solid #8e8e8e; }
        .player-ring-effect {
            position: absolute;
            border-radius: 50%;
            border: 3px dashed #00fff4;
            opacity: 0.5;
            pointer-events: none;
            z-index: 100;
        }
        .upgrade-option-card { transition: transform 0.2s, box-shadow 0.2s; cursor: pointer; }
    </style>
</head>
<body class="bg-gray-900 text-white">

<div id="game-container" class="p-4 sm:p-6 lg:p-8">
    <div id="top-bar" class="w-full mb-2 flex justify-end space-x-2 shrink-0 max-w-[1000px]">
        <button id="fullscreen-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
            <span class="mr-2">üì∫</span> Fullscreen
        </button>
        <button id="pause-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
            <span class="mr-2">‚è∏Ô∏è</span> Pause (P)
        </button>
    </div>

    <div id="game-viewport">
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="overlay"></div>
        </div>
    </div>

    <div id="ui-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <div class="flex justify-between items-center text-xl font-bold">
            <div id="score-left" class="text-blue-400">BLUE: 0</div>
            <div id="center-info" class="text-center">
                <div id="timer" class="text-white text-3xl font-mono">02:00</div>
                <div id="mode-info" class="text-sm text-gray-300 mt-1">TIME REMAINING</div>
            </div>
            <div id="score-right" class="text-red-400">RED: 0</div>
        </div>
    </div>

    <div id="forever-status-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <h3 class="text-xl font-bold mb-3 text-cyan-400">Forever Mode Status</h3>
        <div class="flex flex-wrap justify-between items-start">
            <div class="w-full md:w-1/3 mb-4 md:mb-0">
                <h4 class="font-semibold text-gray-300">AI Challenge</h4>
                <p id="ai-status" class="text-2xl font-bold text-red-400">LV 1 (1 Car)</p>
                <p class="text-sm text-gray-400 mt-1">Player Level: <span id="player-level-display">0</span></p>
            </div>
            <div class="w-full md:w-2/3">
                <h4 class="font-semibold text-gray-300 mb-2">Player Upgrades & Abilities</h4>
                <div id="player-upgrades-display" class="flex flex-wrap gap-4"></div>
            </div>
        </div>
    </div>

</div>

<script>
// --- Constants ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const DEFAULT_WIDTH = 1000, DEFAULT_HEIGHT = 600; 
const CAR_WIDTH = 50, CAR_HEIGHT = 25; 
const BALL_RADIUS = 17; 
const GOAL_HEIGHT = 170; 
const GOAL_LINE_WIDTH = 7; 
const MAX_CENTER_OFFSET_FACTOR = 1 / 6;
const PHYSICS_TICK_RATE = 60; 
const COLOR_BLUE = '#0066cc';
const COLOR_RED = '#cc0000';
const COLOR_CYAN = '#00fff4';
const COLOR_FIELD = '#2b2f3d';

// --- Game State ---
let gameState = 'menu';
let gameMode = '1v1 Multiplayer';
let endConditionType = 'timed';
let timeLimitSeconds = 120;
let targetScore = 5;
let gameTimer = 0;
let scoreLeft = 0, scoreRight = 0;
let cars = [];
let boostPads = [];
let goaliePad = null;
let ball = null;
let foreverBalls = [];
let keys = {};
let lastTime = 0;
let animationFrameId;
let aiDifficulty = 1;
let playerUpgrades = {}; 
let playerAbilities = []; 
let playerLevel = 0;
let upgradeRerollsUsed = 0, extraUpgradePicks = 0, upgradeOptions = [];
let pendingUpgradePick = false;
let stuckBallMessage = { text: '', duration: 0 };

// --- Global declarations for menu state ---
let selectedMenuIndex = 0;
let selectedUpgradeIndex = 0;
let menuOptions = []; 
const fullscreenBtn = document.getElementById('fullscreen-btn');

// --- ABILITY POOLS (UNCHANGED) ---
const BRONZE_UPGRADES = [
    {id:'accel',label:'Engine Boost',icon:'‚ö°',desc:'Acceleration +10%.',tier:'bronze'},
    {id:'turn',label:'Agile Steering',icon:'üåÄ',desc:'Rotation speed +15%.',tier:'bronze'},
    {id:'maxBoost',label:'Fuel Tank',icon:'‚õΩ',desc:'Boost capacity +20.',tier:'bronze'},
    {id:'boostRegen',label:'Quick Refuel',icon:'üîã',desc:'Pad refill +6.',tier:'bronze'},
    {id:'frictionFix',label:'Traction Control',icon:'ü¶∂',desc:'Reduces drift by 10%.',tier:'bronze'},
    {id:'speed',label:'Nitro Burst',icon:'üöÄ',desc:'Top speed +5%.',tier:'bronze'},
    {id:'brake',label:'Hand Brake',icon:'üÖøÔ∏è',desc:'Braking force increased.',tier:'bronze'},
    {id:'kick',label:'Stronger Kick',icon:'ü¶µ',desc:'Ball hit knockback +10%.',tier:'bronze'},
    {id:'stickTires',label:'Sticky Tires',icon:'üß≤',desc:'Less slip after hit.',tier:'bronze'},
    {id:'extraBoostPad',label:'Extra Boost Pad',icon:'‚ú®',desc:'Bonus boost pad on field.',tier:'bronze', permanent:true},
    {id:'smallCar',label:'Micro Car',icon:'üêÅ',desc:'Reduced hitbox.',tier:'bronze'},
    {id:'bigCar',label:'Truck Mode',icon:'üöö',desc:'Larger body, better defense.',tier:'bronze'},
    {id:'slipStream',label:'Slipstream',icon:'üí®',desc:'Gain 10 boost after colliding with an AI.',tier:'bronze'},
];
const SILVER_UPGRADES = [
    {id:'miniRobot',label:'Mini Bot',icon:'ü§ñ',desc:'Spawns a friendly AI attacker.',tier:'silver', permanent:true},
    {id:'goalExpansion',label:'Wide Goal',icon:'ü•Ö',desc:'AI goal is 30% wider.',tier:'silver', permanent:true},
    {id:'doubleKick',label:'Double Kick',icon:'ü•ä',desc:'Doubles ball impact force.',tier:'silver'},
    {id:'ballMagnet',label:'Ball Magnet',icon:'üß≤',desc:'Ball gently follows you for 0.25s after contact.',tier:'silver'},
    {id:'ghostCar',label:'Ghost Mode',icon:'üëª',desc:'Boost for 0.8s to phase through AI for 1.5s (2s cooldown).',tier:'silver'},
    {id:'smolRobot',label:'Tiny Bot',icon:'üêú',desc:'Spawns a friendly AI defender.',tier:'silver', permanent:true},
    {id:'boostRain',label:'Boost Rain',icon:'üå¶Ô∏è',desc:'Small chance to randomly get 30 boost.',tier:'silver'},
];
const GOLD_UPGRADES = [
    {id:'superStun',label:'Stun Ring',icon:'üí´',desc:'After you score, stun nearby AI for 2s on *next* ball contact.',tier:'gold'},
    {id:'extraUpgrade',label:'Extra Choice',icon:'üéà',desc:'Get one extra upgrade pick next round.',tier:'gold'},
    {id:'autoGoalie',label:'Auto Goalie',icon:'üïπÔ∏è',desc:'Spawns an AI goalie pad that blocks your net.',tier:'gold', permanent:true},
    {id:'rerollPlus',label:'Unlimited Rerolls',icon:'üîÑ',desc:'Free rerolls *this selection only*.',tier:'gold'},
    {id:'aiSlow',label:'Slow AI',icon:'üê¢',desc:'AIs are slowed by 50% for 5s after you score.',tier:'gold'},
    {id:'timeFreeze',label:'Time Freeze',icon:'‚ùÑÔ∏è',desc:'Freeze all AIs for 2s when you score.',tier:'gold'},
    {id:'freePad',label:'Free Pad',icon:'üçÄ',desc:'A bonus pad spawns when AI scores.',tier:'gold'},
    {id:'ballSplit',label:'Ball Split',icon:'üé±',desc:'Ball splits into two after you score (max 5 balls).',tier:'gold'},
    {id:'goalBlock',label:'Goal Block',icon:'üöß',desc:'Blocks AI balls from scoring for 3s after you score.',tier:'gold'},
    {id:'shortGoal',label:'Mini Goal',icon:'üõ°Ô∏è',desc:'Your goal becomes smaller.',tier:'gold'},
];
const PLATINUM_UPGRADES = [
    {id:'platinumDoubleAll',label:'Multi Ball Mayhem',icon:'üåà',desc:'Spawns 3 balls. Balls have chance for 2x/3x points.',tier:'platinum', permanent:true},
    {id:'platinumSuperAI',label:'AI Mayhem',icon:'üéÆ',desc:'Confuses all AIs for 5s after you score.',tier:'platinum'},
    {id:'platinumStickyNet',label:'Sticky Net',icon:'üï∏Ô∏è',desc:'Opponent goal is "sticky" and slows the ball.',tier:'platinum'},
];
const ALL_UPGRADES = [...BRONZE_UPGRADES, ...SILVER_UPGRADES, ...GOLD_UPGRADES, ...PLATINUM_UPGRADES];

// --- Ability / Upgrade Functions ---
function getAbilityTierByLevel(level) {
    if (level < 5) return "bronze";
    if (level < 15) return Math.random() < 0.25 ? "silver" : "bronze";
    if (level < 30) {
        const r = Math.random();
        if (r < 0.52) return "silver";
        if (r < 0.70) return "gold";
        return "bronze";
    }
    if (level < 70) {
        const r = Math.random();
        if (r < 0.10) return "platinum";
        if (r < 0.69) return "gold";
        return "silver";
    }
    return Math.random() < 0.17 ? "platinum" : (Math.random() < 0.68 ? "gold" : "silver");
}
function getPoolForTier(tier) {
    if (tier === "bronze") return BRONZE_UPGRADES;
    if (tier === "silver") return SILVER_UPGRADES;
    if (tier === "gold") return GOLD_UPGRADES;
    if (tier === "platinum") return PLATINUM_UPGRADES;
}
function randomAbilities(amt, disallowIds=[]) {
    let chosen = [];
    const playerUpgradeIds = Object.keys(playerUpgrades);
    for (let i = 0; i < amt; i++) {
        let tier = getAbilityTierByLevel(playerLevel);
        let pool = getPoolForTier(tier).filter(u => !disallowIds.includes(u.id));
        pool = pool.filter(u => !u.permanent || !playerUpgradeIds.includes(u.id));
       
        if (pool.length === 0) {
            pool = BRONZE_UPGRADES.filter(u => !disallowIds.includes(u.id) && (!u.permanent || !playerUpgradeIds.includes(u.id)));
        }
        if (pool.length === 0) {
             pool = [BRONZE_UPGRADES[0]];
        }
       
        const pick = pool[Math.floor(Math.random() * pool.length)];
        chosen.push(pick);
        disallowIds.push(pick.id);
    }
    return chosen;
}
function requestUpgradePicker() {
    gameState = 'upgrading';
    upgradeRerollsUsed = 0;
    rerollUpgradeOptions(); 
    document.getElementById('pause-btn').classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
}
function rerollUpgradeOptions() {
    let numPicks = 3 + extraUpgradePicks;
    const currentUpgrades = Object.keys(playerUpgrades);
    const excluded = upgradeOptions.map(u => u.id).filter(id => id !== 'reroll' && id !== 'rerollPlus');
   
    upgradeOptions = randomAbilities(numPicks, excluded);
   
    if (upgradeRerollsUsed < 1 && !playerUpgrades.rerollPlus) {
        if (!upgradeOptions.some(o => o.id === 'reroll')) {
            upgradeOptions.push({id:'reroll', label:'REROLL', icon:'üîÑ', desc:`Reroll options (${1-upgradeRerollsUsed} remaining).`, tier:'bronze'});
        }
    } else if (playerUpgrades.rerollPlus) {
         if (!upgradeOptions.some(o => o.id === 'rerollPlus')) {
             upgradeOptions.push({id:'rerollPlus', label:'FREE REROLL', icon:'üîÑ', desc:`Unlimited rerolls for this round.`, tier:'gold'});
         }
    }
    selectedUpgradeIndex = 0;
    drawUpgradeMenu();
}
function applyUpgrade(ability) {
    if (ability.id === 'extraUpgrade') {
        extraUpgradePicks++;
    } else {
        playerUpgrades[ability.id] = (playerUpgrades[ability.id] || 0) + 1;
        if (playerAbilities.findIndex(a => a.id === ability.id) === -1) {
            playerAbilities.push(ability);
        }
    }
   
    cars.filter(c => !c.ai).forEach(c => c.applyPlayerUpgrades(playerUpgrades));
   
    if (ability.id === 'miniRobot' && !cars.some(c => c.playerId === 1001)) addFriendlyAICar(1001, 'attacker', 1.5);
    if (ability.id === 'smolRobot' && !cars.some(c => c.playerId === 1002)) addFriendlyAICar(1002, 'defender', 1.0);
    if (ability.id === 'autoGoalie' && !goaliePad) { goaliePad = new GoaliePad(); }
    if (ability.id === 'platinumDoubleAll' && foreverBalls.length === 1) {
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.forEach(b => b.reset());
    }
   
    updateUpgradesDisplay();
}
function exitUpgradePicker() {
    gameState = 'playing';
    extraUpgradePicks = 0; 
    overlay.classList.remove('visible'); // Use class logic
    overlay.innerHTML = '';
    pauseBtn.classList.remove('hidden');
    document.getElementById('fullscreen-btn').classList.remove('hidden');
   
    lastTime = performance.now();
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Classes --
class Car {
    constructor(x, y, color, controls, team_side, player_id, initial_angle, ai=false, difficulty=1, role="attacker") {
        this.x=x; this.y=y; this.color=color; this.team_side=team_side; this.controls=controls;
        this.playerId=player_id; this.angle=initial_angle; this.velX=0; this.velY=0; this.speed=0;
       
        this.baseAcceleration=0.3; this.baseMaxSpeed=5.0;
        this.baseRotationSpeed=4.5; this.baseSideFrictionFactor=0.05;
        this.boostPower=1.8; this.boostUsage=1.2; this.maxBoost=100; this.boost=this.maxBoost; this.boosting=false;
       
        this.throttleDirection=0;
        this.ai=ai; this.difficulty=difficulty; this.role = role;
        this.upgrades={}; this.abilities=[]; this.effects={};
        this.isStunned=false;
        this.stunDuration=0;
       
        this.isFriendlyAI = team_side === 'left' && ai;
        this.baseColor = color;
        this.boostTimer = 0; 
        this.sizeMultiplier = 1.0;
       
        this.stuckInCornerTimer = 0;
        this.stuckInCornerThreshold = 5.0 + Math.random() * 2.0;
       
        this.updateDifficulty(difficulty);
        this.resetPos={x,y,angle:initial_angle};
    }
   
    updateDifficulty(difficulty) {
        this.difficulty = difficulty;
        if (this.ai) {
            this.acceleration = this.baseAcceleration + 0.05 * (difficulty-1);
            this.maxBoost = 100 + 10 * (difficulty-1);
            this.rotationSpeed = this.baseRotationSpeed;
            this.sideFrictionFactor = this.baseSideFrictionFactor;
        } else {
            this.applyPlayerUpgrades(playerUpgrades);
        }
    }
   
    applyPlayerUpgrades(upgrades) {
        if (this.ai) return; 
        let count = id => upgrades[id]||0;
       
        this.acceleration = this.baseAcceleration * (1 + count('accel') * 0.1);
        this.rotationSpeed = this.baseRotationSpeed * (1 + count('turn') * 0.15);
        this.maxBoost = 100 + count('maxBoost') * 20;
        this.baseMaxSpeed = 5.0 * (1 + count('speed') * 0.05);
        let frictionFactor = 1 - count('frictionFix') * 0.1;
        this.sideFrictionFactor = this.baseSideFrictionFactor * Math.max(0.1, frictionFactor);
       
        this.sizeMultiplier = 1.0; 
        if (count('smallCar') > 0) this.sizeMultiplier *= 0.75; 
        if (count('bigCar') > 0) this.sizeMultiplier *= 1.25; 
       
        this.boost = Math.min(this.maxBoost,this.boost); 
    }
   
    handleInput(deltaTime) { 
        if (this.ai) { this.handleAI(deltaTime); return; }
        if (this.isStunned) return;
       
        this.throttleDirection=0; let accelerationForce = 0;
       
        if (keys[this.controls['left']]) this.angle=(this.angle+this.rotationSpeed)%360;
        if (keys[this.controls['right']]) this.angle=(this.angle-this.rotationSpeed)%360;
       
        if (keys[this.controls['up']]) {accelerationForce=this.acceleration;this.throttleDirection=1;}
        if (keys[this.controls['down']]) {
            if (playerUpgrades.brake) { accelerationForce=-this.acceleration*2.0; }
            else { accelerationForce = -this.acceleration * 0.7;}
            this.throttleDirection=-1;
        }
       
        if (accelerationForce!==0) {
            let rad=Math.PI*this.angle/180;
            this.velX+=Math.cos(rad)*accelerationForce; this.velY-=Math.sin(rad)*accelerationForce;
        }
       
        let boostActive = keys[this.controls['boost']];
        
        if (gameMode === 'Vs Computer' && this.playerId === 1) {
            if (keys['ShiftLeft'] || keys['ShiftRight']) {
                boostActive = true;
            }
        }
       
        this.boosting = boostActive && this.boost > 0;
       
        if (this.boosting) {
             this.boostTimer += deltaTime;
             if (playerUpgrades.ghostCar && this.boostTimer > 0.8 && !this.effects.ghost) {
                 this.effects.ghost = { duration: 1.5 }; 
                 this.boostTimer = -2.0; 
             }
        } else {
            this.boostTimer = Math.max(0, this.boostTimer); 
        }
    }

    handleAI(deltaTime) {
        if (!ball || this.isStunned) return;
       
        cars.forEach(otherCar => {
            if (otherCar === this || !otherCar.ai || otherCar.isFriendlyAI) return;
            let dxAI = this.x - otherCar.x;
            let dyAI = this.y - otherCar.y;
            let distAI = Math.hypot(dxAI, dyAI);
            let avoidRadius = (CAR_WIDTH * this.sizeMultiplier) * 1.5;
            if (distAI < avoidRadius && distAI > 0) {
                let separationForce = 0.3 * (avoidRadius - distAI) / avoidRadius;
                this.velX += (dxAI / distAI) * separationForce;
                this.velY += (dyAI / distAI) * separationForce;
            }
        });
       
        const center_x = canvas.width / 2;
        const numAIs = getNumberOfAICars();
        let targetX, targetY;
       
        let targetBall = foreverBalls[0];
        let minBallDist = Infinity;
        foreverBalls.forEach(b => {
            let dist = Math.hypot(b.x - this.x, b.y - this.y);
            if (dist < minBallDist) {
                minBallDist = dist;
                targetBall = b;
            }
        });
       
        switch(this.role){
            case "defender":
                let gLineX = this.team_side === "right" ? canvas.width - BALL_RADIUS*3 : BALL_RADIUS*3;
                targetX = gLineX;
                targetY = Math.max(canvas.height/2-GOAL_HEIGHT/2+BALL_RADIUS, Math.min(targetBall.y,canvas.height/2+GOAL_HEIGHT/2-BALL_RADIUS));
                
                if (numAIs > 1) {
                    targetX = Math.max(canvas.width * 0.70, targetX);
                }
                if (this.team_side === 'right' && targetBall.x > canvas.width - 100) targetX = targetBall.x;
                break;
            case "mid":
                targetX = targetBall.x; targetY = targetBall.y;
                
                if (numAIs >= 3) { 
                    targetX = Math.max(canvas.width * 0.45, Math.min(targetX, canvas.width * 0.80));
                }
                break;
            case "attacker":
                targetX = targetBall.x; targetY = targetBall.y;
                let zoneLeft = 0;
                let zoneRight = canvas.width;
                let zoneTop = 0;
                let zoneBottom = canvas.height;

                if (numAIs === 2) zoneRight = canvas.width * 0.80; 
                if (numAIs >= 3) zoneRight = canvas.width * 0.55; 

                if (numAIs >= 4) {
                    let attackers = cars.filter(c => c.ai && !c.isFriendlyAI && c.role === 'attacker').sort((a,b) => a.playerId - b.playerId);
                    let myAttackerIndex = attackers.findIndex(a => a.playerId === this.playerId);
                    
                    if (myAttackerIndex === 0) { 
                        zoneBottom = canvas.height / 2;
                        if (targetBall.y > zoneBottom || targetBall.x > zoneRight) {
                            targetY = canvas.height * 0.25; 
                        }
                    } else if (myAttackerIndex >= 1) { 
                        zoneTop = canvas.height / 2;
                         if (targetBall.y < zoneTop || targetBall.x > zoneRight) {
                            targetY = canvas.height * 0.75;
                        }
                    }
                    if (targetBall.x > zoneRight && targetBall.x > this.x) targetX = (zoneLeft + zoneRight) / 2;
                }
                
                targetX = Math.max(zoneLeft, Math.min(targetX, zoneRight));
                targetY = Math.max(zoneTop, Math.min(targetY, zoneBottom));
                break;
            case "goalkeeper":
                let gkLineX = this.team_side === "right" ? canvas.width - BALL_RADIUS*3 : BALL_RADIUS*3;
                targetX = gkLineX;
                targetY = Math.max(canvas.height/2-GOAL_HEIGHT/2+BALL_RADIUS, Math.min(targetBall.y,canvas.height/2+GOAL_HEIGHT/2-BALL_RADIUS));
                break;
            default: targetX=targetBall.x; targetY=targetBall.y;
        }
       
        const cornerSize = 150;
        const ballInTop = targetBall.y < cornerSize;
        const ballInBottom = targetBall.y > canvas.height - cornerSize;
        const ballInLeft = targetBall.x < cornerSize;
        const ballInRight = targetBall.x > canvas.width - cornerSize;

        const aiNearTop = this.y < cornerSize + 50;
        const aiNearBottom = this.y > canvas.height - cornerSize - 50;
        const aiNearLeft = this.x < cornerSize + 50;
        const aiNearRight = this.x > canvas.width - cornerSize - 50;
       
        let aiIsInCorner = false;
        if ((ballInTop && aiNearTop) || (ballInBottom && aiNearBottom)) {
            if ((ballInLeft && aiNearLeft) || (ballInRight && aiNearRight)) {
                aiIsInCorner = true;
            }
        }

        if (aiIsInCorner && this.role !== 'goalkeeper') {
            this.stuckInCornerTimer += deltaTime;
            
            if (this.stuckInCornerTimer > this.stuckInCornerThreshold) { 
                if (this.role === 'defender') {
                    targetX = canvas.width / 2;
                    targetY = canvas.height / 2;
                } else { 
                    targetX = targetBall.x;
                    targetY = targetBall.y;
                    if (ballInLeft) targetX = cornerSize + 20;
                    if (ballInRight) targetX = canvas.width - cornerSize - 20;
                    if (ballInTop) targetY = cornerSize + 20;
                    if (ballInBottom) targetY = canvas.height - cornerSize - 20;
                }
            }
        } else {
            this.stuckInCornerTimer = 0; 
            if (this.stuckInCornerTimer < -1) { 
                 this.stuckInCornerThreshold = 5.0 + Math.random() * 2.0;
            }
        }
       
        const dx=targetX-this.x,dy=targetY-this.y;
        const targetAngleRad=Math.atan2(-dy,dx); let targetAngle=(targetAngleRad*180/Math.PI+360)%360;
        let angleDiff = targetAngle-this.angle; if(angleDiff>180)angleDiff-=360;if(angleDiff<-180)angleDiff+=360;
        const dist = Math.hypot(dx,dy);
       
        if(this.effects.confused) {
            this.angle = (this.angle + (Math.random() < 0.5 ? 5 : -5)) % 360;
            this.throttleDirection = Math.random() < 0.7 ? 1 : 0;
        } else {
            if(angleDiff>this.rotationSpeed){this.angle=(this.angle+this.rotationSpeed)%360;}
            else if(angleDiff<-this.rotationSpeed){this.angle=(this.angle-this.rotationSpeed)%360;}
            else{this.angle=targetAngle;}
           
            this.throttleDirection=0;
            if(Math.abs(angleDiff)<32) {
                let rad=Math.PI*this.angle/180;
                let roleBoost = (this.role==='attacker'?1.14:(this.role==='defender'?0.87:1));
                this.velX+=Math.cos(rad)*this.acceleration*roleBoost;
                this.velY-=Math.sin(rad)*this.acceleration*roleBoost;
                this.throttleDirection=1;
            }
        }
       
        let boostThreshold = this.maxBoost * (0.1 * this.difficulty);
        if (["attacker","mid"].includes(this.role)) {
            let basicBoost = this.boost > boostThreshold && ((dist > 200 && (Math.abs(angleDiff) < 8)));
            
            let numAIs = getNumberOfAICars();
            if (numAIs >= 6) {
                boostThreshold = this.maxBoost * 0.1; 
                basicBoost = this.boost > boostThreshold && ((dist > 150 && (Math.abs(angleDiff) < 15)));
                this.boosting = basicBoost; 
            } else {
                this.boosting = (this.difficulty > 1 ? basicBoost : false);
            }
        } else { 
            this.boosting = false; 
        }
    }
   
    move(deltaTime) {
        if(this.isStunned){
            this.stunDuration -= deltaTime;
            if(this.stunDuration <= 0) {
                this.isStunned=false;
                this.stunDuration = 0;
            }
            return;
        }
       
        ["slow","confused","forceField","invincible","goalBlock","ring","ghost"].forEach(eff=>{
            if(this.effects[eff]) {
                this.effects[eff].duration -= deltaTime;
                if(this.effects[eff].duration <=0) delete this.effects[eff];
            }
        });
       
        let rad=Math.PI*this.angle/180;
        let fVel=this.velX*Math.cos(rad)-this.velY*Math.sin(rad);
        let sVel=this.velX*Math.sin(rad)+this.velY*Math.cos(rad);
        sVel*=(1-this.sideFrictionFactor); fVel*=0.96;
       
        if(this.boosting && this.boost>0 && this.throttleDirection!==0) {
            let boostForce=this.acceleration*this.boostPower*1.5;
            fVel+=boostForce*this.throttleDirection;
            if(!this.effects.invincible) this.boost -= this.boostUsage * deltaTime * PHYSICS_TICK_RATE;
            if(this.boost<0){this.boost=0;this.boosting=false;}
        }
       
        this.velX= fVel*Math.cos(rad)+sVel*Math.sin(rad);
        this.velY= -fVel*Math.sin(rad)+sVel*Math.cos(rad);

        let speedMultiplier = 1;
        if(this.effects.slow) speedMultiplier = this.effects.slow.factor;
       
        this.speed = Math.hypot(this.velX,this.velY);
        let maxSpeed = this.baseMaxSpeed*(this.boosting?this.boostPower:1);
        if(this.speed>maxSpeed){let sc=maxSpeed/this.speed;this.velX*=sc;this.velY*=sc;}
       
        this.x += this.velX * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
       
        let w = CAR_WIDTH * this.sizeMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier;
        
        let marginW = w / 2;
        let marginH = h / 2;

        if (this.x < marginW) {
            this.x = marginW;
            this.velX *= -0.5;
        } else if (this.x > canvas.width - marginW) {
            this.x = canvas.width - marginW;
            this.velX *= -0.5;
        }
       
        if (this.y < marginH) {
            this.y = marginH;
            this.velY *= -0.5;
        } else if (this.y > canvas.height - marginH) {
            this.y = canvas.height - marginH;
            this.velY *= -0.5;
        }
    }
   
    draw() {
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(-Math.PI*this.angle/180);
       
        let w = CAR_WIDTH * this.sizeMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier;
       
        let displayColor = this.color;
        if(this.isFriendlyAI) displayColor = '#00cccc';
        if(this.isStunned) displayColor = '#aaaaaa';
        if(this.effects.ring) displayColor = '#fcd34d';
        if(this.effects.forceField) displayColor = '#00ff00';
        if(this.effects.invincible) displayColor = '#ff00ff';
        if(this.effects.ghost) displayColor = 'rgba(255,255,255,0.5)';
       
        ctx.fillStyle=displayColor;
        ctx.beginPath(); ctx.roundRect(-w/2,-h/2, w, h, 8 * this.sizeMultiplier); ctx.fill();
       
        ctx.fillStyle='yellow';
        ctx.beginPath(); ctx.roundRect(w/2-(10*this.sizeMultiplier),-h/2+(5*this.sizeMultiplier), 8*this.sizeMultiplier, h-(10*this.sizeMultiplier), 2*this.sizeMultiplier); ctx.fill();
       
        if(this.boosting){
            ctx.fillStyle="#ffaa00";
            ctx.beginPath(); ctx.moveTo(-w/2,0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),-h/4);
            ctx.lineTo(-w/2-(20*this.sizeMultiplier),0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),h/4); ctx.closePath(); ctx.fill();
        }
        ctx.restore();
       
        if(this.effects.ring || this.effects.forceField){
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = this.effects.ring ? "#fcd34d" : (this.effects.forceField ? "#00ff00":"#00fff4");
            ctx.globalAlpha = 0.6; ctx.lineWidth=4;
            let radius = (CAR_WIDTH * this.sizeMultiplier) * 1.7;
            if(this.effects.forceField) radius = (CAR_WIDTH * this.sizeMultiplier) * 2.5;
            ctx.arc(this.x,this.y,radius,0,Math.PI*2); ctx.stroke();
            ctx.restore();
        }
       
        const isHuman=!this.ai;
        const label = isHuman?`P${this.playerId}`:`AI Lv.${this.difficulty} (${this.role})`;
        const labelY=this.y-h/2-15, barWidth=40, barHeight=6, bpct=this.boost/this.maxBoost;
        ctx.fillStyle=isHuman?COLOR_BLUE:(this.isFriendlyAI ? '#00cccc' : COLOR_RED);
        ctx.font='12px Inter'; ctx.textAlign='center';
        ctx.fillText(label,this.x,labelY-5);
        ctx.fillStyle='#1f2937';
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth,barHeight,3); ctx.fill();
        let grad = ctx.createLinearGradient(this.x-barWidth/2,0,this.x-barWidth/2+barWidth,0);
        grad.addColorStop(0,bpct<0.3?'#ef4444':'#f97316'); grad.addColorStop(1,'#f97316');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth*bpct,barHeight,3); ctx.fill();
    }
   
    refillBoost(amount) {
        this.boost = Math.min(this.maxBoost,this.boost+amount);
    }
   
    reset() {
        this.x=this.resetPos.x; this.y=this.resetPos.y; this.angle=this.resetPos.angle;
        this.velX=0; this.velY=0; this.speed=0; this.boost=this.maxBoost;
        this.isStunned=false; this.stunDuration=0; this.effects={};
        this.stuckInCornerTimer = 0;
        this.stuckInCornerThreshold = 5.0 + Math.random() * 2.0;
    }
}

class Ball {
    constructor(x, y, radius, pointType=1) {
        this.x=x;this.y=y;this.radius=radius;this.color=COLOR_CYAN;
        this.velX=0;this.velY=0;this.maxSpeed=35; this.pointType=pointType; this.effects = {};
       
        this.stuckTimer = 0;
        this.ballStuckCountdown = 0;
    }
   
    move(deltaTime) {
        if (this.effects.magnet) {
            let playerCar = cars.find(c => c.playerId === 1);
            if (playerCar) {
                let dx = playerCar.x - this.x;
                let dy = playerCar.y - this.y;
                let dist = Math.hypot(dx, dy);
                let pullForce = 0.005;
                if (dist > 10) {
                    this.velX += dx * pullForce;
                    this.velY += dy * pullForce;
                }
                this.effects.magnet.duration -= deltaTime;
                if (this.effects.magnet.duration <= 0) delete this.effects.magnet;
            } else {
                delete this.effects.magnet;
            }
        }

        this.velX *= 0.98; 
        this.velY *= 0.98;
       
        let speed = Math.hypot(this.velX, this.velY);
        if(speed > this.maxSpeed){
            let sc = this.maxSpeed / speed;
            this.velX *= sc;
            this.velY *= sc;
        }
       
        this.x += this.velX * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * deltaTime * PHYSICS_TICK_RATE;
       
        let bMargin = this.radius;
       
        if (this.x < bMargin) {
            this.x = bMargin;
            this.velX *= -0.8;
        } else if (this.x > canvas.width - bMargin) {
            this.x = canvas.width - bMargin;
            this.velX *= -0.8;
        }
       
        if (this.y < bMargin) {
            this.y = bMargin;
            this.velY *= -0.8;
        } else if (this.y > canvas.height - bMargin) {
            this.y = canvas.height - bMargin;
            this.velY *= -0.8;
        }
       
        if(playerUpgrades.platinumStickyNet) {
            let aiGoalTop=canvas.height/2-GOAL_HEIGHT/2, aiGoalBottom=canvas.height/2+GOAL_HEIGHT/2;
            if(this.y>aiGoalTop && this.y<aiGoalBottom && this.x > canvas.width - (BALL_RADIUS*3)) {
                this.velX *= 0.9;
            }
        }
       
        const STUCK_SPEED_LIMIT = 0.8; 
        const STUCK_GRACE_PERIOD = 2.0; 
        const STUCK_COUNTDOWN = 5.0; 

        const cornerCheckSize = 150; 
        const ballInTop = this.y < cornerCheckSize;
        const ballInBottom = this.y > canvas.height - cornerCheckSize;
        const ballInLeft = this.x < cornerCheckSize;
        const ballInRight = this.x > canvas.width - cornerCheckSize;
        
        let ballIsInCorner = false;
        if (ballInTop || ballInBottom) {
            if (ballInLeft || ballInRight) {
                ballIsInCorner = true;
            }
        }

        if (speed < STUCK_SPEED_LIMIT && ballIsInCorner) { 
            this.stuckTimer += deltaTime;

            if (this.stuckTimer > STUCK_GRACE_PERIOD) {
                this.ballStuckCountdown = Math.ceil(STUCK_COUNTDOWN - (this.stuckTimer - STUCK_GRACE_PERIOD));
               
                if (this.ballStuckCountdown < 1) { 
                    this.reset();
                    stuckBallMessage = { text: 'Ball stuck! Resetting position...', duration: 2.0 };
                }
            }
        } else {
            this.stuckTimer = 0;
            this.ballStuckCountdown = 0;
        }
    }
   
    draw() {
        ctx.fillStyle=this.pointType===1?this.color:(this.pointType===2?'#ffe066':'#ff92c6');
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,0.5)';
        ctx.beginPath(); ctx.arc(this.x-5,this.y-5,this.radius/2,0,Math.PI*2); ctx.fill();
       
        if(this.pointType>1){
            ctx.save();
            ctx.font='bold 13px Inter'; ctx.globalAlpha=0.90;
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillStyle=(this.pointType===2?'#fcad03':'#ed1b90'); ctx.strokeStyle='#fff';
            let txt=(this.pointType===2?'2x':'3x');
            ctx.fillText(txt,this.x,this.y-this.radius+10);
            ctx.restore();
        }
    }
   
    reset() {
        let maxOffset=canvas.height*MAX_CENTER_OFFSET_FACTOR, randomYOffset=Math.random()*2*maxOffset-maxOffset;
        this.x=canvas.width/2; this.y=canvas.height/2+randomYOffset; this.velX=0;this.velY=0;
       
        this.stuckTimer = 0;
        this.ballStuckCountdown = 0;
       
        let r=Math.random();
        if(playerUpgrades.platinumDoubleAll) {
            if(r<0.10) this.pointType=3;
            else if(r<0.30) this.pointType=2;
            else this.pointType=1;
        } else if(r<0.03) this.pointType=3;
        else if(r<0.13) this.pointType=2;
        else this.pointType=1;
       
        this.effects = {};
    }
}

class BoostPad {
    constructor(x,y,radius=12){ 
        this.x=x;this.y=y;this.radius=radius; 
        this.active = true;
        this.cooldownTimer = 0;
        this.cooldownDuration = 3.0; 
    }
    
    update(deltaTime) {
        if (!this.active) {
            this.cooldownTimer -= deltaTime;
            if (this.cooldownTimer <= 0) {
                this.active = true;
            }
        }
    }

    draw() {
        ctx.save();
        if (!this.active) {
            ctx.globalAlpha = 0.3; 
        }
        ctx.strokeStyle="#fbbf24"; ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle="#f59e42";
        ctx.beginPath(); 
        ctx.arc(this.x,this.y,this.radius-7,0,Math.PI*2); 
        ctx.fill();
        ctx.restore();
    }
    
    checkCollision(car){
        if (!this.active) return false; 
        let dist=Math.hypot(this.x-car.x,this.y-car.y);
        return dist<this.radius+(CAR_WIDTH * car.sizeMultiplier / 2);
    }

    consume(car) {
        if (!this.active) return;
        
        this.active = false;
        this.cooldownTimer = this.cooldownDuration;
        
        let refill = 25; 
        
        if(!car.ai && car.playerId===1){
            refill += (playerUpgrades.boostRegen || 0) * 6;
        }
        car.refillBoost(refill);
    }
}

class GoaliePad {
    constructor() {
        this.width = GOAL_LINE_WIDTH * 2;
        this.height = GOAL_HEIGHT * 0.20; 
        this.x = GOAL_LINE_WIDTH / 2;
        this.y = canvas.height / 2;
        this.speed = 400; 
    }
    update(deltaTime) {
        let targetBall = foreverBalls[0];
        if (foreverBalls.length > 1) {
            let minBallDist = Infinity;
            foreverBalls.forEach(b => {
                if (b.x < canvas.width / 2 + 100) {
                    let dist = Math.abs(b.y - this.y);
                    if (dist < minBallDist) {
                        minBallDist = dist;
                        targetBall = b;
                    }
                }
            });
        }
       
        let targetY = targetBall.y;
        let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
        let playerGoalTop = canvas.height/2 - goalHeight/2;
        let playerGoalBottom = canvas.height/2 + goalHeight/2;
       
        let targetCenter = Math.max(playerGoalTop + this.height/2, Math.min(targetY, playerGoalBottom - this.height/2));
       
        let moveDist = this.speed * deltaTime;
       
        if (this.y < targetCenter) this.y = Math.min(this.y + moveDist, targetCenter);
        else if (this.y > targetCenter) this.y = Math.max(this.y - moveDist, targetCenter);
       
        this.y = Math.max(playerGoalTop + this.height/2, Math.min(this.y, playerGoalBottom - this.height/2));
    }
    draw() {
        ctx.fillStyle = '#00cccc';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height, 4);
        ctx.fill();
        ctx.stroke();
    }
    checkCollision(ball) {
        let top = this.y - this.height/2;
        let bottom = this.y + this.height/2;
        let left = this.x - this.width/2;
        let right = this.x + this.width/2;
       
        if (ball.x - ball.radius < right && ball.x + ball.radius > left && ball.y > top && ball.y < bottom) {
            if (ball.velX < 0) {
                ball.velX *= -1.2;
                ball.x = right + ball.radius;
            }
        }
    }
}


// ====== Game Functions ======
function getInitialAngle(x1,y1,x2,y2){
    let angleRad=Math.atan2(y1-y2,x2-x1);
    return (angleRad*180/Math.PI+360)%360;
}
function getNumberOfAICars(){return cars.filter(c=>c.ai&&!c.isFriendlyAI).length;}

function addFriendlyAICar(playerId, role, difficultyMultiplier) {
    const P1_X=100+CAR_WIDTH/2, center_y=canvas.height/2;
    let newAI = new Car(P1_X + 20, center_y + (Math.random() * 100 - 50),
                        '#00cccc', {}, 'left', playerId,
                        getInitialAngle(P1_X, center_y, canvas.width/2, center_y),
                        true, aiDifficulty * difficultyMultiplier, role);
    newAI.sizeMultiplier = 0.75;
    cars.push(newAI);
}

function addEnemyAICar() {
    let center_x=canvas.width/2, center_y=canvas.height/2;
    let P2_X=canvas.width-100-CAR_WIDTH/2;
    let P1_Y_OFFSET=CAR_HEIGHT*2;
    let aiY=center_y+((Math.random() > 0.5)?P1_Y_OFFSET*(Math.random()*2):-P1_Y_OFFSET*Math.random()*2);
   
    let newAI = new Car(P2_X,aiY,COLOR_RED,{},'right',2+getNumberOfAICars(),getInitialAngle(P2_X,aiY,center_x,center_y),true,aiDifficulty);
    cars.push(newAI);
   
    let allAIs = cars.filter(c => c.ai && !c.isFriendlyAI);
    allAIs.forEach((ai, index) => {
        ai.sizeMultiplier = Math.max(0.6, 1.0 - (index * 0.08));
    });
   
    assignAIRoles(allAIs);
}

function assignAIRoles(aiCars){
    const roleOrder = ["attacker", "defender", "mid", "attacker", "defender", "mid"];
   
    aiCars.sort((a, b) => a.playerId - b.playerId).forEach((ai, index) => {
        ai.role = roleOrder[index] || "attacker";
    });
}

function setupGameObjects(mode,initialAICount=1){
    canvas.width = DEFAULT_WIDTH;
    canvas.height = DEFAULT_HEIGHT;
   
    let center_x=canvas.width/2, center_y=canvas.height/2;
   
    let initialBallCount = 1;
    if(playerUpgrades.platinumDoubleAll) initialBallCount = 3;
    foreverBalls = [];
    for(let i=0; i<initialBallCount; i++) {
        let newBall = new Ball(center_x, center_y, BALL_RADIUS);
        newBall.reset();
        foreverBalls.push(newBall);
    }
    ball = foreverBalls[0];
   
    cars=[];
    let P1_X=100+CAR_WIDTH/2, P2_X=canvas.width-100-CAR_WIDTH/2;
    let P1_Y_OFFSET=CAR_HEIGHT*2;
   
    let p1 = new Car(P1_X,center_y,COLOR_BLUE,
        {'up':'KeyW','down':'KeyS','left':'KeyA','right':'KeyD','boost':'ShiftLeft'},'left',1,getInitialAngle(P1_X,center_y,center_x,center_y));
    cars.push(p1);

    if(mode==="1v1 Multiplayer") {
        cars.push(new Car(P2_X,center_y,COLOR_RED,
            {'up':'ArrowUp','down':'ArrowDown','left':'ArrowLeft','right':'ArrowRight','boost':'ShiftRight'},
            'right',2,getInitialAngle(P2_X,center_y,center_x,center_y)));
    }
    else if(mode==="2v2 Multiplayer") {
        cars.push(new Car(P1_X,center_y+P1_Y_OFFSET, COLOR_BLUE, { 'up': 'KeyT', 'down': 'KeyG', 'left': 'KeyF', 'right': 'KeyH', 'boost': 'Space' }, 'left', 2, getInitialAngle(P1_X,center_y+P1_Y_OFFSET,center_x,center_y)));
        
        cars.push(new Car(P2_X,center_y-P1_Y_OFFSET, COLOR_RED, { 'up': 'ArrowUp', 'down': 'ArrowDown', 'left': 'ArrowLeft', 'right': 'ArrowRight', 'boost': 'ControlRight' }, 'right', 3, getInitialAngle(P2_X,center_y-P1_Y_OFFSET,center_x,center_y)));
        cars.push(new Car(P2_X,center_y+P1_Y_OFFSET, COLOR_RED, { 'up': 'KeyI', 'down': 'KeyK', 'left': 'KeyJ', 'right': 'KeyL', 'boost': 'ShiftRight' }, 'right', 4, getInitialAngle(P2_X,center_y+P1_Y_OFFSET,center_x,center_y)));
    }
   
    if(mode==="Vs Computer"){
        for(let i=0; i<initialAICount;i++){
            let aiY=center_y+((i%2===0)?P1_Y_OFFSET*(i/2):-P1_Y_OFFSET*Math.ceil(i/2));
            let aiObj=new Car(P2_X,aiY,COLOR_RED,{},'right',2+i,getInitialAngle(P2_X,aiY,center_x,center_y),true,aiDifficulty);
            cars.push(aiObj);
        }
        assignAIRoles(cars.filter(c=>c.ai&&!c.isFriendlyAI));
       
        if(playerUpgrades.miniRobot) addFriendlyAICar(1001, 'attacker', 1.5);
        if(playerUpgrades.smolRobot) addFriendlyAICar(1002, 'defender', 1.0);
    }
   
    p1.applyPlayerUpgrades(playerUpgrades);
   
    goaliePad = null;
    if (playerUpgrades.autoGoalie) { goaliePad = new GoaliePad(); }
   
    boostPads=[
        new BoostPad(canvas.width*0.5,canvas.height*0.25), new BoostPad(canvas.width*0.5,canvas.height*0.75),
        new BoostPad(canvas.width*0.25,canvas.height*0.5), new BoostPad(canvas.width*0.75,canvas.height*0.5),
        new BoostPad(canvas.width*0.5,canvas.height*0.5),
        new BoostPad(canvas.width*0.1,canvas.height*0.12), new BoostPad(canvas.width*0.9,canvas.height*0.12),
        new BoostPad(canvas.width*0.1,canvas.height*0.88), new BoostPad(canvas.width*0.9,canvas.height*0.88),
    ];
    if(playerUpgrades.extraBoostPad) {
        boostPads.push(new BoostPad(canvas.width*0.35, canvas.height*0.35));
        boostPads.push(new BoostPad(canvas.width*0.65, canvas.height*0.65));
    }
}

// --- UI and Menu functions ---

const overlay = document.getElementById('overlay');
const uiPanel = document.getElementById('ui-panel');
const foreverStatusPanel = document.getElementById('forever-status-panel');
const pauseBtn = document.getElementById('pause-btn');

function updateUI(){
    let modeInfoElement=document.getElementById('mode-info'), timerElement=document.getElementById('timer'), aiStatusElement=document.getElementById('ai-status');
   
    document.getElementById('score-left').textContent=`BLUE: ${scoreLeft}`;
    document.getElementById('score-right').textContent=`RED: ${scoreRight}`;
   
    if(endConditionType==='points'){
        timerElement.textContent=`${scoreLeft} / ${targetScore}`;
        modeInfoElement.textContent=`PLAYER GOALS`;
        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.add('hidden');
    }
    else if(endConditionType==='timed'){
        let minutes=Math.floor(gameTimer/60), seconds=Math.floor(gameTimer%60);
        timerElement.textContent=`${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
        modeInfoElement.textContent=`TIME REMAINING`;
        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.add('hidden');
    }
    else if(endConditionType==='forever'){
        timerElement.textContent=`${playerLevel}`;
        modeInfoElement.textContent=`PLAYER LEVEL`;
        aiStatusElement.textContent = `LV ${aiDifficulty} (${getNumberOfAICars()} Car${getNumberOfAICars()!==1?'s':''})`;
        document.getElementById('player-level-display').textContent = playerLevel;
       
        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.remove('hidden');
    }
    updateUpgradesDisplay();
}

function updateUpgradesDisplay() {
    const display = document.getElementById('player-upgrades-display');
    display.innerHTML = '';
   
    if (playerAbilities.length === 0) {
        display.innerHTML = `<p class="text-sm text-gray-400">Score to earn upgrades!</p>`;
        return;
    }
   
    playerAbilities.forEach(ability => {
        const count = playerUpgrades[ability.id] || 0;
        const countDisplay = count > 1 ? ` (x${count})` : '';
        const levelClass = `ability-level-${ability.tier}`;
        const item = document.createElement('div');
       
        item.className = `p-2 rounded-lg text-sm font-semibold flex items-center shadow-md ${levelClass} upgrade-icon-container`;
       
        item.innerHTML = `
            <span class="text-xl mr-1">${ability.icon}</span>
            ${ability.label}${countDisplay}
            <div class="upgrade-tooltip">
                <h4 class="font-bold mb-1 flex items-center">
                    <span class="text-xl mr-2">${ability.icon}</span>
                    ${ability.label}
                    <span class="font-mono text-xs p-1 rounded-full ${levelClass} ml-2">${ability.tier.toUpperCase()}</span>
                </h4>
                <p class="text-xs">${ability.desc}</p>
            </div>
        `;
        display.appendChild(item);
    });
}

// --- Drawing Functions ---
function drawField(){
    ctx.fillStyle=COLOR_FIELD; ctx.fillRect(0,0,canvas.width,canvas.height);

    let goalDepth = 15;
    let goalHeight = GOAL_HEIGHT;
    if (playerUpgrades.shortGoal) goalHeight *= 0.7;
    let aiGoalHeight = GOAL_HEIGHT;
    if (playerUpgrades.goalExpansion) aiGoalHeight *= 1.3;
    
    let aiGoalTop=canvas.height/2 - aiGoalHeight/2, aiGoalBottom=canvas.height/2 + aiGoalHeight/2;
    let playerGoalTop=canvas.height/2 - goalHeight/2, playerGoalBottom=canvas.height/2 + goalHeight/2;

    ctx.fillStyle = 'rgba(0, 102, 204, 0.2)'; 
    ctx.fillRect(0, playerGoalTop, goalDepth, playerGoalBottom - playerGoalTop);
    ctx.fillStyle = 'rgba(204, 0, 0, 0.2)'; 
    ctx.fillRect(canvas.width - goalDepth, aiGoalTop, goalDepth, aiGoalBottom - aiGoalTop);

    ctx.strokeStyle="#dcdcdc"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(canvas.width/2,0); ctx.lineTo(canvas.width/2,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(canvas.width/2,canvas.height/2,80,0,Math.PI*2); ctx.stroke();
   
    ctx.strokeStyle=COLOR_BLUE; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(0,playerGoalTop); ctx.lineTo(0,playerGoalBottom); ctx.stroke();
   
    ctx.strokeStyle=COLOR_RED; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(canvas.width,aiGoalTop); ctx.lineTo(canvas.width,aiGoalBottom); ctx.stroke();
   
    boostPads.forEach(pad=>pad.draw());
    if (goaliePad) goaliePad.draw();
}

// --- Collision & Goal Logic ---
function checkCarBallCollision(car, ball){
    let dx=ball.x-car.x, dy=ball.y-car.y;
    let collisionRadius=BALL_RADIUS+(CAR_WIDTH * car.sizeMultiplier * 0.5);
    let dist=Math.hypot(dx,dy);
   
    if(dist<collisionRadius){
        let impulseAngle=Math.atan2(dy,dx), carSpeed=car.speed, baseForce=1.0;
        let force=baseForce+carSpeed*1.5*(car.boosting?car.boostPower:1);
       
        let kickBoost = 1;
        if (!car.ai) {
            kickBoost += (playerUpgrades.kick || 0) * 0.1;
            if (playerUpgrades.doubleKick) kickBoost *= 2;
        }
        force *= kickBoost;
       
        if (!car.ai && playerUpgrades.stickTires) {
            car.velX *= 0.9;
            car.velY *= 0.9;
        }
       
        ball.velX+=Math.cos(impulseAngle)*force; ball.velY+=Math.sin(impulseAngle)*force;
       
        let overlap=collisionRadius-dist;
        if(overlap>0){
            ball.x+=Math.cos(impulseAngle)*overlap;
            ball.y+=Math.sin(impulseAngle)*overlap;
        }
       
        if (!car.ai && playerUpgrades.ballMagnet) {
            ball.effects.magnet = { duration: 0.25 };
        }
       
        if (!car.ai && car.effects.ring && car.effects.ring.stunOnHit) {
            let aiCars = cars.filter(c => c.ai && !c.isFriendlyAI);
            aiCars.forEach(ai => {
                let aiDist = Math.hypot(ai.x - car.x, ai.y - car.y);
                if (aiDist < (CAR_WIDTH * car.sizeMultiplier * 2.5)) {
                    ai.isStunned = true;
                    ai.stunDuration = Math.max(ai.stunDuration, 2.0); 
                }
            });
            delete car.effects.ring.stunOnHit;
        }
    }
}

function checkCarCarCollision(car1, car2) {
    if ((!car1.ai && car1.effects.ghost && car2.ai) || (!car2.ai && car2.effects.ghost && car1.ai)) return;
   
    let radius1 = (CAR_WIDTH * car1.sizeMultiplier / 2) * 0.9;
    let radius2 = (CAR_WIDTH * car2.sizeMultiplier / 2) * 0.9;
    let collisionDistance = radius1 + radius2;

    let dx = car2.x - car1.x;
    let dy = car2.y - car1.y;
    let dist = Math.hypot(dx, dy);
   
    if (dist < collisionDistance) {
        let impulseAngle = Math.atan2(dy, dx);
        let overlap = collisionDistance - dist;
       
        let sepX = Math.cos(impulseAngle) * (overlap / 2 + 0.1);
        let sepY = Math.sin(impulseAngle) * (overlap / 2 + 0.1);
        car1.x -= sepX; car1.y -= sepY;
        car2.x += sepX; car2.y += sepY;
       
        let v1 = car1.velX * Math.cos(impulseAngle) + car1.velY * Math.sin(impulseAngle);
        let v2 = car2.velX * Math.cos(impulseAngle) + car2.velY * Math.sin(impulseAngle);
       
        let mass1 = (car1.isFriendlyAI ? 0.5 : 1.0);
        let mass2 = (car2.isFriendlyAI ? 0.5 : 1.0);

        mass1 *= car1.sizeMultiplier;
        mass2 *= car2.sizeMultiplier;

        let v1Final = (v1 * (mass1 - mass2) + 2 * mass2 * v2) / (mass1 + mass2);
        let v2Final = (v2 * (mass2 - mass1) + 2 * mass1 * v1) / (mass1 + mass2);
       
        let elasticity = 0.85;
        let dv1 = (v1Final - v1) * elasticity;
        let dv2 = (v2Final - v2) * elasticity;
       
        car1.velX += dv1 * Math.cos(impulseAngle); car1.velY += dv1 * Math.sin(impulseAngle);
        car2.velX += dv2 * Math.cos(impulseAngle); car2.velY += dv2 * Math.sin(impulseAngle);
       
        if (!car1.ai && car2.ai && playerUpgrades.slipStream) car1.boost = Math.min(car1.maxBoost, car1.boost + 10);
        if (!car2.ai && car1.ai && playerUpgrades.slipStream) car2.boost = Math.min(car2.maxBoost, car2.boost + 10);
    }
}


function checkGoal(ball) {
    let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
    let aiGoalHeight = GOAL_HEIGHT;
    if (playerUpgrades.goalExpansion) aiGoalHeight *= 1.3;
   
    let aiGoalTop=canvas.height/2 - aiGoalHeight/2, aiGoalBottom=canvas.height/2 + aiGoalHeight/2;
    let playerGoalTop=canvas.height/2 - goalHeight/2, playerGoalBottom=canvas.height/2 + goalHeight/2;
   
    if(ball.y>playerGoalTop && ball.y<playerGoalBottom){
        if(ball.x-ball.radius<=0) return 'right'; 
    }
    if(ball.y>aiGoalTop && ball.y<aiGoalBottom){
        if(playerUpgrades.goalBlock && cars[0].effects.goalBlock) return null;
        if(ball.x+ball.radius>=canvas.width) return 'left'; 
    }
    return null;
}

function handleGoal(scoringTeam, scoredBall) {
    if (scoringTeam === 'left') { 
        let oldLevel = playerLevel;
        scoreLeft += scoredBall.pointType;
        playerLevel += scoredBall.pointType;
       
        if (endConditionType === 'forever' && Math.floor(playerLevel / 5) > Math.floor(oldLevel / 5)) {
            pendingUpgradePick = true;
        }
       
        let oldTenBlock = Math.floor(oldLevel / 10);
        let newTenBlock = Math.floor(playerLevel / 10);
       
        if (endConditionType === 'forever' && newTenBlock > oldTenBlock) {
             if (getNumberOfAICars() < 6) {
                 addEnemyAICar();
             } else {
                 aiDifficulty++;
                 cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => {
                    ai.baseAcceleration += 0.02;
                    ai.maxBoost += 10;
                    ai.updateDifficulty(aiDifficulty);
                 });
             }
        }
       
        cars[0].effects.ring = { duration: 10.0, stunOnHit: true };
        cars[0].effects.goalBlock = { duration: 3.0 };
       
        cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => {
            if (playerUpgrades.aiSlow) ai.effects.slow = { duration: 5.0, factor: 0.5 };
            if (playerUpgrades.timeFreeze) { ai.isStunned = true; ai.stunDuration = Math.max(ai.stunDuration, 2.0); }
            if (playerUpgrades.platinumSuperAI) ai.effects.confused = { duration: 5.0 };
        });
       
        if(playerUpgrades.ballSplit && foreverBalls.length < 5) {
             const newBall = new Ball(scoredBall.x, scoredBall.y, BALL_RADIUS, 1);
             newBall.velX = Math.random() > 0.5 ? 10 : -10;
             newBall.velY = Math.random() > 0.5 ? 10 : -10;
             foreverBalls.push(newBall);
        }
    }
    else if (scoringTeam === 'right') { 
        scoreRight += scoredBall.pointType;
        if (playerUpgrades.freePad) {
            boostPads.push(new BoostPad(canvas.width/2, canvas.height/2, 20));
        }
        if (endConditionType === 'forever' && scoreRight >= scoreLeft + 5) {
             gameState = 'finished';
             drawGameOver('ai_won');
             return;
        }
    }
   
    if(foreverBalls.length === 1 || scoredBall.pointType > 1) {
        cars.forEach(c => c.reset());
    }
   
    if(foreverBalls.length > 1) {
        foreverBalls = foreverBalls.filter(b => b !== scoredBall);
    } else {
        scoredBall.reset();
    }
   
    if (gameState === 'playing') {
        if (checkGameEnd()) {
            gameState = 'finished';
            drawGameOver();
        } else if (pendingUpgradePick) {
            requestUpgradePicker();
            pendingUpgradePick = false;
        }
    }
}

function checkGameEnd() {
    if (endConditionType === 'points' && (scoreLeft >= targetScore || scoreRight >= targetScore)) return true;
    if (endConditionType === 'timed' && gameTimer <= 0) return true;
    return false;
}

// --- GAME LOOP ---
function update(deltaTime) {
    if(gameState==='playing'){
        if (playerUpgrades.boostRain && Math.random() < 0.005) { cars[0].refillBoost(30); }
        if (endConditionType === 'timed') { gameTimer=Math.max(0,gameTimer-deltaTime); }
       
        cars.forEach(car => { car.handleInput(deltaTime); car.move(deltaTime); });
        foreverBalls.forEach(ball => ball.move(deltaTime));
        boostPads.forEach(pad => pad.update(deltaTime));
       
        if (goaliePad) goaliePad.update(deltaTime);

        cars.forEach(car => foreverBalls.forEach(ball => checkCarBallCollision(car, ball)));
        for(let i=0; i<cars.length; i++) for(let j=i+1; j<cars.length; j++) checkCarCarCollision(cars[i], cars[j]);
       
        cars.forEach(car => {
            boostPads.forEach(pad => { 
                if (pad.checkCollision(car)) { 
                    pad.consume(car); 
                }
            });
        });
       
        const scoredBalls = [];
        foreverBalls.forEach(ball => {
            if (goaliePad) goaliePad.checkCollision(ball);
            let scoringTeam = checkGoal(ball);
            if (scoringTeam) scoredBalls.push({ball, scoringTeam});
        });
       
        if (scoredBalls.length > 0) {
            handleGoal(scoredBalls[0].scoringTeam, scoredBalls[0].ball);
        }
       
        updateUI();
    }
}

function gameLoop(currentTime) {
    if (!['playing', 'paused', 'finished', 'upgrading'].includes(gameState)) {
        cancelAnimationFrame(animationFrameId);
        return;
    }
   
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
   
    if (gameState === 'playing') {
        update(deltaTime);
        drawField();
        cars.forEach(car => car.draw());
        foreverBalls.forEach(ball => ball.draw());
    } else if (gameState === 'paused' || gameState === 'finished' || gameState === 'upgrading') {
        drawField();
        cars.forEach(car => car.draw());
        foreverBalls.forEach(ball => ball.draw());
    }
   
    foreverBalls.forEach(b => {
        if (b.ballStuckCountdown > 0) {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            ctx.font = 'bold 40px Inter';
            ctx.fillText(b.ballStuckCountdown, b.x, b.y - 5);

            ctx.font = 'bold 12px Inter';
            ctx.shadowBlur = 5;
            ctx.fillText("Ball Stuck", b.x, b.y + 15);
           
            ctx.restore();
        }
    });
   
    if (stuckBallMessage.duration > 0) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = 'bold 24px Inter';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 5;
        ctx.fillText(stuckBallMessage.text, canvas.width / 2, 50);
        ctx.restore();
        if (gameState === 'playing') {
            stuckBallMessage.duration -= deltaTime;
        }
    }
   
    if (gameState === 'playing' || gameState === 'paused' || gameState === 'finished') {
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

// --- MENU FUNCTIONS ---
function drawMainMenu() {
    gameState = 'menu';
    overlay.classList.add('visible'); 
    document.getElementById('pause-btn').classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
    
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-8 text-yellow-400">2D ROCKET LEAGUE</h1>
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="select-mode-1v1">1v1 Multiplayer (Local)</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="select-mode-2v2">2v2 Multiplayer (Local)</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="select-mode-vs-computer">Vs Computer</div>
               
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="play-online">Play Online</div>
            </div>
        </div>
    `;
   
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
   
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => {
            if (option.getAttribute('data-action')) {
                handleMenuSelection(index);
            }
        });
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
   
    selectedMenuIndex = 0;
    updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}

function drawGameSettingsMenu(mode) {
    gameState = 'menu';
    overlay.classList.add('visible'); 
    document.getElementById('pause-btn').classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');

    let foreverModeOption = '';
    if (mode === 'Vs Computer') {
        foreverModeOption = `
            <h2 class="text-2xl font-bold mb-3 text-white mt-6">Challenge Mode</h2>
            <div class="flex justify-center gap-4 mb-6">
                <div class="p-3 bg-cyan-600 rounded-lg hover:bg-cyan-500 transition duration-150" data-action="start-forever">Start FOREVER MODE</div>
            </div>
        `;
    }

    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-lg pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">${mode} Settings</h1>
            <div id="menu-options">
                <h2 class="text-2xl font-bold mb-3 text-white">Time Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-timed-1">1 Minute</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-timed-2">2 Minutes</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-timed-5">5 Minutes</div>
                </div>
   
                <h2 class="text-2xl font-bold mb-3 text-white">Score Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-points-3">3 Points</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-points-5">5 Points</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-points-10">10 Points</div>
                </div>
   
                ${foreverModeOption}

                <hr class="border-gray-500 my-6">
               
                <div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="main-menu">Back</div>
                </div>
            </div>
        </div>
    `;
   
    window.currentGameModeSelection = mode;
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
   
    menuOptions.forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
   
    selectedMenuIndex = 0;
    updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}


function drawUpgradeMenu() {
    overlay.classList.add('visible'); 
    drawField();
    cars.forEach(car => car.draw());
    foreverBalls.forEach(ball => ball.draw());
   
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-4xl pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-2 text-green-400">UPGRADE AVAILABLE! (Level ${playerLevel})</h1>
            <p class="text-gray-300 mb-6">Select an ability. Rerolls remaining: ${playerUpgrades.rerollPlus ? '‚àû' : (1-upgradeRerollsUsed)}</p>
            <div id="upgrade-options" class="flex flex-wrap justify-center gap-6">
                ${upgradeOptions.map((opt, index) => `
                    <div id="upgrade-${index}" data-index="${index}" class="upgrade-option-card p-4 rounded-xl w-64 text-left shadow-lg border-2 border-transparent bg-gray-600 transition duration-200">
                        <p class="text-xl font-bold mb-1 flex items-center justify-between">
                            <span class="text-2xl mr-2">${opt.icon}</span>
                            <span class="font-mono text-sm font-bold p-1 px-2 rounded-full ability-level-${opt.tier}">${opt.tier.toUpperCase()}</span>
                        </p>
                        <h2 class="text-2xl font-bold mb-2 ${opt.id.includes('reroll') ? 'text-yellow-300' : 'text-white'}">${opt.label}</h2>
                        <p class="text-sm text-gray-300">${opt.desc}</p>
                        ${opt.id.includes('reroll') ? '' : `<p class="mt-2 text-xs text-gray-400">Current count: ${playerUpgrades[opt.id] || 0}</p>`}
                    </div>
                `).join('')}
            </div>
        </div>
    `;
   
    menuOptions = document.getElementById('upgrade-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleUpgradeSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('upgrade-options', index, 'upgrade'));
    });
   
    selectedUpgradeIndex = 0;
    updateMenuSelectionUI('upgrade-options', selectedUpgradeIndex, 'upgrade');
}

function drawGameOver(reason = null) {
    pauseBtn.classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
    overlay.classList.add('visible'); 
   
    let message = 'DRAW!';
    if (reason === 'ai_won') {
        message = 'YOU LOSE!';
    } else if (scoreLeft > scoreRight) {
        message = 'BLUE TEAM WINS!';
    } else if (scoreRight > scoreLeft) {
        message = 'RED TEAM WINS!';
    }
   
    const finalLevel = playerLevel;
    const finalScore = scoreLeft;
   
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-4 text-pink-400">GAME OVER</h1>
            <p class="text-3xl font-bold mb-6 ${reason === 'ai_won' ? 'text-red-400' : 'text-yellow-300'}">${message}</p>
            ${endConditionType === 'forever' ?
                `<p class="text-xl text-gray-300 mb-6">Final Level: <span class="text-yellow-400">${finalLevel}</span> | Goals Scored: <span class="text-blue-400">${finalScore}</span></p>`
                :
                `<p class="text-xl text-gray-300 mb-6">Final Score: <span class="text-blue-400">${scoreLeft}</span> - <span class="text-red-400">${scoreRight}</span></p>`
            }
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="restart">Play Again</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="main-menu">Back to Main Menu</div>
            </div>
        </div>
    `;
   
    menuOptions = document.getElementById('menu-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
    });
   
    selectedMenuIndex = 0;
    updateMenuSelectionUI('menu-options', selectedMenuIndex);
}

function updateMenuSelectionUI(containerId, selectedIndex, type = 'menu') {
    if (type === 'menu') selectedMenuIndex = selectedIndex;
    else selectedUpgradeIndex = selectedIndex;
   
    let optionsToUpdate;
    if (type === 'upgrade' && containerId) {
        const container = document.getElementById(containerId);
        if(container) optionsToUpdate = container.children;
        else optionsToUpdate = menuOptions;
    } else {
        optionsToUpdate = menuOptions;
    }
   
    Array.from(optionsToUpdate).forEach((child, index) => {
        child.classList.remove('menu-selected');
        if (index === selectedIndex) { child.classList.add('menu-selected'); }
    });
}

function handleMenuSelection(index) {
    if (!menuOptions[index]) return;
    const selection = menuOptions[index].getAttribute('data-action');
   
    const mode = window.currentGameModeSelection;
   
    if (selection === 'select-mode-1v1') {
        drawGameSettingsMenu('1v1 Multiplayer');
    }
    else if (selection === 'select-mode-2v2') {
        drawGameSettingsMenu('2v2 Multiplayer');
    }
    else if (selection === 'select-mode-vs-computer') {
        drawGameSettingsMenu('Vs Computer');
    }
    else if (selection === 'start-forever') {
        startGame('Vs Computer', 'forever');
    }
    else if (selection === 'start-timed-1') { timeLimitSeconds = 60; startGame(mode, 'timed'); }
    else if (selection === 'start-timed-2') { timeLimitSeconds = 120; startGame(mode, 'timed'); }
    else if (selection === 'start-timed-5') { timeLimitSeconds = 300; startGame(mode, 'timed'); }
    else if (selection === 'start-points-3') { targetScore = 3; startGame(mode, 'points'); }
    else if (selection === 'start-points-5') { targetScore = 5; startGame(mode, 'points'); }
    else if (selection === 'start-points-10') { targetScore = 10; startGame(mode, 'points'); }
   
    else if (selection === 'play-online') {
        window.location.href = "https://ccpspy.github.io/onlinecargame";
    }
   
    else if (selection === 'restart') {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        startGame(gameMode, endConditionType);
    }
   
    else if (selection === 'main-menu') {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        gameState = 'menu';
        uiPanel.classList.add('hidden'); 
        foreverStatusPanel.classList.add('hidden');
        document.getElementById('fullscreen-btn').classList.add('hidden');
        drawMainMenu();
    }
    else if (selection === 'resume') {
        togglePause();
    }
}

function handleUpgradeSelection(index) {
    if (!upgradeOptions[index]) return;
    const upgrade = upgradeOptions[index];
   
    if (upgrade.id === 'reroll' || upgrade.id === 'rerollPlus') {
        if (upgrade.id === 'reroll') {
            upgradeRerollsUsed++;
        }
        rerollUpgradeOptions();
    } else {
        applyUpgrade(upgrade);
        exitUpgradePicker();
    }
}

function startGame(mode, endType='timed') {
    gameMode = mode; endConditionType = endType; scoreLeft = 0; scoreRight = 0;
    aiDifficulty = 1;
    let initialAICount = 1;
   
    if(endType === 'forever') {
        timeLimitSeconds = 99999;
        targetScore = 999;
        initialAICount = 1;
        playerLevel = 0;
        playerUpgrades = {};
        playerAbilities = [];
        pendingUpgradePick = false;
    }
    else {
        playerUpgrades = {}; 
        playerAbilities = [];
        initialAICount = (mode === '1v1 Multiplayer') ? 0 : (mode === '2v2 Multiplayer') ? 0 : 1;
    }
   
    gameTimer = timeLimitSeconds;
    setupGameObjects(mode, initialAICount);
    updateUI(); 
   
    if (endType === 'forever') {
        gameState = 'upgrading'; 
        overlay.classList.remove('visible'); 
        requestUpgradePicker(); 
    } else {
        gameState = 'playing';
        overlay.classList.remove('visible');
        pauseBtn.classList.remove('hidden');
        document.getElementById('fullscreen-btn').classList.remove('hidden');
        lastTime = performance.now();
        if (animationFrameId) cancelAnimationFrame(animationFrameId); 
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

function togglePause() {
    if (gameState === 'playing') {
        gameState = 'paused';
        pauseBtn.innerHTML = '<span class="mr-2">‚ñ∂Ô∏è</span> Resume (P)';
        overlay.classList.add('visible'); 
       
        let foreverRules = '';
        if (endConditionType === 'forever') {
            foreverRules = `
                <div class="text-left bg-gray-800 p-4 rounded-lg mt-6 border border-gray-600 pointer-events-auto">
                    <h3 class="font-bold text-lg text-cyan-400 mb-2">Forever Mode Rules:</h3>
                    <ul class="list-disc list-inside text-sm text-gray-300 space-y-1">
                        <li>Get an upgrade every 5 levels (goals).</li>
                        <li>A new AI opponent appears every 10 levels (max 6).</li>
                        <li>After 6 AI, they get faster and smarter.</li>
                        <li>You lose if the AI is 5 points ahead!</li>
                    </ul>
                </div>
            `;
        }

        overlay.innerHTML = `
            <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
                <h1 class="text-5xl font-extrabold mb-8 text-red-400">GAME PAUSED</h1>
                <div id="menu-options" class="space-y-4 text-xl">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="resume">Resume Game</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="restart">Restart Game</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="main-menu">Back to Main Menu</div>
                </div>
                ${foreverRules}
            </div>
        `;
        menuOptions = document.getElementById('menu-options').children;
        Array.from(menuOptions).forEach((option, index) => {
            option.addEventListener('click', () => handleMenuSelection(index));
            option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
        });
        selectedMenuIndex = 0;
        updateMenuSelectionUI('menu-options', selectedMenuIndex);
       
    } else if (gameState === 'paused') {
        gameState = 'playing';
        overlay.classList.remove('visible');
        pauseBtn.innerHTML = '<span class="mr-2">‚è∏Ô∏è</span> Pause (P)';
        document.getElementById('fullscreen-btn').classList.remove('hidden');
       
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

// --- NEW: Fullscreen Functions ---
function toggleFullScreen() {
    const gameContainer = document.getElementById('game-container');
    const body = document.body;

    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        if (gameContainer.requestFullscreen) {
            gameContainer.requestFullscreen();
        } else if (gameContainer.webkitRequestFullscreen) { 
            gameContainer.webkitRequestFullscreen();
        } else if (gameContainer.msRequestFullscreen) { 
            gameContainer.msRequestFullscreen();
        }
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { 
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { 
            document.msExitFullscreen();
        }
    }
}

function updateFullscreenState() {
    const gameContainer = document.getElementById('game-container');
    const body = document.body;
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);

    if (isFullscreen) {
        gameContainer.classList.add('fullscreen-active');
        body.classList.add('fullscreen-active');
        fullscreenBtn.innerHTML = '<span class="mr-2">üì∫</span> Exit Fullscreen';
    } else {
        gameContainer.classList.remove('fullscreen-active');
        body.classList.remove('fullscreen-active');
        fullscreenBtn.innerHTML = '<span class="mr-2">üì∫</span> Fullscreen';
    }
}

// Listen for fullscreen changes
document.addEventListener('fullscreenchange', updateFullscreenState);
document.addEventListener('webkitfullscreenchange', updateFullscreenState);
fullscreenBtn.addEventListener('click', toggleFullScreen);


// --- Keyboard Listeners ---
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
   
    if (gameState === 'menu' || gameState === 'paused' || gameState === 'finished') {
        let containerId = 'menu-options';
        if (e.code === 'ArrowDown') { selectedMenuIndex = (selectedMenuIndex + 1) % menuOptions.length; }
        else if (e.code === 'ArrowUp') { selectedMenuIndex = (selectedMenuIndex - 1 + menuOptions.length) % menuOptions.length; }
        else if (e.code === 'Enter') {
            if (menuOptions[selectedMenuIndex]) {
                menuOptions[selectedMenuIndex].click();
            }
        }
        else return;
       
        updateMenuSelectionUI(containerId, selectedMenuIndex);
        e.preventDefault();
       
    } else if (gameState === 'upgrading') {
        let containerId = 'upgrade-options';
        if (e.code === 'ArrowRight') { selectedUpgradeIndex = (selectedUpgradeIndex + 1) % menuOptions.length; }
        else if (e.code === 'ArrowLeft') { selectedUpgradeIndex = (selectedUpgradeIndex - 1 + menuOptions.length) % menuOptions.length; }
        else if (e.code === 'Enter') {
            if (menuOptions[selectedUpgradeIndex]) {
                menuOptions[selectedUpgradeIndex].click();
            }
        }
        else return;
       
        updateMenuSelectionUI(containerId, selectedUpgradeIndex, 'upgrade');
        e.preventDefault();
       
    } else if (gameState === 'playing' && e.code === 'KeyP') {
        togglePause();
    }
});
window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

// --- Initial load ---
window.onload = function () {
    canvas.width = DEFAULT_WIDTH;
    canvas.height = DEFAULT_HEIGHT;
    drawMainMenu();
}
</script>
</body>
</html>
