<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Rocket League - Enhanced Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            overflow-y: auto;
        }
        body.fullscreen-active { padding: 0; overflow: hidden; }
        #game-container {
            width: 100%; max-width: 1000px; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 1rem; overflow: hidden;
            display: flex; flex-direction: column; align-items: center;
            background-color: #1f2937; transition: all 0.3s ease;
        }
        #game-container.fullscreen-active {
            width: 100vw; height: 100vh; max-width: none;
            border-radius: 0; padding: 1rem; box-sizing: border-box;
            justify-content: space-between;
        }
        #game-viewport {
            position: relative; width: 100%;
            display: flex; justify-content: center; align-items: center;
        }
        #game-container.fullscreen-active #game-viewport {
            flex-grow: 1; height: 0; min-height: 0; margin: 10px 0;
        }
        #canvas-wrapper { position: relative; width: 1000px; height: 600px; }
        #game-container.fullscreen-active #canvas-wrapper {
            width: auto; height: auto; max-width: 100%; max-height: 100%;
            aspect-ratio: 1000 / 600;
        }
        canvas { background-color: #2b2f3d; display: block; border-radius: 0.75rem; width: 100%; height: 100%; }
        #overlay {
            position: absolute; inset: 0; border-radius: 0.75rem;
            display: flex; align-items: center; justify-content: center;
            background-color: rgba(17, 24, 39, 0.9); opacity: 0;
            pointer-events: none; transition: opacity 0.3s; z-index: 50;
        }
        #overlay.visible { opacity: 1; pointer-events: auto; }
        #ui-panel, #forever-status-panel { flex-shrink: 0; width: 100%; max-width: 1000px; }
        
        .menu-selected {
            border: 3px solid #fcd34d;
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.6);
            padding: 0.5rem 1rem; border-radius: 10px;
            color: #fcd34d; transform: translateY(-2px);
        }
        #menu-options > div, #upgrade-options > div { cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .upgrade-icon-container { position: relative; cursor: default; }
        .upgrade-tooltip {
            visibility: hidden; background-color: #1f2937; color: white;
            text-align: left; border-radius: 6px; padding: 8px 12px;
            position: absolute; z-index: 60; bottom: 125%; left: 50%;
            transform: translateX(-50%); opacity: 0; transition: opacity 0.3s;
            pointer-events: none; width: 220px; white-space: normal; border: 1px solid #4b5563;
        }
        .upgrade-icon-container:hover .upgrade-tooltip { visibility: visible; opacity: 1; }
        .ability-level-bronze { background: #cd7f32; color: #ffffff; }
        .ability-level-silver { background: #9ca3af; color: #1f2937; }
        .ability-level-gold { background: linear-gradient(90deg,#ffd700,#fae360); color: #625002; }
        .ability-level-platinum { background: linear-gradient(90deg,#e5e4e2,#a5f3fc); color: #164e63; border: 2px solid #06b6d4; }
        .upgrade-option-card { transition: transform 0.2s, box-shadow 0.2s; cursor: pointer; }
    </style>
</head>
<body class="bg-gray-900 text-white">

<div id="game-container" class="p-4 sm:p-6 lg:p-8">
    <div id="top-bar" class="w-full mb-2 flex justify-end space-x-2 shrink-0 max-w-[1000px]">
        <button id="fullscreen-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
            <span class="mr-2">üì∫</span> Fullscreen
        </button>
        <button id="pause-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
            <span class="mr-2">‚è∏Ô∏è</span> Pause (P)
        </button>
    </div>

    <div id="game-viewport">
        <div id="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="overlay"></div>
        </div>
    </div>

    <div id="ui-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <div class="flex justify-between items-center text-xl font-bold">
            <div id="score-left" class="text-blue-400">BLUE: 0</div>
            <div id="center-info" class="text-center">
                <div id="timer" class="text-white text-3xl font-mono">02:00</div>
                <div id="mode-info" class="text-sm text-gray-300 mt-1">TIME REMAINING</div>
            </div>
            <div id="score-right" class="text-red-400">RED: 0</div>
        </div>
    </div>

    <div id="forever-status-panel" class="mt-2 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <div class="flex flex-wrap justify-between items-start">
            <div class="w-full md:w-1/3 mb-4 md:mb-0">
                <h4 class="font-semibold text-gray-300">Challenge Status</h4>
                <p id="ai-status" class="text-2xl font-bold text-red-400">LV 1</p>
                <p class="text-sm text-gray-400 mt-1">Player Level: <span id="player-level-display" class="text-yellow-400 text-xl">0</span></p>
                <div id="late-game-warning" class="hidden text-xs text-orange-400 mt-2 font-bold animate-pulse">AI OVERDRIVE ACTIVE</div>
            </div>
            <div class="w-full md:w-2/3">
                <h4 class="font-semibold text-gray-300 mb-2">Upgrades</h4>
                <div id="player-upgrades-display" class="flex flex-wrap gap-2"></div>
            </div>
        </div>
    </div>
</div>

<script>
// --- Constants ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const DEFAULT_WIDTH = 1000, DEFAULT_HEIGHT = 600; 
const CAR_WIDTH = 50, CAR_HEIGHT = 25; 
const BALL_RADIUS = 17; 
const GOAL_HEIGHT = 170; 
const GOAL_LINE_WIDTH = 7; 
const PHYSICS_TICK_RATE = 60; 
const MAX_CENTER_OFFSET_FACTOR = 1 / 6; // Added missing constant
const COLOR_BLUE = '#0066cc';
const COLOR_RED = '#cc0000';
const COLOR_CYAN = '#00fff4';
const COLOR_FIELD = '#2b2f3d';

// --- Game State ---
let gameState = 'menu';
let gameMode = '1v1 Multiplayer';
let endConditionType = 'timed';
let timeLimitSeconds = 120;
let targetScore = 5;
let gameTimer = 0;
let scoreLeft = 0, scoreRight = 0;
let cars = [];
let boostPads = [];
let goaliePad = null;
let ball = null;
let foreverBalls = [];
let keys = {};
let lastTime = 0;
let animationFrameId;
let aiDifficulty = 1;
let playerUpgrades = {}; 
let playerAbilities = []; 
let playerLevel = 0;
let upgradeRerollsUsed = 0, extraUpgradePicks = 0, upgradeOptions = [];
let pendingUpgradePick = false;
let stuckBallMessage = { text: '', duration: 0 };
let systemMessage = { text: '', duration: 0, color: 'white' };

// --- Global declarations ---
let selectedMenuIndex = 0;
let selectedUpgradeIndex = 0;
let menuOptions = []; 
const fullscreenBtn = document.getElementById('fullscreen-btn');

// --- NEW ABILITY POOLS ---
// Progression: Bronze (0+), Silver (35+), Gold (50+), Platinum (100+)

const BRONZE_UPGRADES = [
    {id:'accel',label:'Engine V1',icon:'‚ö°',desc:'Acceleration +10%.',tier:'bronze'},
    {id:'turn',label:'Power Steering',icon:'üåÄ',desc:'Rotation speed +15%.',tier:'bronze'},
    {id:'maxBoost',label:'Fuel Tank',icon:'‚õΩ',desc:'Boost capacity +20.',tier:'bronze'},
    {id:'boostRegen',label:'Eco Mode',icon:'‚ôªÔ∏è',desc:'Passive boost regen (small).',tier:'bronze'},
    {id:'speed',label:'Top Gear',icon:'üöÄ',desc:'Top speed +5%.',tier:'bronze'},
    {id:'brake',label:'ABS Brakes',icon:'üõë',desc:'Braking force increased significantly.',tier:'bronze'},
    {id:'kick',label:'Iron Bumper',icon:'üëä',desc:'Hit force +15%.',tier:'bronze'},
    {id:'grip',label:'Sport Tires',icon:'üç©',desc:'Better grip, less drift.',tier:'bronze'},
    {id:'heavy',label:'Heavyweight',icon:'üêò',desc:'You are heavier (harder to push).',tier:'bronze'},
    {id:'sniper',label:'Sniper Hit',icon:'üéØ',desc:'Ball travels faster when you hit it.',tier:'bronze'},
    {id:'extraBoostPad',label:'Field Supply',icon:'‚ú®',desc:'Adds a permanent boost pad.',tier:'bronze', permanent:true},
    {id:'slipStream',label:'Drafter',icon:'üí®',desc:'Gain boost when hitting opponents.',tier:'bronze'},
    {id:'bigCar',label:'Tank Body',icon:'üõ°Ô∏è',desc:'Larger size, better blocking.',tier:'bronze'},
];

const SILVER_UPGRADES = [
    {id:'shrinkRay',label:'Shrink Ray',icon:'üî¨',desc:'All Enemy AIs become 25% smaller.',tier:'silver', permanent:true},
    {id:'miniRobot',label:'Attacker Bot',icon:'ü§ñ',desc:'Spawns a friendly AI Attacker.',tier:'silver', permanent:true},
    {id:'goalExpansion',label:'Goal Hack',icon:'ü•Ö',desc:'Opponent goal is 30% wider.',tier:'silver', permanent:true},
    {id:'doubleKick',label:'Power Hit',icon:'ü•ä',desc:'Doubles ball impact force.',tier:'silver'},
    {id:'magnet',label:'Magnet V1',icon:'üß≤',desc:'Weak magnetic pull on ball.',tier:'silver'},
    {id:'wallRider',label:'Wall Rider',icon:'üßó',desc:'Speed boost when near walls.',tier:'silver'},
    {id:'bumperResist',label:'Steady',icon:'‚öì',desc:'You take 50% less knockback.',tier:'silver'},
    {id:'boostRain',label:'Boost Rain',icon:'üåßÔ∏è',desc:'Chance to get full boost randomly.',tier:'silver'},
];

const GOLD_UPGRADES = [
    {id:'smolRobot',label:'Defender Bot',icon:'üõ°Ô∏è',desc:'Spawns a friendly AI Defender.',tier:'gold', permanent:true},
    {id:'autoGoalie',label:'Robo-Goalie',icon:'ü•Ö',desc:'Auto-moving goalie pad blocks your net.',tier:'gold', permanent:true},
    {id:'freeze',label:'Cryo Blast',icon:'‚ùÑÔ∏è',desc:'Freeze enemies for 2s when you score.',tier:'gold'},
    {id:'gravity',label:'Gravity Well',icon:'üåå',desc:'Slowly pulls ball towards you constantly.',tier:'gold'},
    {id:'repulsor',label:'Repulsor',icon:'üëã',desc:'Push nearby enemies away automatically.',tier:'gold'},
    {id:'goalBlock',label:'Forcefield',icon:'üöß',desc:'Blocks AI shots for 3s after you score.',tier:'gold'},
    {id:'rerollPlus',label:'Master Key',icon:'üîë',desc:'Unlimited Rerolls.',tier:'gold'},
    {id:'extraUpgrade',label:'Double Down',icon:'‚úåÔ∏è',desc:'Get an extra pick next round.',tier:'gold'},
];

const PLATINUM_UPGRADES = [
    {id:'platinumDoubleAll',label:'Multiball',icon:'üé±',desc:'Spawns extra balls permanently.',tier:'platinum', permanent:true},
    {id:'platinumSuperAI',label:'Mind Control',icon:'üß†',desc:'Confuses AI directions periodically.',tier:'platinum'},
    {id:'platinumStickyNet',label:'Glue Net',icon:'üï∏Ô∏è',desc:'Opponent goal catches ball (stops bounces).',tier:'platinum'},
    {id:'timeWarp',label:'Time Warp',icon:'‚è≥',desc:'Slows down everything except you.',tier:'platinum'},
    {id:'blackHole',label:'Singularity',icon:'‚ö´',desc:'Opponent goal sucks the ball in.',tier:'platinum'},
];

// --- Logic Functions ---

function getAbilityTierByLevel(level) {
    // Strict progression as requested
    if (level < 35) return 'bronze';
    if (level < 50) return Math.random() < 0.8 ? 'silver' : 'bronze';
    if (level < 100) {
        const r = Math.random();
        if (r < 0.3) return 'gold';
        if (r < 0.8) return 'silver';
        return 'bronze';
    }
    // Level 100+
    const r = Math.random();
    if (r < 0.2) return 'platinum'; // 20% chance for Plat
    if (r < 0.5) return 'gold';
    return 'silver';
}

function getPoolForTier(tier) {
    if (tier === 'platinum') return PLATINUM_UPGRADES;
    if (tier === 'gold') return GOLD_UPGRADES;
    if (tier === 'silver') return SILVER_UPGRADES;
    return BRONZE_UPGRADES;
}

function randomAbilities(amt, disallowIds=[]) {
    let chosen = [];
    const playerUpgradeIds = Object.keys(playerUpgrades);
    
    for (let i = 0; i < amt; i++) {
        let tier = getAbilityTierByLevel(playerLevel);
        let pool = getPoolForTier(tier).filter(u => !disallowIds.includes(u.id));
        // Filter out permanents already owned
        pool = pool.filter(u => !u.permanent || !playerUpgradeIds.includes(u.id));
       
        // Fallbacks if pool empty
        if (pool.length === 0 && tier === 'platinum') pool = getPoolForTier('gold');
        if (pool.length === 0 && tier === 'gold') pool = getPoolForTier('silver');
        if (pool.length === 0) pool = getPoolForTier('bronze');
        
        // Ultimate fallback
        if (pool.length === 0) pool = [BRONZE_UPGRADES[0]];
       
        const pick = pool[Math.floor(Math.random() * pool.length)];
        if (pick) {
            chosen.push(pick);
            disallowIds.push(pick.id);
        }
    }
    return chosen;
}

function requestUpgradePicker() {
    gameState = 'upgrading';
    upgradeRerollsUsed = 0;
    rerollUpgradeOptions(); 
    document.getElementById('pause-btn').classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
}

function rerollUpgradeOptions() {
    let numPicks = 3 + extraUpgradePicks;
    const excluded = upgradeOptions.map(u => u.id).filter(id => id !== 'reroll' && id !== 'rerollPlus');
    upgradeOptions = randomAbilities(numPicks, excluded);
   
    if (upgradeRerollsUsed < 1 && !playerUpgrades.rerollPlus) {
        if (!upgradeOptions.some(o => o.id === 'reroll')) {
            upgradeOptions.push({id:'reroll', label:'REROLL', icon:'üîÑ', desc:`Reroll options (${1-upgradeRerollsUsed} remaining).`, tier:'bronze'});
        }
    } else if (playerUpgrades.rerollPlus) {
         if (!upgradeOptions.some(o => o.id === 'rerollPlus')) {
             upgradeOptions.push({id:'rerollPlus', label:'FREE REROLL', icon:'üîÑ', desc:`Unlimited rerolls.`, tier:'gold'});
         }
    }
    selectedUpgradeIndex = 0;
    drawUpgradeMenu();
}

function applyUpgrade(ability) {
    if (ability.id === 'extraUpgrade') {
        extraUpgradePicks++;
    } else {
        playerUpgrades[ability.id] = (playerUpgrades[ability.id] || 0) + 1;
        if (playerAbilities.findIndex(a => a.id === ability.id) === -1) {
            playerAbilities.push(ability);
        }
    }
   
    // Apply instant effects
    cars.filter(c => !c.ai).forEach(c => c.applyPlayerUpgrades(playerUpgrades));
   
    // Handle Spawns
    if (ability.id === 'miniRobot' && !cars.some(c => c.playerId === 1001)) addFriendlyAICar(1001, 'attacker', 1.5);
    if (ability.id === 'smolRobot' && !cars.some(c => c.playerId === 1002)) addFriendlyAICar(1002, 'defender', 1.0);
    if (ability.id === 'autoGoalie' && !goaliePad) { goaliePad = new GoaliePad(); }
    
    // Handle Shrink Ray (Updates enemies)
    if (ability.id === 'shrinkRay') {
        cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => ai.updateDifficulty(aiDifficulty));
    }

    if (ability.id === 'platinumDoubleAll' && foreverBalls.length === 1) {
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.forEach(b => b.reset());
    }
   
    updateUpgradesDisplay();
}

function exitUpgradePicker() {
    gameState = 'playing';
    extraUpgradePicks = 0; 
    overlay.classList.remove('visible');
    overlay.innerHTML = '';
    pauseBtn.classList.remove('hidden');
    document.getElementById('fullscreen-btn').classList.remove('hidden');
    lastTime = performance.now();
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Classes --
class Car {
    constructor(x, y, color, controls, team_side, player_id, initial_angle, ai=false, difficulty=1, role="attacker") {
        this.x=x; this.y=y; this.color=color; this.team_side=team_side; this.controls=controls;
        this.playerId=player_id; this.angle=initial_angle; this.velX=0; this.velY=0; this.speed=0;
       
        this.baseAcceleration=0.3; this.baseMaxSpeed=5.0;
        this.baseRotationSpeed=4.5; this.baseSideFrictionFactor=0.05;
        this.boostPower=1.8; this.boostUsage=1.2; this.maxBoost=100; this.boost=this.maxBoost; this.boosting=false;
       
        this.throttleDirection=0;
        this.ai=ai; this.difficulty=difficulty; this.role = role;
        this.upgrades={}; this.abilities=[]; this.effects={};
        this.isStunned=false; this.stunDuration=0;
       
        this.isFriendlyAI = team_side === 'left' && ai;
        this.baseColor = color;
        this.boostTimer = 0; 
        this.sizeMultiplier = 1.0;
        this.massMultiplier = 1.0;
        
        this.canBoost = false; // Unlocked late game for AI
        this.chasingCorner = false; // Logic flag

        this.updateDifficulty(difficulty);
        this.resetPos={x,y,angle:initial_angle};
    }
   
    updateDifficulty(difficulty) {
        this.difficulty = difficulty;
        if (this.ai) {
            this.acceleration = this.baseAcceleration + 0.05 * (difficulty-1);
            this.maxBoost = 100 + 10 * (difficulty-1);
            this.rotationSpeed = this.baseRotationSpeed;
            this.sideFrictionFactor = this.baseSideFrictionFactor;
            
            // Late game scaling
            if (difficulty > 20) this.baseMaxSpeed = 5.5;
            
            // Apply Shrink Ray Debuff
            this.sizeMultiplier = Math.max(0.5, 1.0 - (playerUpgrades.shrinkRay ? 0.25 : 0));
            
        } else {
            this.applyPlayerUpgrades(playerUpgrades);
        }
    }
   
    applyPlayerUpgrades(upgrades) {
        if (this.ai) return; 
        let count = id => upgrades[id]||0;
       
        this.acceleration = this.baseAcceleration * (1 + count('accel') * 0.1);
        this.rotationSpeed = this.baseRotationSpeed * (1 + count('turn') * 0.15);
        this.maxBoost = 100 + count('maxBoost') * 20;
        this.baseMaxSpeed = 5.0 * (1 + count('speed') * 0.05);
        let frictionFactor = 1 - count('grip') * 0.1;
        this.sideFrictionFactor = this.baseSideFrictionFactor * Math.max(0.1, frictionFactor);
       
        this.sizeMultiplier = 1.0; 
        if (count('bigCar') > 0) this.sizeMultiplier *= 1.25; 
        
        this.massMultiplier = 1.0 + (count('heavy') * 0.3);
    }
   
    handleInput(deltaTime) { 
        if (this.ai) { this.handleAI(deltaTime); return; }
        if (this.isStunned) return;
       
        this.throttleDirection=0; let accelerationForce = 0;
       
        if (keys[this.controls['left']]) this.angle=(this.angle+this.rotationSpeed)%360;
        if (keys[this.controls['right']]) this.angle=(this.angle-this.rotationSpeed)%360;
       
        if (keys[this.controls['up']]) {accelerationForce=this.acceleration;this.throttleDirection=1;}
        if (keys[this.controls['down']]) {
            if (playerUpgrades.brake) { accelerationForce=-this.acceleration*2.5; }
            else { accelerationForce = -this.acceleration * 0.7;}
            this.throttleDirection=-1;
        }
       
        if (accelerationForce!==0) {
            let rad=Math.PI*this.angle/180;
            this.velX+=Math.cos(rad)*accelerationForce; this.velY-=Math.sin(rad)*accelerationForce;
        }
       
        let boostActive = keys[this.controls['boost']];
        if (gameMode === 'Vs Computer' && this.playerId === 1 && (keys['ShiftLeft'] || keys['ShiftRight'])) boostActive = true;
        this.boosting = boostActive && this.boost > 0;
       
        if (this.boosting) {
             this.boost -= this.boostUsage * deltaTime * PHYSICS_TICK_RATE;
        } else if (playerUpgrades.boostRegen) {
             this.boost = Math.min(this.maxBoost, this.boost + (0.1 * deltaTime * PHYSICS_TICK_RATE));
        }
    }

    handleAI(deltaTime) {
        if (!ball || this.isStunned) return;
       
        // Repulsor Logic
        if (!this.isFriendlyAI) {
            let p1 = cars[0];
            if (playerUpgrades.repulsor) {
                let d = Math.hypot(p1.x - this.x, p1.y - this.y);
                if (d < 150) {
                    let angle = Math.atan2(this.y - p1.y, this.x - p1.x);
                    this.velX += Math.cos(angle) * 1.0;
                    this.velY += Math.sin(angle) * 1.0;
                }
            }
        }

        // Avoidance (Skip if chasing corner or friendly)
        cars.forEach(otherCar => {
            if (otherCar === this || (!otherCar.ai && !this.isFriendlyAI) || otherCar.isFriendlyAI) return;
            let dxAI = this.x - otherCar.x;
            let dyAI = this.y - otherCar.y;
            let distAI = Math.hypot(dxAI, dyAI);
            let avoidRadius = (CAR_WIDTH * this.sizeMultiplier) * 1.5;
            if (distAI < avoidRadius && distAI > 0) {
                let separationForce = 0.3 * (avoidRadius - distAI) / avoidRadius;
                this.velX += (dxAI / distAI) * separationForce;
                this.velY += (dyAI / distAI) * separationForce;
            }
        });
       
        let targetBall = foreverBalls[0];
        // Simple closest ball logic
        let minBallDist = Infinity;
        foreverBalls.forEach(b => {
            let dist = Math.hypot(b.x - this.x, b.y - this.y);
            if (dist < minBallDist) { minBallDist = dist; targetBall = b; }
        });
       
        let targetX, targetY;
        let numAIs = getNumberOfAICars();

        // --- SQUAD LOGIC OVERRIDE ---
        // If this car was designated to chase a corner ball, do it direct
        if (this.chasingCorner) {
             targetX = targetBall.x;
             targetY = targetBall.y;
        } 
        else if (this.role === 'defender') {
            // Defender Logic
            // Friendly AI (Left Team) defends x=100 approx
            // Enemy AI (Right Team) defends x=Width-100 approx
            let defenseLineX = this.team_side === 'left' ? BALL_RADIUS * 4 : canvas.width - BALL_RADIUS * 4;
            
            targetX = defenseLineX;
            // Track ball Y but stay in goal box bounds
            targetY = Math.max(canvas.height/2 - GOAL_HEIGHT/2, Math.min(targetBall.y, canvas.height/2 + GOAL_HEIGHT/2));
            
            // If ball is dangerously close to goal, attack it
            let distToGoal = Math.abs(targetBall.x - defenseLineX);
            if (distToGoal < 200) {
                targetX = targetBall.x;
                targetY = targetBall.y;
            }
        } 
        else if (this.role === 'attacker') {
            targetX = targetBall.x;
            targetY = targetBall.y;
            
            // If avoiding corner, stay central
            if (this.avoidingCorner) {
                targetX = canvas.width / 2;
                targetY = canvas.height / 2 + (this.playerId % 2 === 0 ? 50 : -50);
            }
        }
        else {
            // Default Mid
            targetX = targetBall.x;
            targetY = targetBall.y;
        }
       
        const dx=targetX-this.x,dy=targetY-this.y;
        const targetAngleRad=Math.atan2(-dy,dx); let targetAngle=(targetAngleRad*180/Math.PI+360)%360;
        let angleDiff = targetAngle-this.angle; if(angleDiff>180)angleDiff-=360;if(angleDiff<-180)angleDiff+=360;
       
        if(this.effects.confused) {
            this.angle = (this.angle + (Math.random() < 0.5 ? 10 : -10)) % 360;
            this.throttleDirection = 1;
        } else {
            if(angleDiff>this.rotationSpeed){this.angle=(this.angle+this.rotationSpeed)%360;}
            else if(angleDiff<-this.rotationSpeed){this.angle=(this.angle-this.rotationSpeed)%360;}
            else{this.angle=targetAngle;}
           
            this.throttleDirection=0;
            if(Math.abs(angleDiff)<40) {
                let rad=Math.PI*this.angle/180;
                this.velX+=Math.cos(rad)*this.acceleration;
                this.velY-=Math.sin(rad)*this.acceleration;
                this.throttleDirection=1;
            }
        }
       
        // AI Boosting Logic (Unlocked Late Game)
        if (this.canBoost && this.boost > 0 && this.throttleDirection === 1 && Math.abs(angleDiff) < 10) {
            let distToTarget = Math.hypot(dx, dy);
            if (distToTarget > 200) {
                this.boosting = true;
                this.boost -= this.boostUsage * deltaTime * PHYSICS_TICK_RATE;
            } else {
                this.boosting = false;
            }
        } else {
            this.boosting = false;
            // AI Regen
            this.boost = Math.min(this.maxBoost, this.boost + (0.05 * deltaTime * PHYSICS_TICK_RATE));
        }
    }
   
    move(deltaTime) {
        if(this.isStunned){
            this.stunDuration -= deltaTime;
            if(this.stunDuration <= 0) this.isStunned=false;
            return;
        }
        
        // Effect Timers
        ["slow","confused","forceField","invincible","goalBlock","ring","ghost"].forEach(eff=>{
            if(this.effects[eff]) {
                this.effects[eff].duration -= deltaTime;
                if(this.effects[eff].duration <=0) delete this.effects[eff];
            }
        });
       
        let rad=Math.PI*this.angle/180;
        let fVel=this.velX*Math.cos(rad)-this.velY*Math.sin(rad);
        let sVel=this.velX*Math.sin(rad)+this.velY*Math.cos(rad);
        sVel*=(1-this.sideFrictionFactor); fVel*=0.96;
       
        if(this.boosting && this.boost>0) {
            let boostForce=this.acceleration*this.boostPower*1.5;
            fVel+=boostForce*this.throttleDirection;
        }
       
        this.velX= fVel*Math.cos(rad)+sVel*Math.sin(rad);
        this.velY= -fVel*Math.sin(rad)+sVel*Math.cos(rad);

        let speedMultiplier = 1;
        if(this.effects.slow) speedMultiplier = 0.5;
        if(playerUpgrades.timeWarp && !this.isFriendlyAI && this.ai) speedMultiplier = 0.4;
       
        this.speed = Math.hypot(this.velX,this.velY);
        let maxSpeed = this.baseMaxSpeed*(this.boosting?this.boostPower:1);
        if(this.speed>maxSpeed){let sc=maxSpeed/this.speed;this.velX*=sc;this.velY*=sc;}
       
        this.x += this.velX * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
       
        let w = CAR_WIDTH * this.sizeMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier;
        
        // Field Bounds
        if (this.x < w/2) { this.x = w/2; this.velX *= -0.5; }
        if (this.x > canvas.width - w/2) { this.x = canvas.width - w/2; this.velX *= -0.5; }
        if (this.y < h/2) { this.y = h/2; this.velY *= -0.5; }
        if (this.y > canvas.height - h/2) { this.y = canvas.height - h/2; this.velY *= -0.5; }
    }
   
    draw() {
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(-Math.PI*this.angle/180);
       
        let w = CAR_WIDTH * this.sizeMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier;
       
        let displayColor = this.color;
        if(this.isFriendlyAI) displayColor = '#00cccc';
        if(this.isStunned) displayColor = '#9ca3af';
        if(this.effects.confused) displayColor = '#a855f7';
       
        ctx.fillStyle=displayColor;
        ctx.beginPath(); ctx.roundRect(-w/2,-h/2, w, h, 8 * this.sizeMultiplier); ctx.fill();
       
        ctx.fillStyle='yellow';
        ctx.beginPath(); ctx.roundRect(w/2-(10*this.sizeMultiplier),-h/2+(5*this.sizeMultiplier), 8*this.sizeMultiplier, h-(10*this.sizeMultiplier), 2*this.sizeMultiplier); ctx.fill();
       
        if(this.boosting){
            ctx.fillStyle="#ffaa00";
            ctx.beginPath(); ctx.moveTo(-w/2,0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),-h/4);
            ctx.lineTo(-w/2-(20*this.sizeMultiplier),0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),h/4); ctx.closePath(); ctx.fill();
        }
        ctx.restore();
       
        if(this.effects.ring || this.effects.forceField){
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = this.effects.ring ? "#fcd34d" : "#00ff00";
            ctx.globalAlpha = 0.6; ctx.lineWidth=4;
            let radius = (CAR_WIDTH * this.sizeMultiplier) * 1.7;
            ctx.arc(this.x,this.y,radius,0,Math.PI*2); ctx.stroke();
            ctx.restore();
        }
       
        const isHuman=!this.ai;
        const label = isHuman?`P${this.playerId}`:`AI Lv.${this.difficulty} ${this.canBoost?'‚ö°':''}`;
        const labelY=this.y-h/2-15, barWidth=40, barHeight=6, bpct=this.boost/this.maxBoost;
        ctx.fillStyle=isHuman?COLOR_BLUE:(this.isFriendlyAI ? '#00cccc' : COLOR_RED);
        ctx.font='12px Inter'; ctx.textAlign='center';
        ctx.fillText(label,this.x,labelY-5);
        ctx.fillStyle='#1f2937';
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth,barHeight,3); ctx.fill();
        let grad = ctx.createLinearGradient(this.x-barWidth/2,0,this.x-barWidth/2+barWidth,0);
        grad.addColorStop(0,bpct<0.3?'#ef4444':'#f97316'); grad.addColorStop(1,'#f97316');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth*bpct,barHeight,3); ctx.fill();
    }
   
    refillBoost(amount) { this.boost = Math.min(this.maxBoost,this.boost+amount); }
    reset() {
        this.x=this.resetPos.x; this.y=this.resetPos.y; this.angle=this.resetPos.angle;
        this.velX=0; this.velY=0; this.speed=0; this.boost=this.maxBoost;
        this.isStunned=false; this.stunDuration=0; this.effects={};
    }
}

class Ball {
    constructor(x, y, radius, pointType=1) {
        this.x=x;this.y=y;this.radius=radius;this.color=COLOR_CYAN;
        this.velX=0;this.velY=0;this.maxSpeed=35; this.pointType=pointType; this.effects = {};
        this.stuckTimer = 0;
    }
   
    move(deltaTime) {
        if (this.effects.magnet || playerUpgrades.gravity) {
            let playerCar = cars.find(c => c.playerId === 1);
            if (playerCar) {
                let dx = playerCar.x - this.x;
                let dy = playerCar.y - this.y;
                let force = 0.005;
                if (playerUpgrades.gravity) force = 0.008;
                this.velX += dx * force;
                this.velY += dy * force;
            }
        }
        if (playerUpgrades.blackHole) {
             // Pull to Right Goal
             let goalX = canvas.width;
             let goalY = canvas.height / 2;
             let dx = goalX - this.x;
             let dy = goalY - this.y;
             let dist = Math.hypot(dx, dy);
             if (dist < 400) {
                 this.velX += dx * 0.002;
                 this.velY += dy * 0.002;
             }
        }

        this.velX *= 0.985; this.velY *= 0.985; // slightly less friction
       
        let speed = Math.hypot(this.velX, this.velY);
        if(speed > this.maxSpeed){ let sc = this.maxSpeed / speed; this.velX *= sc; this.velY *= sc; }
       
        let timeFactor = playerUpgrades.timeWarp ? 0.5 : 1.0;

        this.x += this.velX * deltaTime * PHYSICS_TICK_RATE * timeFactor;
        this.y += this.velY * deltaTime * PHYSICS_TICK_RATE * timeFactor;
       
        // Wall Bounces
        if (this.x < this.radius) { this.x = this.radius; this.velX *= -0.8; }
        else if (this.x > canvas.width - this.radius) { this.x = canvas.width - this.radius; this.velX *= -0.8; }
        if (this.y < this.radius) { this.y = this.radius; this.velY *= -0.8; }
        else if (this.y > canvas.height - this.radius) { this.y = canvas.height - this.radius; this.velY *= -0.8; }
       
        if(playerUpgrades.platinumStickyNet) {
            let aiGoalTop=canvas.height/2-GOAL_HEIGHT/2, aiGoalBottom=canvas.height/2+GOAL_HEIGHT/2;
            if(this.y>aiGoalTop && this.y<aiGoalBottom && this.x > canvas.width - (BALL_RADIUS*3)) {
                this.velX *= 0.6; // Sticky
            }
        }
        
        // Anti-Stuck
        if (speed < 0.8 && (this.x < 100 || this.x > canvas.width-100) && (this.y < 100 || this.y > canvas.height-100)) {
             this.stuckTimer += deltaTime;
             if(this.stuckTimer > 5.0) { this.reset(); stuckBallMessage = {text:'Ball Reset', duration:2}; }
        } else { this.stuckTimer = 0; }
    }
   
    draw() {
        ctx.fillStyle=this.pointType===1?this.color:(this.pointType===2?'#ffe066':'#ff92c6');
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
        if(this.pointType>1){
            ctx.fillStyle='white'; ctx.textAlign='center'; ctx.font='bold 12px Inter';
            ctx.fillText(this.pointType+'x', this.x, this.y+4);
        }
    }
   
    reset() {
        let maxOffset=canvas.height*MAX_CENTER_OFFSET_FACTOR;
        this.x=canvas.width/2; this.y=canvas.height/2 + (Math.random()*maxOffset*2 - maxOffset);
        this.velX=0;this.velY=0; this.effects = {};
        
        // Reset Point Type
        if(playerUpgrades.platinumDoubleAll) {
            this.pointType = Math.random() < 0.3 ? 2 : 1;
        } else {
            this.pointType = 1;
        }
    }
}

class BoostPad {
    constructor(x,y,radius=12){ this.x=x;this.y=y;this.radius=radius; this.active = true; this.timer = 0; }
    update(deltaTime) {
        if (!this.active) { this.timer -= deltaTime; if (this.timer <= 0) this.active = true; }
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.active ? 1 : 0.3;
        ctx.strokeStyle="#fbbf24"; ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle="#f59e42"; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius-7,0,Math.PI*2); ctx.fill();
        ctx.restore();
    }
    checkCollision(car){
        if (!this.active) return false; 
        let dist=Math.hypot(this.x-car.x,this.y-car.y);
        if (dist<this.radius+(CAR_WIDTH*car.sizeMultiplier/2)) {
             this.active = false; this.timer = 3.0;
             car.refillBoost(25 + (playerUpgrades.boostRegen ? 10 : 0));
        }
    }
}

class GoaliePad {
    constructor() { this.w = 14; this.h = GOAL_HEIGHT * 0.25; this.x = 7; this.y = canvas.height/2; }
    update(deltaTime) {
        let b = foreverBalls[0];
        if (b.x < canvas.width/2) {
            let ty = Math.max(canvas.height/2 - GOAL_HEIGHT/2 + 20, Math.min(b.y, canvas.height/2 + GOAL_HEIGHT/2 - 20));
            if (this.y < ty) this.y += 300 * deltaTime;
            else this.y -= 300 * deltaTime;
        }
    }
    draw() {
        ctx.fillStyle='#00cccc'; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.roundRect(this.x-this.w/2, this.y-this.h/2, this.w, this.h, 4); ctx.fill(); ctx.stroke();
    }
    checkCollision(ball) {
        if (ball.x - ball.radius < this.x + this.w/2 && Math.abs(ball.y - this.y) < this.h/2 + ball.radius) {
            ball.velX = Math.abs(ball.velX) * 1.2 + 5; // Kick out
            ball.x = this.x + this.w/2 + ball.radius + 2;
        }
    }
}


// ====== Game Functions ======
function getNumberOfAICars(){return cars.filter(c=>c.ai&&!c.isFriendlyAI).length;}

function addFriendlyAICar(playerId, role, difficultyMultiplier) {
    const P1_X=100+CAR_WIDTH/2, center_y=canvas.height/2;
    let newAI = new Car(P1_X + 20, center_y, '#00cccc', {}, 'left', playerId, 0, true, aiDifficulty * difficultyMultiplier, role);
    newAI.sizeMultiplier = 0.8;
    cars.push(newAI);
}

function addEnemyAICar() {
    let center_x=canvas.width/2, center_y=canvas.height/2;
    let P2_X=canvas.width-100;
    let newAI = new Car(P2_X,center_y + (Math.random()*100-50),COLOR_RED,{},'right',2+getNumberOfAICars(),180,true,aiDifficulty);
    cars.push(newAI);
    assignAIRoles();
    
    // Check for Boost Unlock
    if (getNumberOfAICars() >= 6) {
        cars.filter(c => c.ai && !c.isFriendlyAI).forEach(c => c.canBoost = true);
        systemMessage = { text: "WARNING: AI BOOST UNLOCKED!", duration: 3.0, color: 'orange' };
    }
}

function assignAIRoles(){
    let ais = cars.filter(c => c.ai && !c.isFriendlyAI);
    ais.forEach((ai, i) => {
        if (i === 0) ai.role = "attacker";
        else if (i === 1) ai.role = "defender";
        else if (i === 2) ai.role = "mid";
        else ai.role = i % 2 === 0 ? "attacker" : "defender";
    });
}

// --- AI STRATEGY CONTROL ---
function updateAIStrategy() {
    let cornerDist = 180;
    let ball = foreverBalls[0];
    
    // Reset Flags
    cars.forEach(c => { c.chasingCorner = false; c.avoidingCorner = false; });

    // 1. CHECK RIGHT CORNERS (AI SIDE) -> Send closest Defender
    if (ball.x > canvas.width - cornerDist && (ball.y < cornerDist || ball.y > canvas.height - cornerDist)) {
        let enemies = cars.filter(c => c.ai && !c.isFriendlyAI);
        if (enemies.length > 0) {
            // Filter for defenders first
            let defenders = enemies.filter(c => c.role === 'defender');
            let candidates = defenders.length > 0 ? defenders : enemies;
            
            let bestCar = null;
            let minDist = Infinity;
            candidates.forEach(c => {
                let d = Math.hypot(ball.x - c.x, ball.y - c.y);
                if (d < minDist) { minDist = d; bestCar = c; }
            });
            
            if (bestCar) {
                bestCar.chasingCorner = true;
                // Others avoid
                enemies.forEach(c => { if (c !== bestCar) c.avoidingCorner = true; });
            }
        }
    }

    // 2. CHECK LEFT CORNERS (PLAYER SIDE) -> Send closest Attacker
    else if (ball.x < cornerDist && (ball.y < cornerDist || ball.y > canvas.height - cornerDist)) {
         let enemies = cars.filter(c => c.ai && !c.isFriendlyAI);
         if (enemies.length > 0) {
             let attackers = enemies.filter(c => c.role === 'attacker');
             let candidates = attackers.length > 0 ? attackers : enemies;
             
             let bestCar = null;
             let minDist = Infinity;
             candidates.forEach(c => {
                 let d = Math.hypot(ball.x - c.x, ball.y - c.y);
                 if (d < minDist) { minDist = d; bestCar = c; }
             });
             
             if (bestCar) {
                 bestCar.chasingCorner = true;
                 enemies.forEach(c => { if (c !== bestCar) c.avoidingCorner = true; });
             }
         }
    }
}

function setupGameObjects(mode){
    canvas.width = DEFAULT_WIDTH; canvas.height = DEFAULT_HEIGHT;
    foreverBalls = [new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS)];
    ball = foreverBalls[0];
   
    cars=[];
    let p1 = new Car(100,canvas.height/2,COLOR_BLUE,{'up':'KeyW','down':'KeyS','left':'KeyA','right':'KeyD','boost':'ShiftLeft'},'left',1,0);
    cars.push(p1);

    if(mode==="1v1 Multiplayer") {
        cars.push(new Car(canvas.width-100,canvas.height/2,COLOR_RED,{'up':'ArrowUp','down':'ArrowDown','left':'ArrowLeft','right':'ArrowRight','boost':'ShiftRight'},'right',2,180));
    } else if(mode==="2v2 Multiplayer") {
        // 2v2 setup omitted for brevity, user focused on Vs Computer mostly
        cars.push(new Car(100,canvas.height/2+50, COLOR_BLUE, { 'up': 'KeyT', 'down': 'KeyG', 'left': 'KeyF', 'right': 'KeyH', 'boost': 'Space' }, 'left', 2, 0));
        cars.push(new Car(canvas.width-100,canvas.height/2-50, COLOR_RED, { 'up': 'ArrowUp', 'down': 'ArrowDown', 'left': 'ArrowLeft', 'right': 'ArrowRight', 'boost': 'ControlRight' }, 'right', 3, 180));
        cars.push(new Car(canvas.width-100,canvas.height/2+50, COLOR_RED, { 'up': 'KeyI', 'down': 'KeyK', 'left': 'KeyJ', 'right': 'KeyL', 'boost': 'ShiftRight' }, 'right', 4, 180));
    } else {
        // Vs Computer
        let newAI = new Car(canvas.width-100,canvas.height/2,COLOR_RED,{},'right',2,180,true,aiDifficulty);
        newAI.role = "attacker";
        cars.push(newAI);
    }
   
    p1.applyPlayerUpgrades(playerUpgrades);
    
    // Restore Permanents
    if (playerUpgrades.miniRobot) addFriendlyAICar(1001, 'attacker', 1.5);
    if (playerUpgrades.smolRobot) addFriendlyAICar(1002, 'defender', 1.0);
    if (playerUpgrades.autoGoalie) goaliePad = new GoaliePad();
   
    boostPads=[
        new BoostPad(canvas.width*0.5,canvas.height*0.25), new BoostPad(canvas.width*0.5,canvas.height*0.75),
        new BoostPad(canvas.width*0.25,canvas.height*0.5), new BoostPad(canvas.width*0.75,canvas.height*0.5),
        new BoostPad(canvas.width*0.5,canvas.height*0.5),
        new BoostPad(canvas.width*0.1,canvas.height*0.12), new BoostPad(canvas.width*0.9,canvas.height*0.12),
        new BoostPad(canvas.width*0.1,canvas.height*0.88), new BoostPad(canvas.width*0.9,canvas.height*0.88),
    ];
    if(playerUpgrades.extraBoostPad) {
        boostPads.push(new BoostPad(canvas.width*0.35, canvas.height*0.35));
        boostPads.push(new BoostPad(canvas.width*0.65, canvas.height*0.65));
    }
}

// --- UI ---
const overlay = document.getElementById('overlay');
const uiPanel = document.getElementById('ui-panel');
const foreverStatusPanel = document.getElementById('forever-status-panel');
const pauseBtn = document.getElementById('pause-btn');

function updateUI(){
    let timerElement=document.getElementById('timer'), aiStatusElement=document.getElementById('ai-status');
    document.getElementById('score-left').textContent=`BLUE: ${scoreLeft}`;
    document.getElementById('score-right').textContent=`RED: ${scoreRight}`;
   
    if(endConditionType==='forever'){
        timerElement.textContent=`${playerLevel}`;
        document.getElementById('mode-info').textContent=`PLAYER LEVEL`;
        aiStatusElement.textContent = `LV ${aiDifficulty} (${getNumberOfAICars()} Bots)`;
        document.getElementById('player-level-display').textContent = playerLevel;
        
        if (playerLevel > 100) {
            document.getElementById('late-game-warning').classList.remove('hidden');
        }
    } else {
        let m=Math.floor(gameTimer/60), s=Math.floor(gameTimer%60);
        timerElement.textContent=`${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }
    updateUpgradesDisplay();
}

function updateUpgradesDisplay() {
    const display = document.getElementById('player-upgrades-display');
    display.innerHTML = '';
    playerAbilities.forEach(ability => {
        const count = playerUpgrades[ability.id] || 0;
        const levelClass = `ability-level-${ability.tier}`;
        const item = document.createElement('div');
        item.className = `p-1 px-2 rounded text-xs font-bold flex items-center shadow ${levelClass} upgrade-icon-container`;
        item.innerHTML = `${ability.icon} ${ability.label} ${count>1?'x'+count:''}
            <div class="upgrade-tooltip">
                <h4 class="font-bold">${ability.label} <span class="text-[10px] px-1 rounded ${levelClass} text-black bg-white/50">${ability.tier.toUpperCase()}</span></h4>
                <p>${ability.desc}</p>
            </div>`;
        display.appendChild(item);
    });
}

function drawField(){
    ctx.fillStyle=COLOR_FIELD; ctx.fillRect(0,0,canvas.width,canvas.height);

    let goalHeight = GOAL_HEIGHT * (playerUpgrades.shortGoal ? 0.7 : 1);
    let aiGoalHeight = GOAL_HEIGHT * (playerUpgrades.goalExpansion ? 1.3 : 1);
    
    let pGT=canvas.height/2 - goalHeight/2, pGB=canvas.height/2 + goalHeight/2;
    let aGT=canvas.height/2 - aiGoalHeight/2, aGB=canvas.height/2 + aiGoalHeight/2;

    ctx.fillStyle = 'rgba(0, 102, 204, 0.1)'; ctx.fillRect(0, pGT, 20, goalHeight);
    ctx.fillStyle = 'rgba(204, 0, 0, 0.1)'; ctx.fillRect(canvas.width - 20, aGT, 20, aiGoalHeight);

    ctx.strokeStyle="#dcdcdc"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(canvas.width/2,0); ctx.lineTo(canvas.width/2,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(canvas.width/2,canvas.height/2,80,0,Math.PI*2); ctx.stroke();
   
    ctx.strokeStyle=COLOR_BLUE; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(0,pGT); ctx.lineTo(0,pGB); ctx.stroke();
   
    ctx.strokeStyle=COLOR_RED; ctx.lineWidth=GOAL_LINE_WIDTH; 
    ctx.beginPath(); ctx.moveTo(canvas.width,aGT); ctx.lineTo(canvas.width,aGB); ctx.stroke();
   
    boostPads.forEach(pad=>pad.draw());
    if (goaliePad) goaliePad.draw();
}

function handleGoal(scoringTeam, scoredBall) {
    if (scoringTeam === 'left') { 
        let oldLevel = playerLevel;
        scoreLeft += scoredBall.pointType;
        playerLevel += scoredBall.pointType;
       
        if (endConditionType === 'forever') {
            if(Math.floor(playerLevel/5) > Math.floor(oldLevel/5)) pendingUpgradePick = true;
            
            // Late Game AI Buffs (Level 100+)
            if (playerLevel > 100 && Math.floor(playerLevel/10) > Math.floor(oldLevel/10)) {
                aiDifficulty++;
                let buffType = Math.random();
                let buffMsg = "";
                
                cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => {
                    ai.updateDifficulty(aiDifficulty);
                    if (buffType < 0.33) { ai.baseMaxSpeed += 0.5; buffMsg = "AI SPEED UP"; }
                    else if (buffType < 0.66) { ai.massMultiplier += 0.2; buffMsg = "AI MASS UP"; }
                    else { ai.sizeMultiplier *= 1.1; buffMsg = "AI SIZE UP"; }
                });
                systemMessage = { text: `LV ${playerLevel}: ${buffMsg}`, duration: 4.0, color: 'red' };
            }
            else if (Math.floor(playerLevel/10) > Math.floor(oldLevel/10)) {
                // Normal Progression < 100
                if (getNumberOfAICars() < 6) addEnemyAICar();
                else {
                    aiDifficulty++;
                    cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => ai.updateDifficulty(aiDifficulty));
                }
            }
        }

        if (playerUpgrades.freeze) cars.filter(c=>c.ai && !c.isFriendlyAI).forEach(c=>{c.isStunned=true; c.stunDuration=2.0;});
        if (playerUpgrades.ballSplit && foreverBalls.length < 5) foreverBalls.push(new Ball(scoredBall.x, scoredBall.y, BALL_RADIUS));
    }
    else if (scoringTeam === 'right') { 
        scoreRight += scoredBall.pointType;
        if (endConditionType === 'forever' && scoreRight >= scoreLeft + 5) {
             gameState = 'finished'; drawGameOver('ai_won'); return;
        }
    }
   
    if(foreverBalls.length === 1 || scoredBall.pointType > 1) cars.forEach(c => c.reset());
    if(foreverBalls.length > 1) foreverBalls = foreverBalls.filter(b => b !== scoredBall);
    else scoredBall.reset();
   
    if (gameState === 'playing') {
        if (checkGameEnd()) { gameState = 'finished'; drawGameOver(); }
        else if (pendingUpgradePick) { requestUpgradePicker(); pendingUpgradePick = false; }
    }
}

function checkGoal(ball) {
    let gh = GOAL_HEIGHT * (playerUpgrades.shortGoal?0.7:1);
    let agh = GOAL_HEIGHT * (playerUpgrades.goalExpansion?1.3:1);
    if(ball.y>canvas.height/2-gh/2 && ball.y<canvas.height/2+gh/2 && ball.x-ball.radius<=0) return 'right'; 
    if(ball.y>canvas.height/2-agh/2 && ball.y<canvas.height/2+agh/2 && ball.x+ball.radius>=canvas.width) {
        if(playerUpgrades.goalBlock && cars[0].effects.goalBlock) return null;
        return 'left';
    }
    return null;
}

function checkGameEnd() {
    if (endConditionType === 'points' && (scoreLeft >= targetScore || scoreRight >= targetScore)) return true;
    if (endConditionType === 'timed' && gameTimer <= 0) return true;
    return false;
}

// --- MAIN LOOP ---
function update(deltaTime) {
    if(gameState==='playing'){
        if (playerUpgrades.boostRain && Math.random() < 0.001) cars[0].refillBoost(100);
        if (endConditionType === 'timed') gameTimer=Math.max(0,gameTimer-deltaTime);
        
        // Run AI Strategy Commander
        updateAIStrategy();
       
        cars.forEach(car => { car.handleInput(deltaTime); car.move(deltaTime); });
        foreverBalls.forEach(ball => ball.move(deltaTime));
        boostPads.forEach(pad => pad.update(deltaTime));
        if (goaliePad) goaliePad.update(deltaTime);

        // Collisions
        cars.forEach(car => foreverBalls.forEach(ball => {
            let dx=ball.x-car.x, dy=ball.y-car.y;
            let cr=BALL_RADIUS+(CAR_WIDTH*car.sizeMultiplier*0.5);
            let dist=Math.hypot(dx,dy);
            if(dist<cr){
                let ang=Math.atan2(dy,dx);
                let force = 1.0 + car.speed*1.5*(car.boosting?1.8:1);
                if(!car.ai) {
                    force *= (1 + (playerUpgrades.kick||0)*0.15);
                    if (playerUpgrades.doubleKick) force *= 2;
                    if (playerUpgrades.sniper) force *= 1.3;
                }
                
                // Knockback Physics
                if(!car.ai && playerUpgrades.grip) { car.velX *= 0.9; car.velY *= 0.9; }
                else {
                    let recoil = 0.5 / car.massMultiplier;
                    car.velX -= Math.cos(ang)*force*recoil; 
                    car.velY -= Math.sin(ang)*force*recoil;
                }

                ball.velX+=Math.cos(ang)*force; ball.velY+=Math.sin(ang)*force;
                let overlap=cr-dist;
                if(overlap>0){ ball.x+=Math.cos(ang)*overlap; ball.y+=Math.sin(ang)*overlap; }
                
                if (!car.ai && playerUpgrades.magnet) ball.effects.magnet = {duration:0.5};
            }
        }));

        for(let i=0; i<cars.length; i++) for(let j=i+1; j<cars.length; j++) {
            let c1=cars[i], c2=cars[j];
            let d = Math.hypot(c1.x-c2.x, c1.y-c2.y);
            let r1 = CAR_WIDTH*c1.sizeMultiplier/2, r2 = CAR_WIDTH*c2.sizeMultiplier/2;
            if (d < r1+r2) {
                let ang = Math.atan2(c2.y-c1.y, c2.x-c1.x);
                let lap = (r1+r2)-d;
                c1.x -= Math.cos(ang)*lap/2; c1.y -= Math.sin(ang)*lap/2;
                c2.x += Math.cos(ang)*lap/2; c2.y += Math.sin(ang)*lap/2;
                
                // Mass Based Collision
                let m1 = c1.massMultiplier * c1.sizeMultiplier;
                let m2 = c2.massMultiplier * c2.sizeMultiplier;
                
                let v1 = Math.hypot(c1.velX, c1.velY);
                let v2 = Math.hypot(c2.velX, c2.velY);
                
                c1.velX -= Math.cos(ang) * v2 * (m2/m1) * 0.8;
                c1.velY -= Math.sin(ang) * v2 * (m2/m1) * 0.8;
                c2.velX += Math.cos(ang) * v1 * (m1/m2) * 0.8;
                c2.velY += Math.sin(ang) * v1 * (m1/m2) * 0.8;
                
                if(!c1.ai && c2.ai && playerUpgrades.slipStream) c1.refillBoost(15);
            }
        }
        
        cars.forEach(car => boostPads.forEach(pad => pad.checkCollision(car)));
       
        let scoredBalls = [];
        foreverBalls.forEach(ball => {
            if (goaliePad) goaliePad.checkCollision(ball);
            let team = checkGoal(ball);
            if (team) scoredBalls.push({ball, team});
        });
        if (scoredBalls.length > 0) handleGoal(scoredBalls[0].team, scoredBalls[0].ball);
       
        updateUI();
    }
}

function gameLoop(currentTime) {
    if (!['playing', 'paused', 'finished', 'upgrading'].includes(gameState)) { cancelAnimationFrame(animationFrameId); return; }
    const deltaTime = (currentTime - lastTime) / 1000; lastTime = currentTime;
   
    if (gameState === 'playing') update(deltaTime);
    
    if (['playing','paused','finished','upgrading'].includes(gameState)) {
        drawField();
        cars.forEach(car => car.draw());
        foreverBalls.forEach(ball => ball.draw());
    }

    // Messages
    if (stuckBallMessage.duration > 0) {
        ctx.fillStyle='white'; ctx.font='bold 24px Inter'; ctx.fillText(stuckBallMessage.text, canvas.width/2, 100);
        if(gameState==='playing') stuckBallMessage.duration -= deltaTime;
    }
    if (systemMessage.duration > 0) {
        ctx.fillStyle=systemMessage.color; ctx.font='bold 30px Inter'; ctx.textAlign='center';
        ctx.fillText(systemMessage.text, canvas.width/2, canvas.height/2 - 50);
        if(gameState==='playing') systemMessage.duration -= deltaTime;
    }

    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- MENU ---
function drawMainMenu() {
    gameState = 'menu';
    overlay.classList.add('visible'); 
    document.getElementById('pause-btn').classList.add('hidden');
    document.getElementById('fullscreen-btn').classList.add('hidden');
    
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-8 text-yellow-400">2D ROCKET LEAGUE</h1>
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="select-mode-1v1">1v1 Multiplayer (Local)</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="select-mode-2v2">2v2 Multiplayer (Local)</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="select-mode-vs-computer">Vs Computer</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="play-online">Play Online</div>
            </div>
        </div>
    `;
   
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}

function drawGameSettingsMenu(mode) {
    gameState = 'menu';
    let foreverModeOption = '';
    if (mode === 'Vs Computer') {
        foreverModeOption = `<h2 class="text-2xl font-bold mb-3 text-white mt-6">Challenge Mode</h2>
            <div class="flex justify-center gap-4 mb-6"><div class="p-3 bg-cyan-600 rounded-lg hover:bg-cyan-500" data-action="start-forever">Start FOREVER MODE</div></div>`;
    }

    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-lg pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">${mode} Settings</h1>
            <div id="menu-options">
                <h2 class="text-2xl font-bold mb-3 text-white">Time Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-timed-1">1 Min</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-timed-2">2 Mins</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-timed-5">5 Mins</div>
                </div>
                <h2 class="text-2xl font-bold mb-3 text-white">Score Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-points-3">3 Pts</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-points-5">5 Pts</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="start-points-10">10 Pts</div>
                </div>
                ${foreverModeOption}
                <hr class="border-gray-500 my-6">
                <div><div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="main-menu">Back</div></div>
            </div>
        </div>`;
   
    window.currentGameModeSelection = mode;
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
    menuOptions.forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu'));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}

function drawUpgradeMenu() {
    drawField(); cars.forEach(c => c.draw()); foreverBalls.forEach(b => b.draw());
    overlay.classList.add('visible'); 
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-5xl pointer-events-auto">
            <h1 class="text-4xl font-extrabold mb-2 text-green-400">LEVEL UP! (Lv ${playerLevel})</h1>
            <p class="text-gray-300 mb-6">Select an ability. Rerolls: ${playerUpgrades.rerollPlus ? '‚àû' : (1-upgradeRerollsUsed)}</p>
            <div id="upgrade-options" class="flex flex-wrap justify-center gap-6">
                ${upgradeOptions.map((opt, index) => `
                    <div id="upgrade-${index}" data-index="${index}" class="upgrade-option-card p-4 rounded-xl w-64 text-left shadow-lg border-2 border-transparent bg-gray-600">
                        <p class="text-xl font-bold mb-1 flex items-center justify-between">
                            <span class="text-2xl mr-2">${opt.icon}</span>
                            <span class="font-mono text-sm font-bold p-1 px-2 rounded-full ability-level-${opt.tier}">${opt.tier.toUpperCase()}</span>
                        </p>
                        <h2 class="text-lg font-bold mb-2 text-white">${opt.label}</h2>
                        <p class="text-xs text-gray-300 h-12 overflow-hidden">${opt.desc}</p>
                    </div>
                `).join('')}
            </div>
        </div>`;
   
    menuOptions = document.getElementById('upgrade-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleUpgradeSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('upgrade-options', index, 'upgrade'));
    });
    selectedUpgradeIndex = 0; updateMenuSelectionUI('upgrade-options', selectedUpgradeIndex, 'upgrade');
}

function drawGameOver(reason) {
    pauseBtn.classList.add('hidden'); document.getElementById('fullscreen-btn').classList.add('hidden');
    overlay.classList.add('visible'); 
    let message = reason === 'ai_won' ? 'YOU LOSE!' : (scoreLeft>scoreRight?'BLUE WINS!':'RED WINS!');
   
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md pointer-events-auto">
            <h1 class="text-5xl font-extrabold mb-4 text-pink-400">GAME OVER</h1>
            <p class="text-3xl font-bold mb-6 ${reason==='ai_won'?'text-red-400':'text-yellow-300'}">${message}</p>
            ${endConditionType === 'forever' ? `<p class="text-xl text-gray-300 mb-6">Final Level: ${playerLevel}</p>` : ''}
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="restart">Play Again</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500" data-action="main-menu">Back</div>
            </div>
        </div>`;
   
    menuOptions = document.getElementById('menu-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
    });
    selectedMenuIndex = 0; updateMenuSelectionUI('menu-options', selectedMenuIndex);
}

function updateMenuSelectionUI(containerId, selectedIndex, type = 'menu') {
    if (type === 'menu') selectedMenuIndex = selectedIndex; else selectedUpgradeIndex = selectedIndex;
    let optionsToUpdate = (type === 'upgrade' && containerId) ? document.getElementById(containerId).children : menuOptions;
    Array.from(optionsToUpdate).forEach((child, index) => {
        child.classList.remove('menu-selected');
        if (index === selectedIndex) child.classList.add('menu-selected');
    });
}

function handleMenuSelection(index) {
    if (!menuOptions[index]) return;
    const selection = menuOptions[index].getAttribute('data-action');
    const mode = window.currentGameModeSelection;
   
    if (selection === 'select-mode-1v1') drawGameSettingsMenu('1v1 Multiplayer');
    else if (selection === 'select-mode-2v2') drawGameSettingsMenu('2v2 Multiplayer');
    else if (selection === 'select-mode-vs-computer') drawGameSettingsMenu('Vs Computer');
    else if (selection === 'start-forever') startGame('Vs Computer', 'forever');
    else if (selection && selection.startsWith('start-timed')) { timeLimitSeconds = parseInt(selection.split('-')[2])*60; startGame(mode, 'timed'); }
    else if (selection && selection.startsWith('start-points')) { targetScore = parseInt(selection.split('-')[2]); startGame(mode, 'points'); }
    else if (selection === 'play-online') window.location.href = "https://ccpspy.github.io/onlinecargame";
    else if (selection === 'restart') { cancelAnimationFrame(animationFrameId); startGame(gameMode, endConditionType); }
    else if (selection === 'main-menu') {
        cancelAnimationFrame(animationFrameId); gameState = 'menu';
        uiPanel.classList.add('hidden'); foreverStatusPanel.classList.add('hidden');
        drawMainMenu();
    }
}

function handleUpgradeSelection(index) {
    if (!upgradeOptions[index]) return;
    const upgrade = upgradeOptions[index];
    if (upgrade.id.startsWith('reroll')) { if(upgrade.id==='reroll') upgradeRerollsUsed++; rerollUpgradeOptions(); }
    else { applyUpgrade(upgrade); exitUpgradePicker(); }
}

function startGame(mode, endType='timed') {
    gameMode = mode; endConditionType = endType; scoreLeft = 0; scoreRight = 0; aiDifficulty = 1;
    if(endType === 'forever') {
        timeLimitSeconds = 99999; targetScore = 999; playerLevel = 0; playerUpgrades = {}; playerAbilities = [];
        gameState = 'upgrading'; requestUpgradePicker();
    } else {
        playerUpgrades = {}; playerAbilities = []; gameState = 'playing';
        pauseBtn.classList.remove('hidden'); document.getElementById('fullscreen-btn').classList.remove('hidden');
        lastTime = performance.now(); animationFrameId = requestAnimationFrame(gameLoop);
    }
    setupGameObjects(mode); updateUI(); 
    uiPanel.classList.remove('hidden');
    if(endType === 'forever') { uiPanel.classList.add('hidden'); foreverStatusPanel.classList.remove('hidden'); }
}

function toggleFullScreen() {
    const el = document.getElementById('game-container');
    if (!document.fullscreenElement) el.requestFullscreen(); else document.exitFullscreen();
}
document.addEventListener('fullscreenchange', () => {
    const el = document.getElementById('game-container');
    if (document.fullscreenElement) { el.classList.add('fullscreen-active'); document.body.classList.add('fullscreen-active'); }
    else { el.classList.remove('fullscreen-active'); document.body.classList.remove('fullscreen-active'); }
});
fullscreenBtn.addEventListener('click', toggleFullScreen);

// --- Inputs ---
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (gameState.includes('menu') || gameState === 'paused' || gameState === 'finished') {
        if (e.code === 'ArrowDown') selectedMenuIndex = (selectedMenuIndex + 1) % menuOptions.length;
        else if (e.code === 'ArrowUp') selectedMenuIndex = (selectedMenuIndex - 1 + menuOptions.length) % menuOptions.length;
        else if (e.code === 'Enter') menuOptions[selectedMenuIndex]?.click();
        updateMenuSelectionUI('menu-options', selectedMenuIndex);
    } else if (gameState === 'upgrading') {
        if (e.code === 'ArrowRight') selectedUpgradeIndex = (selectedUpgradeIndex + 1) % 3; // approximate
        else if (e.code === 'Enter') menuOptions[selectedUpgradeIndex]?.click();
        // Basic arrow navigation support for upgrade menu is simplified here
    }
});
window.addEventListener('keyup', (e) => keys[e.code] = false);
window.onload = function () { canvas.width = DEFAULT_WIDTH; canvas.height = DEFAULT_HEIGHT; drawMainMenu(); }

</script>
</body>
</html>
