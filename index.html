<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Rocket League - Enhanced Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }
        #game-container {
            width: 100%;
            max-width: 1200px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 1rem; /* rounded-2xl */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background-color: #2b2f3d; /* Custom field color */
            display: block;
            border-radius: 0.75rem; /* rounded-xl */
            margin: 0 auto;
        }
        .boost-bar {
            transition: width 0.1s ease-out;
        }
        /* Style for keyboard/mouse selected menu items */
        .menu-selected {
            border: 3px solid #fcd34d; /* amber-300 */
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.6);
            padding: 0.5rem 1rem;
            border-radius: 10px;
            color: #fcd34d; /* amber-300 */
            transform: translateY(-2px);
        }
        #menu-options > div, #upgrade-options > div, #menu-options > a { /* Added 'a' for online button */
             cursor: pointer; /* Changed from default to pointer */
             transition: transform 0.2s, box-shadow 0.2s;
        }
       
        /* Tooltip styles (for bottom bar) */
        .upgrade-icon-container {
            position: relative;
            cursor: default;
        }
        .upgrade-tooltip {
            visibility: hidden;
            background-color: #1f2937; /* bg-gray-800 */
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 10;
            bottom: 125%; /* Position above the icon */
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            width: 220px; /* Give it some width */
            white-space: normal; /* Allow text wrapping */
        }
        .upgrade-icon-container:hover .upgrade-tooltip {
            visibility: visible;
            opacity: 1;
        }
        /* End Tooltip */

        /* Ability tier colors */
        /* FIX: Changed bronze to brown */
        .ability-level-bronze { background: #cd7f32; color: #ffffff; }
        .ability-level-silver { background: #c0c0c0; color: #393939; }
        .ability-level-gold { background: linear-gradient(90deg,#ffd700,#fae360); color: #625002; }
        .ability-level-platinum { background: linear-gradient(90deg,#e5e4e2,#b9f2ff); color: #234d5f; border: 2px solid #8e8e8e; }
       
        .ball-point-label {
            position: absolute;
            pointer-events: none;
            min-width: 18px;
            min-height: 18px;
            font-size: 13px !important;
            text-align: center;
            background: #fff;
            color: #333;
            border-radius: 50%;
            box-shadow: 0 0 5px rgb(0 0 0 / 40%);
            border: 2px solid #f0ad4e;
            padding: 0 4px;
        }
        .player-ring-effect {
            position: absolute;
            border-radius: 50%;
            border: 3px dashed #00fff4;
            opacity: 0.5;
            pointer-events: none;
            z-index: 100;
        }
        .ability-selected {
            border: 3px solid #39ff14;
        }
        .upgrade-option-card {
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }
        /* REMOVED: .upgrade-option-card:hover - This is now handled by .menu-selected for consistency */
    </style>
</head>
<body class="bg-gray-900 text-white">

<div id="game-container" class="bg-gray-800 p-4 sm:p-6 lg:p-8">
    <!-- Top Bar for Pause Button -->
    <div id="top-bar" class="w-full mb-4 flex justify-end">
        <button id="pause-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg transition duration-200 shadow-md flex items-center hidden">
            <span class="mr-2">‚è∏Ô∏è</span> Pause (P)
        </button>
    </div>

    <!-- NEW: Game Viewport - Wraps Canvas and Overlay -->
    <div id="game-viewport" class="relative w-full">
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Overlay for Menus, Upgrades, and End Screen -->
        <!-- NOTE: This is now *inside* game-viewport, so it only covers the canvas -->
        <div id="overlay" class="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-90 transition-opacity duration-300 hidden"></div>
    </div>

    <!-- UI Panel (Score/Boost/Difficulty) -->
    <!-- This is now *outside* the viewport and will remain visible when paused -->
    <div id="ui-panel" class="w-full mt-4 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <div class="flex justify-between items-center text-xl font-bold">
            <div id="score-left" class="text-blue-400">BLUE: 0</div>
            <div id="center-info" class="text-center">
                <div id="timer" class="text-white text-3xl font-mono">02:00</div>
                <div id="mode-info" class="text-sm text-gray-300 mt-1">TIME REMAINING</div>
            </div>
            <div id="score-right" class="text-red-400">RED: 0</div>
        </div>
    </div>

    <!-- Forever Mode Status Panel -->
    <!-- This is now *outside* the viewport and will remain visible when paused -->
    <div id="forever-status-panel" class="w-full mt-4 p-4 bg-gray-700 rounded-lg shadow-lg hidden">
        <h3 class="text-xl font-bold mb-3 text-cyan-400">Forever Mode Status</h3>
        <div class="flex flex-wrap justify-between items-start">
            <div class="w-full md:w-1/3 mb-4 md:mb-0">
                <h4 class="font-semibold text-gray-300">AI Challenge</h4>
                <p id="ai-status" class="text-2xl font-bold text-red-400">LV 1 (1 Car)</p>
                <p class="text-sm text-gray-400 mt-1">Player Level: <span id="player-level-display">0</span></p>
            </div>
            <div class="w-full md:w-2/3">
                <h4 class="font-semibold text-gray-300 mb-2">Player Upgrades & Abilities</h4>
                <div id="player-upgrades-display" class="flex flex-wrap gap-4"></div>
            </div>
        </div>
    </div>

</div>

<script>
// --- Constants ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const DEFAULT_WIDTH = 1000, DEFAULT_HEIGHT = 600;
const CAR_WIDTH = 60, CAR_HEIGHT = 30;
const BALL_RADIUS = 20;
const GOAL_HEIGHT = 200;
const GOAL_LINE_WIDTH = 8;
const MAX_CENTER_OFFSET_FACTOR = 1 / 6;
const PHYSICS_TICK_RATE = 60; // We'll scale physics to this (e.g., deltaTime * 60)
const COLOR_BLUE = '#0066cc';
const COLOR_RED = '#cc0000';
const COLOR_CYAN = '#00fff4';
const COLOR_FIELD = '#2b2f3d';

// --- Game State ---
let gameState = 'menu';
let gameMode = '1v1 Multiplayer';
let endConditionType = 'timed';
let timeLimitSeconds = 120;
let targetScore = 5;
let gameTimer = 0;
let scoreLeft = 0, scoreRight = 0;
let cars = [];
let boostPads = [];
// FIX: Removed Jump Pads
let goaliePad = null; // FIX: Added for Goalie Pad ability
let ball = null;
let foreverBalls = [];
let keys = {};
let lastTime = 0;
let animationFrameId;
let aiDifficulty = 1;
let playerUpgrades = {}; // { id: count }
let playerAbilities = []; // [{id, label, icon, desc, tier}]
let playerLevel = 0; // FIX: Start at 0
let upgradeRerollsUsed = 0, extraUpgradePicks = 0, upgradeOptions = [];
let pendingUpgradePick = false;
let stuckBallMessage = { text: '', duration: 0 }; // FIX: For stuck ball message

// --- FIX: Global declarations for menu state ---
let selectedMenuIndex = 0;
let selectedUpgradeIndex = 0;
let menuOptions = []; // This will hold the DOM elements for the current menu

// --- ABILITY POOLS ---
const BRONZE_UPGRADES = [
    {id:'accel',label:'Engine Boost',icon:'‚ö°',desc:'Acceleration +10%.',tier:'bronze'},
    {id:'turn',label:'Agile Steering',icon:'üåÄ',desc:'Rotation speed +15%.',tier:'bronze'},
    {id:'maxBoost',label:'Fuel Tank',icon:'‚õΩ',desc:'Boost capacity +20.',tier:'bronze'},
    {id:'boostRegen',label:'Quick Refuel',icon:'üîã',desc:'Pad refill +10.',tier:'bronze'},
    {id:'frictionFix',label:'Traction Control',icon:'ü¶∂',desc:'Reduces drift by 10%.',tier:'bronze'},
    {id:'speed',label:'Nitro Burst',icon:'üöÄ',desc:'Top speed +5%.',tier:'bronze'},
    {id:'brake',label:'Hand Brake',icon:'üÖøÔ∏è',desc:'Braking force increased.',tier:'bronze'},
    {id:'kick',label:'Stronger Kick',icon:'ü¶µ',desc:'Ball hit knockback +10%.',tier:'bronze'},
    {id:'stickTires',label:'Sticky Tires',icon:'üß≤',desc:'Less slip after hit.',tier:'bronze'},
    {id:'extraBoostPad',label:'Extra Boost Pad',icon:'‚ú®',desc:'Bonus boost pad on field.',tier:'bronze', permanent:true},
    {id:'padFastRespawn',label:'Faster Pads',icon:'‚è©',desc:'Pads respawn quickly.',tier:'bronze', permanent:true}, // Note: Not implemented, but kept
    {id:'smallCar',label:'Micro Car',icon:'üêÅ',desc:'Reduced hitbox.',tier:'bronze'}, // Note: Not implemented
    {id:'bigCar',label:'Truck Mode',icon:'üöö',desc:'Larger body, better defense.',tier:'bronze'}, // Note: Not implemented
    // {id:'shortGoal',label:'Mini Goal',icon:'üõ°Ô∏è',desc:'Your goal becomes smaller.',tier:'bronze'}, // FIX: Moved to Gold
    {id:'slipStream',label:'Slipstream',icon:'üí®',desc:'Gain 10 boost after colliding with an AI.',tier:'bronze'},
    {id:'directionalBoost',label:'Directional Boost',icon:'‚ÜóÔ∏è',desc:'Directional boost on turn.',tier:'bronze'}, // Note: Not implemented
];
const SILVER_UPGRADES = [
    {id:'hyperPad',label:'Hyper Pads',icon:'üå™Ô∏è',desc:'Pads refill 2x faster.',tier:'silver', permanent:true}, // Note: Not implemented, but kept
    {id:'miniRobot',label:'Mini Bot',icon:'ü§ñ',desc:'Spawns a friendly AI attacker.',tier:'silver', permanent:true},
    {id:'goalExpansion',label:'Wide Goal',icon:'ü•Ö',desc:'AI goal is 30% wider.',tier:'silver', permanent:true}, // FIX: Implemented this
    {id:'tempShield',label:'Shield',icon:'üõ°Ô∏è',desc:'AI balls can\'t score if they touch you for 6s.',tier:'silver'}, // Note: Not implemented
    {id:'doubleKick',label:'Double Kick',icon:'ü•ä',desc:'Doubles ball impact force.',tier:'silver'},
    {id:'ballMagnet',label:'Ball Magnet',icon:'üß≤',desc:'Ball gently follows you for 0.25s after contact.',tier:'silver'},
    {id:'ghostCar',label:'Ghost Mode',icon:'üëª',desc:'Boost for 0.8s to phase through AI for 1.5s (2s cooldown).',tier:'silver'}, // FIX: Implemented
    // FIX: Removed Jump Pad
    {id:'smolRobot',label:'Tiny Bot',icon:'üêú',desc:'Spawns a friendly AI defender.',tier:'silver', permanent:true},
    {id:'boostRain',label:'Boost Rain',icon:'üå¶Ô∏è',desc:'Small chance to randomly get 30 boost.',tier:'silver'},
];
const GOLD_UPGRADES = [
    {id:'superStun',label:'Stun Ring',icon:'üí´',desc:'After you score, stun nearby AI for 2s on *next* ball contact.',tier:'gold'},
    {id:'extraUpgrade',label:'Extra Choice',icon:'üéà',desc:'Get one extra upgrade pick next round.',tier:'gold'},
    {id:'autoGoalie',label:'Auto Goalie',icon:'üïπÔ∏è',desc:'Spawns an AI goalie pad that blocks your net.',tier:'gold', permanent:true}, // FIX: Reworked
    {id:'rerollPlus',label:'Unlimited Rerolls',icon:'üîÑ',desc:'Free rerolls *this selection only*.',tier:'gold'},
    {id:'aiSlow',label:'Slow AI',icon:'üê¢',desc:'AIs are slowed by 50% for 5s after you score.',tier:'gold'},
    {id:'timeFreeze',label:'Time Freeze',icon:'‚ùÑÔ∏è',desc:'Freeze all AIs for 2s when you score.',tier:'gold'},
    {id:'doubleJump',label:'Double Jump',icon:'ü¶ò',desc:'Double jump next goal.',tier:'gold'}, // Note: Not implemented
    {id:'forceField',label:'Force Field',icon:'‚òÑÔ∏è',desc:'Radius blocks all AI for a short time.',tier:'gold'}, // Note: Not implemented
    {id:'freePad',label:'Free Pad',icon:'üçÄ',desc:'A bonus pad spawns when AI scores.',tier:'gold'},
    {id:'ballSplit',label:'Ball Split',icon:'üé±',desc:'Ball splits into two after you score (max 5 balls).',tier:'gold'},
    {id:'goalBlock',label:'Goal Block',icon:'üöß',desc:'Blocks AI balls from scoring for 3s after you score.',tier:'gold'},
    {id:'shortGoal',label:'Mini Goal',icon:'üõ°Ô∏è',desc:'Your goal becomes smaller.',tier:'gold'}, // FIX: Moved from Bronze
];
const PLATINUM_UPGRADES = [
    {id:'platinumDoubleAll',label:'Multi Ball Mayhem',icon:'üåà',desc:'Spawns 3 balls. Balls have chance for 2x/3x points.',tier:'platinum', permanent:true},
    {id:'platinumSuperAI',label:'AI Mayhem',icon:'üéÆ',desc:'Confuses all AIs for 5s after you score.',tier:'platinum'},
    {id:'platinumStickyNet',label:'Sticky Net',icon:'üï∏Ô∏è',desc:'Opponent goal is "sticky" and slows the ball.',tier:'platinum'},
    {id:'platinumInvincible',label:'Mega Invincible',icon:'üëë',desc:'Collision immune & unlimited boost for 10s.',tier:'platinum'}, // Note: Not implemented
];
const ALL_UPGRADES = [...BRONZE_UPGRADES, ...SILVER_UPGRADES, ...GOLD_UPGRADES, ...PLATINUM_UPGRADES];

// --- Ability / Upgrade Functions ---
function getAbilityTierByLevel(level) {
    if (level < 5) return "bronze";
    if (level < 15) return Math.random() < 0.25 ? "silver" : "bronze";
    if (level < 30) {
        const r = Math.random();
        if (r < 0.52) return "silver";
        if (r < 0.70) return "gold";
        return "bronze";
    }
    if (level < 70) {
        const r = Math.random();
        if (r < 0.10) return "platinum";
        if (r < 0.69) return "gold";
        return "silver";
    }
    return Math.random() < 0.17 ? "platinum" : (Math.random() < 0.68 ? "gold" : "silver");
}
function getPoolForTier(tier) {
    if (tier === "bronze") return BRONZE_UPGRADES;
    if (tier === "silver") return SILVER_UPGRADES;
    if (tier === "gold") return GOLD_UPGRADES;
    if (tier === "platinum") return PLATINUM_UPGRADES;
}
function randomAbilities(amt, disallowIds=[]) {
    let chosen = [];
    const playerUpgradeIds = Object.keys(playerUpgrades);
    for (let i = 0; i < amt; i++) {
        let tier = getAbilityTierByLevel(playerLevel);
        let pool = getPoolForTier(tier).filter(u => !disallowIds.includes(u.id));
        // Filter out permanent upgrades already owned
        pool = pool.filter(u => !u.permanent || !playerUpgradeIds.includes(u.id));
       
        if (pool.length === 0) { // Failsafe
            pool = BRONZE_UPGRADES.filter(u => !disallowIds.includes(u.id) && (!u.permanent || !playerUpgradeIds.includes(u.id)));
        }
        if (pool.length === 0) { // Super failsafe
             pool = [BRONZE_UPGRADES[0]];
        }
       
        const pick = pool[Math.floor(Math.random() * pool.length)];
        chosen.push(pick);
        disallowIds.push(pick.id);
    }
    return chosen;
}
function requestUpgradePicker() {
    gameState = 'upgrading';
    upgradeRerollsUsed = 0;
    rerollUpgradeOptions(); // This calls drawUpgradeMenu
    document.getElementById('pause-btn').classList.add('hidden');
}
function rerollUpgradeOptions() {
    let numPicks = 3 + extraUpgradePicks;
    const currentUpgrades = Object.keys(playerUpgrades);
    // Don't exclude reroll options from the disallow list
    const excluded = upgradeOptions.map(u => u.id).filter(id => id !== 'reroll' && id !== 'rerollPlus');
   
    upgradeOptions = randomAbilities(numPicks, excluded);
   
    // FIX: Changed to 1 reroll
    if (upgradeRerollsUsed < 1 && !playerUpgrades.rerollPlus) {
        if (!upgradeOptions.some(o => o.id === 'reroll')) {
            // FIX: Changed to 1 reroll
            upgradeOptions.push({id:'reroll', label:'REROLL', icon:'üîÑ', desc:`Reroll options (${1-upgradeRerollsUsed} remaining).`, tier:'bronze'});
        }
    } else if (playerUpgrades.rerollPlus) {
         if (!upgradeOptions.some(o => o.id === 'rerollPlus')) {
             upgradeOptions.push({id:'rerollPlus', label:'FREE REROLL', icon:'üîÑ', desc:`Unlimited rerolls for this round.`, tier:'gold'});
         }
    }
    selectedUpgradeIndex = 0;
    drawUpgradeMenu();
}
function applyUpgrade(ability) {
    if (ability.id === 'extraUpgrade') {
        extraUpgradePicks++;
    } else {
        playerUpgrades[ability.id] = (playerUpgrades[ability.id] || 0) + 1;
        if (playerAbilities.findIndex(a => a.id === ability.id) === -1) {
            playerAbilities.push(ability);
        }
    }
   
    // Apply stats to player car
    cars.filter(c => !c.ai).forEach(c => c.applyPlayerUpgrades(playerUpgrades));
   
    // Handle permanent field/team changes
    if (ability.id === 'miniRobot' && !cars.some(c => c.playerId === 1001)) addFriendlyAICar(1001, 'attacker', 1.5);
    if (ability.id === 'smolRobot' && !cars.some(c => c.playerId === 1002)) addFriendlyAICar(1002, 'defender', 1.0);
    // FIX: Reworked auto goalie
    if (ability.id === 'autoGoalie' && !goaliePad) { goaliePad = new GoaliePad(); }
    if (ability.id === 'platinumDoubleAll' && foreverBalls.length === 1) {
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.push(new Ball(canvas.width/2, canvas.height/2, BALL_RADIUS));
        foreverBalls.forEach(b => b.reset());
    }
    // FIX: Removed jump pad logic
   
    updateUpgradesDisplay();
}
function exitUpgradePicker() {
    gameState = 'playing';
    extraUpgradePicks = 0; // Reset this *after* picking
    overlay.classList.add('hidden');
    overlay.innerHTML = '';
    pauseBtn.classList.remove('hidden');
   
    // Crucial: Reset lastTime to prevent a huge deltaTime spike
    lastTime = performance.now();
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Classes --
class Car {
    constructor(x, y, color, controls, team_side, player_id, initial_angle, ai=false, difficulty=1, role="attacker") {
        this.x=x; this.y=y; this.color=color; this.team_side=team_side; this.controls=controls;
        this.playerId=player_id; this.angle=initial_angle; this.velX=0; this.velY=0; this.speed=0;
       
        // FIX: Lowered base stats
        this.baseAcceleration=0.3; this.baseMaxSpeed=5.0;
        this.baseRotationSpeed=6.0; this.baseSideFrictionFactor=0.05;
        this.boostPower=1.8; this.boostUsage=1.2; this.maxBoost=100; this.boost=this.maxBoost; this.boosting=false;
       
        this.throttleDirection=0;
        this.ai=ai; this.difficulty=difficulty; this.role = role;
        this.upgrades={}; this.abilities=[]; this.effects={};
        this.isStunned=false;
        this.stunDuration=0; // FIX: Was stunTicks
       
        this.isFriendlyAI = team_side === 'left' && ai;
        this.baseColor = color;
        this.boostTimer = 0; // For ghost car
        this.sizeMultiplier = 1.0; // FIX: For AI sizing
       
        this.updateDifficulty(difficulty);
        this.resetPos={x,y,angle:initial_angle};
    }
   
    updateDifficulty(difficulty) {
        this.difficulty = difficulty;
        if (this.ai) {
            // AI stats are boosted by difficulty
            this.acceleration = this.baseAcceleration + 0.05 * (difficulty-1);
            this.maxBoost = 100 + 10 * (difficulty-1);
            this.rotationSpeed = this.baseRotationSpeed;
            this.sideFrictionFactor = this.baseSideFrictionFactor;
        } else {
            // Player stats are boosted by upgrades
            this.applyPlayerUpgrades(playerUpgrades);
        }
    }
   
    applyPlayerUpgrades(upgrades) {
        if (this.ai) return; // Only apply to player
        let count = id => upgrades[id]||0;
       
        this.acceleration = this.baseAcceleration * (1 + count('accel') * 0.1);
        this.rotationSpeed = this.baseRotationSpeed * (1 + count('turn') * 0.15);
        this.maxBoost = 100 + count('maxBoost') * 20;
        // FIX: Player max speed was not inheriting from baseMaxSpeed
        this.baseMaxSpeed = 5.0 * (1 + count('speed') * 0.05);
        let frictionFactor = 1 - count('frictionFix') * 0.1;
        this.sideFrictionFactor = this.baseSideFrictionFactor * Math.max(0.1, frictionFactor);
       
        // FIX: Implement size changes
        this.sizeMultiplier = 1.0; // Reset to base
        if (count('smallCar') > 0) this.sizeMultiplier *= 0.75; // 25% smaller
        if (count('bigCar') > 0) this.sizeMultiplier *= 1.25; // 25% bigger
       
        this.boost = Math.min(this.maxBoost,this.boost); // Clamp boost
    }
   
    handleInput(deltaTime) { // Needs deltaTime for boost timer
        if (this.ai) { this.handleAI(); return; }
        if (this.isStunned) return;
       
        this.throttleDirection=0; let accelerationForce = 0;
       
        if (keys[this.controls['left']]) this.angle=(this.angle+this.rotationSpeed)%360;
        if (keys[this.controls['right']]) this.angle=(this.angle-this.rotationSpeed)%360;
       
        if (keys[this.controls['up']]) {accelerationForce=this.acceleration;this.throttleDirection=1;}
        if (keys[this.controls['down']]) {
            if (playerUpgrades.brake) { accelerationForce=-this.acceleration*2.0; }
            else { accelerationForce = -this.acceleration * 0.7;}
            this.throttleDirection=-1;
        }
       
        if (accelerationForce!==0) {
            let rad=Math.PI*this.angle/180;
            this.velX+=Math.cos(rad)*accelerationForce; this.velY-=Math.sin(rad)*accelerationForce;
        }
       
        let boostActive = keys['ShiftLeft'] || keys['ShiftRight'] || keys[this.controls['boost']];
        this.boosting = boostActive && this.boost > 0;
       
        // FIX: Handle Ghost Car timer
        if (this.boosting) {
             this.boostTimer += deltaTime;
             // If boost for 0.8s, trigger ghost, and set cooldown
             if (playerUpgrades.ghostCar && this.boostTimer > 0.8 && !this.effects.ghost) {
                 this.effects.ghost = { duration: 1.5 }; // 1.5s ghost
                 this.boostTimer = -2.0; // 2s cooldown before timer can increment again
             }
        } else {
            this.boostTimer = Math.max(0, this.boostTimer); // Reset timer if not boosting, unless on cooldown
        }
    }

    handleAI() {
        if (!ball || this.isStunned) return;
       
        // FIX: AI Separation Force to prevent clumping
        cars.forEach(otherCar => {
            if (otherCar === this || !otherCar.ai || otherCar.isFriendlyAI) return; // Skip self, players, and friendly AI
           
            let dxAI = this.x - otherCar.x;
            let dyAI = this.y - otherCar.y;
            let distAI = Math.hypot(dxAI, dyAI);
            let avoidRadius = (CAR_WIDTH * this.sizeMultiplier) * 1.5; // Avoid if within 1.5 car widths
           
            if (distAI < avoidRadius && distAI > 0) {
                let separationForce = 0.3 * (avoidRadius - distAI) / avoidRadius; // Stronger when closer
                this.velX += (dxAI / distAI) * separationForce;
                this.velY += (dyAI / distAI) * separationForce;
            }
        });
       
        const center_x=canvas.width/2;
        let targetX, targetY;
       
        // Find closest ball
        let targetBall = foreverBalls[0];
        let minBallDist = Infinity;
        foreverBalls.forEach(b => {
            let dist = Math.hypot(b.x - this.x, b.y - this.y);
            if (dist < minBallDist) {
                minBallDist = dist;
                targetBall = b;
            }
        });
       
        // AI role logic
        switch(this.role){
            case "defender":
                // FIX: Stays strictly defensive
                targetX = this.team_side === 'right' ? canvas.width - 150 : 150;
                targetY = Math.max(canvas.height/2 - GOAL_HEIGHT, Math.min(targetBall.y, canvas.height/2 + GOAL_HEIGHT)); // Follows ball Y, but in a wide band
                // Only chase if ball is *very* close to goal
                if (this.team_side === 'right' && targetBall.x > canvas.width - 100) targetX = targetBall.x;
                if (this.team_side === 'left' && targetBall.x < 100) targetX = targetBall.x;
                break;
            case "mid":
                // FIX: Stays in the midfield, supports, only chases on their half
                targetX = center_x + (this.team_side==='right' ? -100 : 100); // Stay on their side of center
                targetY = targetBall.y;
                // Only chase if ball is on their half
                if (this.team_side === 'right' && targetBall.x > center_x) targetX = targetBall.x;
                if (this.team_side === 'left' && targetBall.x < center_x) targetX = targetBall.x;
                break;
            case "attacker":
                // Always chases ball
                targetX = targetBall.x; targetY = targetBall.y;
                break;
            case "goalkeeper":
                // Stays on goal line, follows ball's Y
                let gLineX = this.team_side === "right" ? canvas.width - BALL_RADIUS*3 : BALL_RADIUS*3;
                targetX = gLineX;
                targetY = Math.max(canvas.height/2-GOAL_HEIGHT/2+BALL_RADIUS, Math.min(targetBall.y,canvas.height/2+GOAL_HEIGHT/2-BALL_RADIUS));
                break;
            default: targetX=targetBall.x; targetY=targetBall.y;
        }
       
        // --- FIX: AI Corner Avoidance Logic ---
        const cornerSize = 150;
        const ballInTop = targetBall.y < cornerSize;
        const ballInBottom = targetBall.y > canvas.height - cornerSize;
        const ballInLeft = targetBall.x < cornerSize;
        const ballInRight = targetBall.x > canvas.width - cornerSize;

        if ((ballInTop || ballInBottom) && (ballInLeft || ballInRight) && this.role !== 'goalkeeper') {
            // Ball is in a corner.
            // Check if AI is also near that corner
            const aiNearTop = this.y < cornerSize + 50;
            const aiNearBottom = this.y > canvas.height - cornerSize - 50;
            const aiNearLeft = this.x < cornerSize + 50;
            const aiNearRight = this.x > canvas.width - cornerSize - 50;
           
            if ((ballInTop && aiNearTop) || (ballInBottom && aiNearBottom)) {
                if ((ballInLeft && aiNearLeft) || (ballInRight && aiNearRight)) {
                    // Both ball and AI are in the same corner.
                   
                    if (this.role === 'defender') {
                        // Defender's job: Clear towards center
                        targetX = canvas.width / 2;
                        targetY = canvas.height / 2;
                    } else { // Attacker or Mid
                        // Aim slightly out of the corner, not at the ball
                        targetX = targetBall.x;
                        targetY = targetBall.y;
                       
                        if (ballInLeft) targetX = cornerSize + 20; // Aim *out* of the left corner
                        if (ballInRight) targetX = canvas.width - cornerSize - 20; // Aim *out* of the right
                        if (ballInTop) targetY = cornerSize + 20; // Aim *out* of the top
                        if (ballInBottom) targetY = canvas.height - cornerSize - 20; // Aim *out* of the bottom
                    }
                }
            }
        }
        // --- END FIX ---
       
        const dx=targetX-this.x,dy=targetY-this.y;
        const targetAngleRad=Math.atan2(-dy,dx); let targetAngle=(targetAngleRad*180/Math.PI+360)%360;
        let angleDiff = targetAngle-this.angle; if(angleDiff>180)angleDiff-=360;if(angleDiff<-180)angleDiff+=360;
        const dist = Math.hypot(dx,dy);
       
        if(this.effects.confused) {
            // Spin and move randomly
            this.angle = (this.angle + (Math.random() < 0.5 ? 5 : -5)) % 360;
            this.throttleDirection = Math.random() < 0.7 ? 1 : 0;
        } else {
            // Turn towards target
            if(angleDiff>this.rotationSpeed){this.angle=(this.angle+this.rotationSpeed)%360;}
            else if(angleDiff<-this.rotationSpeed){this.angle=(this.angle-this.rotationSpeed)%360;}
            else{this.angle=targetAngle;}
           
            this.throttleDirection=0;
            // Drive if facing target
            if(Math.abs(angleDiff)<32) {
                let rad=Math.PI*this.angle/180;
                let roleBoost = (this.role==='attacker'?1.14:(this.role==='defender'?0.87:1));
                this.velX+=Math.cos(rad)*this.acceleration*roleBoost;
                this.velY-=Math.sin(rad)*this.acceleration*roleBoost;
                this.throttleDirection=1;
            }
        }
       
        // AI Boost logic
        let boostThreshold = this.maxBoost * (0.1 * this.difficulty); // Harder AI boosts more
        if (["attacker","mid"].includes(this.role)) {
            let basicBoost = this.boost>boostThreshold && ((dist>200&&(Math.abs(angleDiff)<8)));
            this.boosting = (this.difficulty > 1 ? basicBoost : false);
        } else { this.boosting=false; }
    }
   
    move(deltaTime) {
        // FIX: Handle stun duration
        if(this.isStunned){
            this.stunDuration -= deltaTime;
            if(this.stunDuration <= 0) {
                this.isStunned=false;
                this.stunDuration = 0;
            }
            return; // Stop all movement
        }
       
        // FIX: Decrement effects by deltaTime
        ["slow","confused","forceField","invincible","goalBlock","ring","ghost"].forEach(eff=>{
            if(this.effects[eff]) {
                this.effects[eff].duration -= deltaTime;
                if(this.effects[eff].duration <=0) delete this.effects[eff];
            }
        });
       
        // Standard physics
        let rad=Math.PI*this.angle/180;
        let fVel=this.velX*Math.cos(rad)-this.velY*Math.sin(rad);
        let sVel=this.velX*Math.sin(rad)+this.velY*Math.cos(rad);
        sVel*=(1-this.sideFrictionFactor); fVel*=0.96; // Apply friction
       
        if(this.boosting && this.boost>0 && this.throttleDirection!==0) {
            let boostForce=this.acceleration*this.boostPower*1.5;
            fVel+=boostForce*this.throttleDirection;
            // FIX: Scale boost usage by deltaTime
            if(!this.effects.invincible) this.boost -= this.boostUsage * deltaTime * PHYSICS_TICK_RATE;
            if(this.boost<0){this.boost=0;this.boosting=false;}
        }
       
        this.velX= fVel*Math.cos(rad)+sVel*Math.sin(rad);
        this.velY= -fVel*Math.sin(rad)+sVel*Math.cos(rad);

        let speedMultiplier = 1;
        if(this.effects.slow) speedMultiplier = this.effects.slow.factor;
       
        this.speed = Math.hypot(this.velX,this.velY);
        let maxSpeed = this.baseMaxSpeed*(this.boosting?this.boostPower:1);
        if(this.speed>maxSpeed){let sc=maxSpeed/this.speed;this.velX*=sc;this.velY*=sc;}
       
        // FIX: Scale movement by deltaTime
        this.x += this.velX * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * speedMultiplier * deltaTime * PHYSICS_TICK_RATE;
       
        // Wall collision
        // FIX: Use dynamic car size for wall collision
        let w = CAR_WIDTH * this.sizeMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier;
        let fieldExpand = Math.min(0.4, (getNumberOfAICars()-1)*0.07);
        // FIX: Changed from clamping to bouncing to prevent getting stuck
        let marginW = w / 2; // Simple approximation
        let marginH = h / 2; // Simple approximation
       
        let fieldMarginW = marginW + fieldExpand*canvas.width/2;
        let fieldMarginH = marginH + fieldExpand*canvas.height/2;

        // NEW Bouncing Logic
        if (this.x < fieldMarginW) {
            this.x = fieldMarginW;
            this.velX *= -0.5; // Bounce off left wall
        } else if (this.x > canvas.width - fieldMarginW) {
            this.x = canvas.width - fieldMarginW;
            this.velX *= -0.5; // Bounce off right wall
        }
       
        if (this.y < fieldMarginH) {
            this.y = fieldMarginH;
            this.velY *= -0.5; // Bounce off top wall
        } else if (this.y > canvas.height - fieldMarginH) {
            this.y = canvas.height - fieldMarginH;
            this.velY *= -0.5; // Bounce off bottom wall
        }
    }
   
    draw() {
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(-Math.PI*this.angle/180);
       
        // FIX: Use dynamic size
        let w = CAR_WIDTH * this.sizeMultiplier;
        let h = CAR_HEIGHT * this.sizeMultiplier;
       
        let displayColor = this.color;
        if(this.isFriendlyAI) displayColor = '#00cccc';
        if(this.isStunned) displayColor = '#aaaaaa';
        if(this.effects.ring) displayColor = '#fcd34d';
        if(this.effects.forceField) displayColor = '#00ff00';
        if(this.effects.invincible) displayColor = '#ff00ff';
        if(this.effects.ghost) displayColor = 'rgba(255,255,255,0.5)';
       
        ctx.fillStyle=displayColor;
        ctx.beginPath(); ctx.roundRect(-w/2,-h/2, w, h, 8 * this.sizeMultiplier); ctx.fill();
       
        // Car details (also scaled)
        ctx.fillStyle='yellow';
        ctx.beginPath(); ctx.roundRect(w/2-(10*this.sizeMultiplier),-h/2+(5*this.sizeMultiplier), 8*this.sizeMultiplier, h-(10*this.sizeMultiplier), 2*this.sizeMultiplier); ctx.fill();
       
        if(this.boosting){
            ctx.fillStyle="#ffaa00";
            ctx.beginPath(); ctx.moveTo(-w/2,0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),-h/4);
            ctx.lineTo(-w/2-(20*this.sizeMultiplier),0); ctx.lineTo(-w/2-(15*this.sizeMultiplier),h/4); ctx.closePath(); ctx.fill();
        }
        ctx.restore();
       
        // Draw effects
        if(this.effects.ring || this.effects.forceField){
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = this.effects.ring ? "#fcd34d" : (this.effects.forceField ? "#00ff00":"#00fff4");
            ctx.globalAlpha = 0.6; ctx.lineWidth=4;
            // FIX: Scale effect radius
            let radius = (CAR_WIDTH * this.sizeMultiplier) * 1.7;
            if(this.effects.forceField) radius = (CAR_WIDTH * this.sizeMultiplier) * 2.5;
            ctx.arc(this.x,this.y,radius,0,Math.PI*2); ctx.stroke();
            ctx.restore();
        }
       
        // Boost Bar UI
        const isHuman=!this.ai;
        const label = isHuman?`P${this.playerId}`:`AI Lv.${this.difficulty} (${this.role})`;
        // FIX: Position boost bar based on car size
        const labelY=this.y-h/2-15, barWidth=40, barHeight=6, bpct=this.boost/this.maxBoost;
        ctx.fillStyle=isHuman?COLOR_BLUE:(this.isFriendlyAI ? '#00cccc' : COLOR_RED);
        ctx.font='12px Inter'; ctx.textAlign='center';
        ctx.fillText(label,this.x,labelY-5);
        ctx.fillStyle='#1f2937';
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth,barHeight,3); ctx.fill();
        let grad = ctx.createLinearGradient(this.x-barWidth/2,0,this.x-barWidth/2+barWidth,0);
        grad.addColorStop(0,bpct<0.3?'#ef4444':'#f97316'); grad.addColorStop(1,'#f97316');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.roundRect(this.x-barWidth/2,labelY,barWidth*bpct,barHeight,3); ctx.fill();
    }
   
    refillBoost(amount) {
        let refill = amount;
        if(!this.ai && this.playerId===1){
            refill += (playerUpgrades.boostRegen || 0) * 10;
            if(playerUpgrades.hyperPad) refill *= 2;
        }
        this.boost = Math.min(this.maxBoost,this.boost+refill);
    }
   
    reset() {
        this.x=this.resetPos.x; this.y=this.resetPos.y; this.angle=this.resetPos.angle;
        this.velX=0; this.velY=0; this.speed=0; this.boost=this.maxBoost;
        this.isStunned=false; this.stunDuration=0; this.effects={};
    }
}

class Ball {
    constructor(x, y, radius, pointType=1) {
        this.x=x;this.y=y;this.radius=radius;this.color=COLOR_CYAN;
        this.velX=0;this.velY=0;this.maxSpeed=35; this.pointType=pointType; this.effects = {};
        this.stuckTimer = 0; // FIX: For stuck ball (re-purposed)
       
        // --- FIX: New Corner Stuck Vars ---
        this.ballInCornerTimer = 0;
        this.ballInCornerArea = null;
        this.ballStuckCountdown = 0;
    }
   
    move(deltaTime) {
        // --- FIX START: Corrected Ball.move logic ---
        if (this.effects.magnet) {
            let playerCar = cars.find(c => c.playerId === 1);
            if (playerCar) {
                let dx = playerCar.x - this.x;
                let dy = playerCar.y - this.y;
                let dist = Math.hypot(dx, dy);
                let pullForce = 0.005;
                if (dist > 10) {
                    this.velX += dx * pullForce;
                    this.velY += dy * pullForce;
                }
                // FIX: Decrement by deltaTime
                this.effects.magnet.duration -= deltaTime;
                if (this.effects.magnet.duration <= 0) delete this.effects.magnet;
            } else {
                delete this.effects.magnet;
            }
        }

        // Standard ball physics
        this.velX *= 0.98; // Apply friction
        this.velY *= 0.98;
       
        let speed = Math.hypot(this.velX, this.velY);
        if(speed > this.maxSpeed){
            let sc = this.maxSpeed / speed;
            this.velX *= sc;
            this.velY *= sc;
        }
       
        // FIX: Scale movement by deltaTime
        this.x += this.velX * deltaTime * PHYSICS_TICK_RATE;
        this.y += this.velY * deltaTime * PHYSICS_TICK_RATE;
       
        // Wall collision
        let bMargin = this.radius;
       
        // NEW Bouncing Logic
        if (this.x < bMargin) {
            this.x = bMargin;
            this.velX *= -0.8; // Bounce off left wall
        } else if (this.x > canvas.width - bMargin) {
            this.x = canvas.width - bMargin;
            this.velX *= -0.8; // Bounce off right wall
        }
       
        if (this.y < bMargin) {
            this.y = bMargin;
            this.velY *= -0.8; // Bounce off top wall
        } else if (this.y > canvas.height - bMargin) {
            this.y = canvas.height - bMargin;
            this.velY *= -0.8; // Bounce off bottom wall
        }
       
        // Sticky net
        if(playerUpgrades.platinumStickyNet) {
            let aiGoalTop=canvas.height/2-GOAL_HEIGHT/2, aiGoalBottom=canvas.height/2+GOAL_HEIGHT/2;
            if(this.y>aiGoalTop && this.y<aiGoalBottom && this.x > canvas.width - (BALL_RADIUS*3)) {
                this.velX *= 0.9; // Slow down in net
            }
        }
       
        // --- FIX: New Stuck Ball in Corner Logic ---
        const cornerSize = 120; // How deep the corner is
        const top = this.y < cornerSize;
        const bottom = this.y > canvas.height - cornerSize;
        const left = this.x < cornerSize;
        const right = this.x > canvas.width - cornerSize;

        let currentCorner = null;
        if (top && left) currentCorner = 'tl';
        else if (top && right) currentCorner = 'tr';
        else if (bottom && left) currentCorner = 'bl';
        else if (bottom && right) currentCorner = 'br';

        this.ballInCornerArea = currentCorner;

        if (this.ballInCornerArea) {
            this.ballInCornerTimer += deltaTime;
            const gracePeriod = 1.5; // 1.5 seconds before countdown starts

            if (this.ballInCornerTimer > gracePeriod) {
                // Calculate countdown (2, 1)
                // Math.ceil ensures it shows 2, then 1
                this.ballStuckCountdown = Math.ceil(2.0 - (this.ballInCornerTimer - gracePeriod));
               
                if (this.ballStuckCountdown < 1) { // Timer has finished (e.g., timer is 3.6s)
                    this.reset();
                    stuckBallMessage = { text: 'Ball stuck! Resetting position...', duration: 2.0 };
                    // Reset timers immediately
                    this.ballInCornerTimer = 0;
                    this.ballStuckCountdown = 0;
                    this.ballInCornerArea = null;
                }
            }
        } else {
            // Ball is not in a corner, reset timers
            this.ballInCornerTimer = 0;
            this.ballStuckCountdown = 0;
        }
        // --- END NEW FIX ---
       
        // --- REMOVED Old Stuck Ball Logic ---
        // if (speed < 0.5) { ... }
        // if (this.stuckTimer > 3.0) { ... }
    }
   
    draw() {
        ctx.fillStyle=this.pointType===1?this.color:(this.pointType===2?'#ffe066':'#ff92c6');
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,0.5)';
        ctx.beginPath(); ctx.arc(this.x-5,this.y-5,this.radius/2,0,Math.PI*2); ctx.fill();
       
        if(this.pointType>1){
            ctx.save();
            ctx.font='bold 13px Inter'; ctx.globalAlpha=0.90;
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillStyle=(this.pointType===2?'#fcad03':'#ed1b90'); ctx.strokeStyle='#fff';
            let txt=(this.pointType===2?'2x':'3x');
            ctx.fillText(txt,this.x,this.y-this.radius+10);
            ctx.restore();
        }
    }
   
    reset() {
        let maxOffset=canvas.height*MAX_CENTER_OFFSET_FACTOR, randomYOffset=Math.random()*2*maxOffset-maxOffset;
        this.x=canvas.width/2; this.y=canvas.height/2+randomYOffset; this.velX=0;this.velY=0;
        this.stuckTimer = 0; // FIX: Reset old timer
       
        // --- FIX: Reset new corner timers ---
        this.ballInCornerTimer = 0;
        this.ballInCornerArea = null;
        this.ballStuckCountdown = 0;
        // --- END FIX ---
       
        let r=Math.random();
        if(playerUpgrades.platinumDoubleAll) {
            if(r<0.10) this.pointType=3;
            else if(r<0.30) this.pointType=2;
            else this.pointType=1;
        } else if(r<0.03) this.pointType=3;
        else if(r<0.13) this.pointType=2;
        else this.pointType=1;
       
        this.effects = {};
    }
}

class BoostPad {
    constructor(x,y,radius=15){this.x=x;this.y=y;this.radius=radius; this.refillAmount=30;}
    draw() {
        ctx.strokeStyle="#fbbf24"; ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle="#f59e42";
        ctx.beginPath(); ctx.arc(this.x,this.y,this.radius-8,0,Math.PI*2); ctx.fill();
    }
    checkCollision(car){
        let dist=Math.hypot(this.x-car.x,this.y-car.y);
        // FIX: Use dynamic car size
        return dist<this.radius+(CAR_WIDTH * car.sizeMultiplier / 2);
    }
}

// FIX: Removed JumpPad class

// FIX: New class for Goalie Pad
class GoaliePad {
    constructor() {
        this.width = GOAL_LINE_WIDTH * 2;
        this.height = GOAL_HEIGHT * 0.20; // 20% of goal height
        this.x = GOAL_LINE_WIDTH / 2;
        this.y = canvas.height / 2;
        this.speed = 400; // pixels per second
    }
    update(deltaTime) {
        // Track closest ball's Y position
        let targetBall = foreverBalls[0];
        if (foreverBalls.length > 1) {
            let minBallDist = Infinity;
            foreverBalls.forEach(b => {
                if (b.x < canvas.width / 2 + 100) { // Only track balls on player side + 100
                    let dist = Math.abs(b.y - this.y); // Just track Y
                    if (dist < minBallDist) {
                        minBallDist = dist;
                        targetBall = b;
                    }
                }
            });
        }
       
        let targetY = targetBall.y;
        // Clamp to player's goal
        let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
        let playerGoalTop = canvas.height/2 - goalHeight/2;
        let playerGoalBottom = canvas.height/2 + goalHeight/2;
       
        let targetCenter = Math.max(playerGoalTop + this.height/2, Math.min(targetY, playerGoalBottom - this.height/2));
       
        let moveDist = this.speed * deltaTime;
       
        if (this.y < targetCenter) this.y = Math.min(this.y + moveDist, targetCenter);
        else if (this.y > targetCenter) this.y = Math.max(this.y - moveDist, targetCenter);
       
        this.y = Math.max(playerGoalTop + this.height/2, Math.min(this.y, playerGoalBottom - this.height/2));
    }
    draw() {
        ctx.fillStyle = '#00cccc';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height, 4);
        ctx.fill();
        ctx.stroke();
    }
    checkCollision(ball) {
        let top = this.y - this.height/2;
        let bottom = this.y + this.height/2;
        let left = this.x - this.width/2;
        let right = this.x + this.width/2;
       
        if (ball.x - ball.radius < right && ball.x + ball.radius > left && ball.y > top && ball.y < bottom) {
            if (ball.velX < 0) { // Only hit ball if it's coming towards goal
                ball.velX *= -1.2; // Hit it back harder
                ball.x = right + ball.radius;
            }
        }
    }
}


// ====== Game Functions ======
function getInitialAngle(x1,y1,x2,y2){
    let angleRad=Math.atan2(y1-y2,x2-x1);
    return (angleRad*180/Math.PI+360)%360;
}
function getNumberOfAICars(){return cars.filter(c=>c.ai&&!c.isFriendlyAI).length;}

function addFriendlyAICar(playerId, role, difficultyMultiplier) {
    const P1_X=100+CAR_WIDTH/2, center_y=canvas.height/2;
    let newAI = new Car(P1_X + 20, center_y + (Math.random() * 100 - 50),
                        '#00cccc', {}, 'left', playerId,
                        getInitialAngle(P1_X, center_y, canvas.width/2, center_y),
                        true, aiDifficulty * difficultyMultiplier, role);
    // FIX: Make friendly AI smaller
    newAI.sizeMultiplier = 0.75;
    cars.push(newAI);
}

function addEnemyAICar() {
    let center_x=canvas.width/2, center_y=canvas.height/2;
    let P2_X=canvas.width-100-CAR_WIDTH/2;
    let P1_Y_OFFSET=CAR_HEIGHT*2;
    let aiY=center_y+((Math.random() > 0.5)?P1_Y_OFFSET*(Math.random()*2):-P1_Y_OFFSET*Math.random()*2);
   
    // FIX: Use getNumberOfAICars() for correct ID
    let newAI = new Car(P2_X,aiY,COLOR_RED,{},'right',2+getNumberOfAICars(),getInitialAngle(P2_X,aiY,center_x,center_y),true,aiDifficulty);
    cars.push(newAI);
   
    // FIX: Update all AI sizes
    let allAIs = cars.filter(c => c.ai && !c.isFriendlyAI);
    allAIs.forEach((ai, index) => {
        ai.sizeMultiplier = Math.max(0.6, 1.0 - (index * 0.08)); // FIX: 8% smaller per car, min 60%
    });
   
    // Re-assign all roles
    assignAIRoles(allAIs);
}

// FIX: New role assignment logic
function assignAIRoles(aiCars){
    // FIX: Use predefined role order
    const roleOrder = ["attacker", "defender", "mid", "attacker", "defender", "mid"];
   
    aiCars.sort((a, b) => a.playerId - b.playerId).forEach((ai, index) => {
        ai.role = roleOrder[index] || "attacker"; // Default to attacker if more than 6 (shouldn't happen)
    });
}

function setupGameObjects(mode,initialAICount=1){
    let fieldExpandFactor = Math.min(0.35,(initialAICount-1)*0.06);
    canvas.width = DEFAULT_WIDTH + DEFAULT_WIDTH*fieldExpandFactor;
    canvas.height=DEFAULT_HEIGHT + DEFAULT_HEIGHT*fieldExpandFactor;
   
    // Make viewport div match canvas size
    document.getElementById('game-viewport').style.width = canvas.width + 'px';
    document.getElementById('game-viewport').style.height = canvas.height + 'px';

    let center_x=canvas.width/2, center_y=canvas.height/2;
   
    let initialBallCount = 1;
    if(playerUpgrades.platinumDoubleAll) initialBallCount = 3;
    foreverBalls = [];
    for(let i=0; i<initialBallCount; i++) {
        let newBall = new Ball(center_x, center_y, BALL_RADIUS);
        newBall.reset();
        foreverBalls.push(newBall);
    }
    ball = foreverBalls[0]; // Main ball
   
    cars=[];
    let P1_X=100+CAR_WIDTH/2, P2_X=canvas.width-100-CAR_WIDTH/2;
    let P1_Y_OFFSET=CAR_HEIGHT*2;
   
    // Player 1
    let p1 = new Car(P1_X,center_y,COLOR_BLUE,
        {'up':'KeyW','down':'KeyS','left':'KeyA','right':'KeyD','boost':'ShiftLeft'},'left',1,getInitialAngle(P1_X,center_y,center_x,center_y));
    cars.push(p1);

    if(mode==="1v1 Multiplayer") {
        cars.push(new Car(P2_X,center_y,COLOR_RED,
            {'up':'ArrowUp','down':'ArrowDown','left':'ArrowLeft','right':'ArrowRight','boost':'ShiftRight'},
            'right',2,getInitialAngle(P2_X,center_y,center_x,center_y)));
    }
    else if(mode==="2v2 Multiplayer") {
        cars.push(new Car(P1_X,center_y+P1_Y_OFFSET, COLOR_BLUE, { 'up': 'KeyT', 'down': 'KeyG', 'left': 'KeyF', 'right': 'KeyH', 'boost': 'Space' }, 'left', 2, getInitialAngle(P1_X,center_y+P1_Y_OFFSET,center_x,center_y)));
        cars.push(new Car(P2_X,center_y-P1_Y_OFFSET, COLOR_RED, { 'up': 'ArrowUp', 'down': 'ArrowDown', 'left': 'ArrowLeft', 'right': 'ArrowRight', 'boost': 'ShiftRight' }, 'right', 3, getInitialAngle(P2_X,center_y-P1_Y_OFFSET,center_x,center_y)));
        cars.push(new Car(P2_X,center_y+P1_Y_OFFSET, COLOR_RED, { 'up': 'KeyI', 'down': 'KeyK', 'left': 'KeyJ', 'right': 'KeyL', 'boost': 'ControlRight' }, 'right', 4, getInitialAngle(P2_X,center_y+P1_Y_OFFSET,center_x,center_y)));
    }
   
    if(mode==="Vs Computer"){
        for(let i=0; i<initialAICount;i++){
            let aiY=center_y+((i%2===0)?P1_Y_OFFSET*(i/2):-P1_Y_OFFSET*Math.ceil(i/2));
            let aiObj=new Car(P2_X,aiY,COLOR_RED,{},'right',2+i,getInitialAngle(P2_X,aiY,center_x,center_y),true,aiDifficulty);
            cars.push(aiObj);
        }
        assignAIRoles(cars.filter(c=>c.ai&&!c.isFriendlyAI));
       
        // Add existing friendly AI
        if(playerUpgrades.miniRobot) addFriendlyAICar(1001, 'attacker', 1.5);
        if(playerUpgrades.smolRobot) addFriendlyAICar(1002, 'defender', 1.0);
    }
   
    p1.applyPlayerUpgrades(playerUpgrades); // Apply all collected upgrades
   
    // FIX: Reset goalie pad and jump pads
    goaliePad = null;
    if (playerUpgrades.autoGoalie) { goaliePad = new GoaliePad(); }
   
    // jumpPads = []; // Removed
    // FIX: Removed jump pad creation
   
    boostPads=[
        new BoostPad(canvas.width*0.5,canvas.height*0.25), new BoostPad(canvas.width*0.5,canvas.height*0.75),
        new BoostPad(canvas.width*0.25,canvas.height*0.5), new BoostPad(canvas.width*0.75,canvas.height*0.5),
        new BoostPad(canvas.width*0.5,canvas.height*0.5),
        new BoostPad(canvas.width*0.1,canvas.height*0.12), new BoostPad(canvas.width*0.9,canvas.height*0.12),
        new BoostPad(canvas.width*0.1,canvas.height*0.88), new BoostPad(canvas.width*0.9,canvas.height*0.88),
    ];
    if(playerUpgrades.extraBoostPad) {
        boostPads.push(new BoostPad(canvas.width*0.35, canvas.height*0.35));
        boostPads.push(new BoostPad(canvas.width*0.65, canvas.height*0.65));
    }
}

// --- UI and Menu functions ---

const overlay = document.getElementById('overlay');
const uiPanel = document.getElementById('ui-panel');
const foreverStatusPanel = document.getElementById('forever-status-panel');
const pauseBtn = document.getElementById('pause-btn');

function updateUI(){
    let modeInfoElement=document.getElementById('mode-info'), timerElement=document.getElementById('timer'), aiStatusElement=document.getElementById('ai-status');
   
    document.getElementById('score-left').textContent=`BLUE: ${scoreLeft}`;
    document.getElementById('score-right').textContent=`RED: ${scoreRight}`;
   
    if(endConditionType==='points'){
        timerElement.textContent=`${scoreLeft} / ${targetScore}`;
        modeInfoElement.textContent=`PLAYER GOALS`;
        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.add('hidden');
    }
    else if(endConditionType==='timed'){
        let minutes=Math.floor(gameTimer/60), seconds=Math.floor(gameTimer%60);
        timerElement.textContent=`${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
        modeInfoElement.textContent=`TIME REMAINING`;
        uiPanel.classList.remove('hidden');
        foreverStatusPanel.classList.add('hidden');
    }
    else if(endConditionType==='forever'){
        // FIX: Show *both* score and level info
        timerElement.textContent=`${playerLevel}`;
        modeInfoElement.textContent=`PLAYER LEVEL`;
        aiStatusElement.textContent = `LV ${aiDifficulty} (${getNumberOfAICars()} Car${getNumberOfAICars()!==1?'s':''})`;
        // FIX: Update player level display
        document.getElementById('player-level-display').textContent = playerLevel;
       
        uiPanel.classList.remove('hidden'); // Show score
        foreverStatusPanel.classList.remove('hidden'); // Show upgrades
    }
    updateUpgradesDisplay();
}

function updateUpgradesDisplay() {
    const display = document.getElementById('player-upgrades-display');
    display.innerHTML = '';
   
    if (playerAbilities.length === 0) {
        display.innerHTML = `<p class="text-sm text-gray-400">Score to earn upgrades!</p>`;
        return;
    }
   
    playerAbilities.forEach(ability => {
        const count = playerUpgrades[ability.id] || 0;
        const countDisplay = count > 1 ? ` (x${count})` : '';
        const levelClass = `ability-level-${ability.tier}`;
        const item = document.createElement('div');
       
        // FIX: Add tooltip container class
        item.className = `p-2 rounded-lg text-sm font-semibold flex items-center shadow-md ${levelClass} upgrade-icon-container`;
       
        // FIX: Add tooltip HTML
        item.innerHTML = `
            <span class="text-xl mr-1">${ability.icon}</span>
            ${ability.label}${countDisplay}
            <div class="upgrade-tooltip">
                <h4 class="font-bold mb-1 flex items-center">
                    <span class="text-xl mr-2">${ability.icon}</span>
                    ${ability.label}
                    <span class="font-mono text-xs p-1 rounded-full ${levelClass} ml-2">${ability.tier.toUpperCase()}</span>
                </h4>
                <p class="text-xs">${ability.desc}</p>
            </div>
        `;
        display.appendChild(item);
    });
}

// --- Drawing Functions ---
function drawField(){
    ctx.fillStyle=COLOR_FIELD; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle="#dcdcdc"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(canvas.width/2,0); ctx.lineTo(canvas.width/2,canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(canvas.width/2,canvas.height/2,80,0,Math.PI*2); ctx.stroke();
   
    // Use dynamic goal height for player
    let goalHeight = GOAL_HEIGHT;
    if (playerUpgrades.shortGoal) goalHeight *= 0.7;
   
    // FIX: Use dynamic goal height for AI
    let aiGoalHeight = GOAL_HEIGHT;
    if (playerUpgrades.goalExpansion) aiGoalHeight *= 1.3; // 30% wider
   
    let aiGoalTop=canvas.height/2 - aiGoalHeight/2, aiGoalBottom=canvas.height/2 + aiGoalHeight/2;
    let playerGoalTop=canvas.height/2 - goalHeight/2, playerGoalBottom=canvas.height/2 + goalHeight/2;
   
    ctx.strokeStyle=COLOR_BLUE; ctx.lineWidth=GOAL_LINE_WIDTH;
    ctx.beginPath(); ctx.moveTo(0,playerGoalTop); ctx.lineTo(0,playerGoalBottom); ctx.stroke();
   
    ctx.strokeStyle=COLOR_RED; ctx.lineWidth=GOAL_LINE_WIDTH;
    ctx.beginPath(); ctx.moveTo(canvas.width,aiGoalTop); ctx.lineTo(canvas.width,aiGoalBottom); ctx.stroke();
   
    boostPads.forEach(pad=>pad.draw());
    // FIX: Removed jump pad drawing
    if (goaliePad) goaliePad.draw(); // FIX: Draw goalie pad
}

// --- Collision & Goal Logic ---
function checkCarBallCollision(car, ball){
    // if (!car.ai && playerUpgrades.ghostCar && car.effects.ghost) return; // Ghost car should still hit ball
    if (!car.ai && playerUpgrades.platinumInvincible && car.effects.invincible) return;
   
    let dx=ball.x-car.x, dy=ball.y-car.y;
    // FIX: Use dynamic radius
    let collisionRadius=BALL_RADIUS+(CAR_WIDTH * car.sizeMultiplier * 0.5);
    let dist=Math.hypot(dx,dy);
   
    // AI Force Field (Not implemented)
    // if(!car.ai && car.effects.forceField) { ... }
   
    if(dist<collisionRadius){
        let impulseAngle=Math.atan2(dy,dx), carSpeed=car.speed, baseForce=1.0;
        let force=baseForce+carSpeed*1.5*(car.boosting?car.boostPower:1);
       
        let kickBoost = 1;
        if (!car.ai) {
            kickBoost += (playerUpgrades.kick || 0) * 0.1;
            if (playerUpgrades.doubleKick) kickBoost *= 2;
        }
        force *= kickBoost;
       
        if (!car.ai && playerUpgrades.stickTires) {
            car.velX *= 0.9;
            car.velY *= 0.9;
        }
       
        ball.velX+=Math.cos(impulseAngle)*force; ball.velY+=Math.sin(impulseAngle)*force;
       
        let overlap=collisionRadius-dist;
        if(overlap>0){
            ball.x+=Math.cos(impulseAngle)*overlap;
            ball.y+=Math.sin(impulseAngle)*overlap;
        }
       
        if (!car.ai && playerUpgrades.ballMagnet) {
            ball.effects.magnet = { duration: 0.25 }; // 15 frames @ 60fps
        }
       
        // SuperStun logic
        if (!car.ai && car.effects.ring && car.effects.ring.stunOnHit) {
            let aiCars = cars.filter(c => c.ai && !c.isFriendlyAI);
            aiCars.forEach(ai => {
                let aiDist = Math.hypot(ai.x - car.x, ai.y - car.y);
                if (aiDist < (CAR_WIDTH * car.sizeMultiplier * 2.5)) { // Use player's size
                    ai.isStunned = true;
                    // FIX: Use stunDuration
                    ai.stunDuration = Math.max(ai.stunDuration, 2.0); // 2 seconds
                }
            });
            delete car.effects.ring.stunOnHit; // Only stuns on the first hit
        }
    }
}

function checkCarCarCollision(car1, car2) {
    // Ghost/Invincible checks
    if ((!car1.ai && car1.effects.ghost && car2.ai) || (!car2.ai && car2.effects.ghost && car1.ai)) return;
    if ((!car1.ai && car1.effects.invincible) || (!car2.ai && car2.effects.invincible)) return;
   
    // FIX: Use dynamic radius based on size and increased hitbox
    // --- START MODIFICATION ---
    // The previous logic used average diameter, which was incorrect.
    // This now uses the sum of radii for a correct collision check.
    let radius1 = (CAR_WIDTH * car1.sizeMultiplier / 2) * 0.9; // 90% of actual radius
    let radius2 = (CAR_WIDTH * car2.sizeMultiplier / 2) * 0.9; // 90% of actual radius
    let collisionDistance = radius1 + radius2; // This is the correct distance for collision
    // --- END MODIFICATION ---

    let dx = car2.x - car1.x;
    let dy = car2.y - car1.y;
    let dist = Math.hypot(dx, dy);
   
    if (dist < collisionDistance) { // MODIFIED: Check against sum of radii
        let impulseAngle = Math.atan2(dy, dx);
        let overlap = collisionDistance - dist; // MODIFIED: Correct overlap
       
        // FIX: Stronger separation
        let sepX = Math.cos(impulseAngle) * (overlap / 2 + 0.1);
        let sepY = Math.sin(impulseAngle) * (overlap / 2 + 0.1);
        car1.x -= sepX; car1.y -= sepY;
        car2.x += sepX; car2.y += sepY;
       
        // --- FIX: Elastic collision physics (with mass) ---
        let v1 = car1.velX * Math.cos(impulseAngle) + car1.velY * Math.sin(impulseAngle);
        let v2 = car2.velX * Math.cos(impulseAngle) + car2.velY * Math.sin(impulseAngle);
       
        // FIX: Friendly AI are "lighter" and get knocked around more
        let mass1 = (car1.isFriendlyAI ? 0.5 : 1.0);
        let mass2 = (car2.isFriendlyAI ? 0.5 : 1.0);

        // Apply mass based on car size
        mass1 *= car1.sizeMultiplier;
        mass2 *= car2.sizeMultiplier;

        let v1Final = (v1 * (mass1 - mass2) + 2 * mass2 * v2) / (mass1 + mass2);
        let v2Final = (v2 * (mass2 - mass1) + 2 * mass1 * v1) / (mass1 + mass2);
       
        // Make collision slightly inelastic (e.g., 85% momentum transfer)
        let elasticity = 0.85;
        let dv1 = (v1Final - v1) * elasticity;
        let dv2 = (v2Final - v2) * elasticity;
       
        car1.velX += dv1 * Math.cos(impulseAngle); car1.velY += dv1 * Math.sin(impulseAngle);
        car2.velX += dv2 * Math.cos(impulseAngle); car2.velY += dv2 * Math.sin(impulseAngle);
        // --- END FIX ---
       
        // Slipstream boost
        if (!car1.ai && car2.ai && playerUpgrades.slipStream) car1.boost = Math.min(car1.maxBoost, car1.boost + 10);
        if (!car2.ai && car1.ai && playerUpgrades.slipStream) car2.boost = Math.min(car2.maxBoost, car2.boost + 10);
    }
}


function checkGoal(ball) {
    let goalHeight = playerUpgrades.shortGoal ? GOAL_HEIGHT * 0.7 : GOAL_HEIGHT;
   
    // FIX: Use dynamic AI goal height
    let aiGoalHeight = GOAL_HEIGHT;
    if (playerUpgrades.goalExpansion) aiGoalHeight *= 1.3; // 30% wider
   
    let aiGoalTop=canvas.height/2 - aiGoalHeight/2, aiGoalBottom=canvas.height/2 + aiGoalHeight/2;
    let playerGoalTop=canvas.height/2 - goalHeight/2, playerGoalBottom=canvas.height/2 + goalHeight/2;
   
    if(ball.y>playerGoalTop && ball.y<playerGoalBottom){
        if(ball.x-ball.radius<=0) return 'right'; // AI scored
    }
    if(ball.y>aiGoalTop && ball.y<aiGoalBottom){
        // Check for player's goal block
        if(playerUpgrades.goalBlock && cars[0].effects.goalBlock) return null;
       
        if(ball.x+ball.radius>=canvas.width) return 'left'; // Player scored
    }
    return null;
}

function handleGoal(scoringTeam, scoredBall) {
    if (scoringTeam === 'left') { // Player scored
        let oldLevel = playerLevel; // FIX: Store level *before* score
        scoreLeft += scoredBall.pointType;
        playerLevel += scoredBall.pointType; // FIX: Level = score
       
        // FIX: Check for upgrade
        if (endConditionType === 'forever' && Math.floor(playerLevel / 5) > Math.floor(oldLevel / 5)) {
            pendingUpgradePick = true;
        }
       
        // FIX: Check for AI scaling
        let oldTenBlock = Math.floor(oldLevel / 10);
        let newTenBlock = Math.floor(playerLevel / 10);
       
        if (endConditionType === 'forever' && newTenBlock > oldTenBlock) {
             if (getNumberOfAICars() < 6) {
                 addEnemyAICar();
             } else {
                 // AI is maxed, make them harder
                 aiDifficulty++;
                 cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => {
                    // FIX: "More boosts and stuff"
                    ai.baseAcceleration += 0.02;
                    ai.maxBoost += 10;
                    ai.updateDifficulty(aiDifficulty);
                 });
             }
        }
       
        // Apply player-on-score effects
        cars[0].effects.ring = { duration: 10.0, stunOnHit: true }; // 10 sec ring
        cars[0].effects.goalBlock = { duration: 3.0 }; // 3 sec goal block
       
        cars.filter(c => c.ai && !c.isFriendlyAI).forEach(ai => {
            if (playerUpgrades.aiSlow) ai.effects.slow = { duration: 5.0, factor: 0.5 };
            if (playerUpgrades.timeFreeze) { ai.isStunned = true; ai.stunDuration = Math.max(ai.stunDuration, 2.0); }
            if (playerUpgrades.platinumSuperAI) ai.effects.confused = { duration: 5.0 };
        });
       
        if(playerUpgrades.ballSplit && foreverBalls.length < 5) {
             const newBall = new Ball(scoredBall.x, scoredBall.y, BALL_RADIUS, 1);
             newBall.velX = Math.random() > 0.5 ? 10 : -10;
             newBall.velY = Math.random() > 0.5 ? 10 : -10;
             foreverBalls.push(newBall);
        }
    }
    else if (scoringTeam === 'right') { // AI scored
        scoreRight += scoredBall.pointType;
        if (playerUpgrades.freePad) {
            boostPads.push(new BoostPad(canvas.width/2, canvas.height/2, 25));
        }
        // FIX: Check for lose condition
        if (endConditionType === 'forever' && scoreRight >= scoreLeft + 5) {
             gameState = 'finished';
             drawGameOver('ai_won');
             return; // Stop further processing
        }
    }
   
    // Reset cars on goal
    if(foreverBalls.length === 1 || scoredBall.pointType > 1) {
        cars.forEach(c => c.reset());
    }
   
    // Remove or reset scored ball
    if(foreverBalls.length > 1) {
        foreverBalls = foreverBalls.filter(b => b !== scoredBall);
    } else {
        scoredBall.reset();
    }
   
    // Check for game end (non-forever modes)
    if (gameState === 'playing') {
        if (checkGameEnd()) {
            gameState = 'finished';
            drawGameOver();
        } else if (pendingUpgradePick) {
            requestUpgradePicker();
            pendingUpgradePick = false;
        }
    }
}

function checkGameEnd() {
    if (endConditionType === 'points' && (scoreLeft >= targetScore || scoreRight >= targetScore)) return true;
    if (endConditionType === 'timed' && gameTimer <= 0) return true;
    return false;
}

// --- GAME LOOP ---
function update(deltaTime) {
    if(gameState==='playing'){
        if (playerUpgrades.boostRain && Math.random() < 0.005) { cars[0].refillBoost(30); }
        if (endConditionType === 'timed') { gameTimer=Math.max(0,gameTimer-deltaTime); }
       
        cars.forEach(car => { car.handleInput(deltaTime); car.move(deltaTime); });
        foreverBalls.forEach(ball => ball.move(deltaTime));
       
        // FIX: Update pads
        // FIX: Removed jump pad update
        if (goaliePad) goaliePad.update(deltaTime);

        cars.forEach(car => foreverBalls.forEach(ball => checkCarBallCollision(car, ball)));
        for(let i=0; i<cars.length; i++) for(let j=i+1; j<cars.length; j++) checkCarCarCollision(cars[i], cars[j]);
       
        cars.forEach(car => {
            boostPads.forEach(pad => { if(pad.checkCollision(car)) car.refillBoost(pad.refillAmount); });
            // FIX: Removed jump pad collision check
        });
       
        const scoredBalls = [];
        foreverBalls.forEach(ball => {
            if (goaliePad) goaliePad.checkCollision(ball); // FIX: Check goalie pad collision
            let scoringTeam = checkGoal(ball);
            if (scoringTeam) scoredBalls.push({ball, scoringTeam});
        });
       
        // Handle goals one by one
        if (scoredBalls.length > 0) {
            handleGoal(scoredBalls[0].scoringTeam, scoredBalls[0].ball);
        }
       
        updateUI();
    }
}

function gameLoop(currentTime) {
    // Stop loop if not in a game state
    if (!['playing', 'paused', 'finished', 'upgrading'].includes(gameState)) {
        cancelAnimationFrame(animationFrameId);
        return;
    }
   
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
   
    if (gameState === 'playing') {
        update(deltaTime);
        drawField();
        cars.forEach(car => car.draw());
        foreverBalls.forEach(ball => ball.draw());
    } else if (gameState === 'paused' || gameState === 'finished') {
        // Draw static field
        drawField();
        cars.forEach(car => car.draw());
        foreverBalls.forEach(ball => ball.draw());
    }
   
    // --- FIX: Draw Stuck Ball Countdown ---
    foreverBalls.forEach(b => {
        if (b.ballStuckCountdown > 0) {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Draw countdown number on the ball
            ctx.font = 'bold 60px Inter'; // Made number smaller
            ctx.fillText(b.ballStuckCountdown, b.x, b.y - 10); // Positioned on ball

            // Draw text under countdown
            ctx.font = 'bold 14px Inter'; // Small text
            ctx.shadowBlur = 5; // Less blur for small text
            ctx.fillText("Ball Stuck", b.x, b.y + 25); // Positioned under number
           
            ctx.restore();
        }
    });
    // --- END FIX ---
   
    // --- FIX: Draw Stuck Ball Message ---
    if (stuckBallMessage.duration > 0) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = 'bold 24px Inter';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 5;
        ctx.fillText(stuckBallMessage.text, canvas.width / 2, 50);
        ctx.restore();
        if (gameState === 'playing') { // Only decrease timer if not paused
            stuckBallMessage.duration -= deltaTime;
        }
    }
    // --- END FIX ---
   
    // Keep looping if game is active or paused
    if (gameState === 'playing' || gameState === 'paused' || gameState === 'finished') {
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

// --- MENU FUNCTIONS ---
function drawMainMenu() {
    gameState = 'menu';
    overlay.classList.remove('hidden');
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md">
            <h1 class="text-5xl font-extrabold mb-8 text-yellow-400">2D ROCKET LEAGUE</h1>
            <div id="menu-options" class="space-y-4 text-xl">
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="select-mode-1v1">1v1 Multiplayer (Local)</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="select-mode-2v2">2v2 Multiplayer (Local)</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-forever">Vs Computer: FOREVER MODE</div>
               
                <!--
                    TODO: Replace '#' with your actual URL for the online mode.
                    (e.g., href="https://my-online-game.com")
                -->
                <!-- FIX: Changed 'a' tag to 'div' to match others, removed opacity -->
                <div data-action="play-online" class="block p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150 cursor-not-allowed" title="Coming Soon!">
                    Play Online
                </div>
            </div>
            <!-- FIX: Removed navigation help text -->
        </div>
    `;
   
    // FIX: Query *all* selectable items for keyboard nav
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
   
    Array.from(menuOptions).forEach((option, index) => {
        // Handle both divs and links
        option.addEventListener('click', () => {
            if (option.getAttribute('data-action')) {
                handleMenuSelection(index);
            }
            // If it's the 'a' tag, the onclick handles it
        });
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu')); // Pass null for containerId
    });
   
    selectedMenuIndex = 0;
    updateMenuSelectionUI(null, selectedMenuIndex, 'menu'); // Pass null for containerId
}

// NEW: Function for game settings menu
function drawGameSettingsMenu(mode) {
    gameState = 'menu'; // Still in menu state
    overlay.classList.remove('hidden');
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-lg">
            <h1 class="text-4xl font-extrabold mb-6 text-yellow-400">${mode} Settings</h1>
            <div id="menu-options">
                <h2 class="text-2xl font-bold mb-3 text-white">Time Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-timed-1">1 Minute</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-timed-2">2 Minutes</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-timed-5">5 Minutes</div>
                </div>
   
                <h2 class="text-2xl font-bold mb-3 text-white">Score Limit</h2>
                <div class="flex justify-center gap-4 mb-6">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-points-3">3 Points</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-points-5">5 Points</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="start-points-10">10 Points</div>
                </div>
   
                <hr class="border-gray-500 my-6">
               
                <div>
                    <!-- FIX: Changed text -->
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="main-menu">Back</div>
                </div>
            </div>
        </div>
    `;
   
    // Store the mode globally for the handlers
    window.currentGameModeSelection = mode;
   
    // Re-query menuOptions to include all selectable items
    menuOptions = document.querySelectorAll('#menu-options [data-action]');
   
    menuOptions.forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI(null, index, 'menu')); // containerId is not needed
    });
   
    selectedMenuIndex = 0;
    updateMenuSelectionUI(null, selectedMenuIndex, 'menu');
}


function drawUpgradeMenu() {
    overlay.classList.remove('hidden');
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-4xl">
            <h1 class="text-4xl font-extrabold mb-2 text-green-400">UPGRADE AVAILABLE! (Level ${playerLevel})</h1>
            <!-- FIX: Changed to 1 reroll -->
            <p class="text-gray-300 mb-6">Select an ability. Rerolls remaining: ${playerUpgrades.rerollPlus ? '‚àû' : (1-upgradeRerollsUsed)}</p>
            <div id="upgrade-options" class="flex flex-wrap justify-center gap-6">
                ${upgradeOptions.map((opt, index) => `
                    <div id="upgrade-${index}" data-index="${index}" class="upgrade-option-card p-4 rounded-xl w-64 text-left shadow-lg border-2 border-transparent bg-gray-600 transition duration-200">
                        <p class="text-xl font-bold mb-1 flex items-center justify-between">
                            <span class="text-2xl mr-2">${opt.icon}</span>
                            <!-- FIX: Made tier text bigger/bolder -->
                            <span class="font-mono text-sm font-bold p-1 px-2 rounded-full ability-level-${opt.tier}">${opt.tier.toUpperCase()}</span>
                        </p>
                        <h2 class="text-2xl font-bold mb-2 ${opt.id.includes('reroll') ? 'text-yellow-300' : 'text-white'}">${opt.label}</h2>
                        <p class="text-sm text-gray-300">${opt.desc}</p>
                        ${opt.id.includes('reroll') ? '' : `<p class="mt-2 text-xs text-gray-400">Current count: ${playerUpgrades[opt.id] || 0}</p>`}
                    </div>
                `).join('')}
            </div>
            <!-- FIX: Removed navigation help text -->
        </div>
    `;
   
    menuOptions = document.getElementById('upgrade-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleUpgradeSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('upgrade-options', index, 'upgrade'));
    });
   
    selectedUpgradeIndex = 0;
    updateMenuSelectionUI('upgrade-options', selectedUpgradeIndex, 'upgrade');
}

function drawGameOver(reason = null) {
    pauseBtn.classList.add('hidden');
    overlay.classList.remove('hidden');
   
    let message = 'DRAW!';
    if (reason === 'ai_won') {
        message = 'YOU LOSE!';
    } else if (scoreLeft > scoreRight) {
        message = 'BLUE TEAM WINS!';
    } else if (scoreRight > scoreLeft) {
        message = 'RED TEAM WINS!';
    }
   
    const finalLevel = playerLevel;
    const finalScore = scoreLeft;
   
    overlay.innerHTML = `
        <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md">
            <h1 class="text-5xl font-extrabold mb-4 text-pink-400">GAME OVER</h1>
            <p class="text-3xl font-bold mb-6 ${reason === 'ai_won' ? 'text-red-400' : 'text-yellow-300'}">${message}</p>
            ${endConditionType === 'forever' ?
                `<p class="text-xl text-gray-300 mb-6">Final Level: <span class="text-yellow-400">${finalLevel}</span> | Goals Scored: <span class="text-blue-400">${finalScore}</span></p>`
                :
                `<p class="text-xl text-gray-300 mb-6">Final Score: <span class="text-blue-400">${scoreLeft}</span> - <span class="text-red-400">${scoreRight}</span></p>`
            }
            <div id="menu-options" class="space-y-4 text-xl">
                <!-- FIX: Added Restart Button -->
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="restart">Play Again</div>
                <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="main-menu">Back to Main Menu</div>
            </div>
            <!-- FIX: Removed navigation help text -->
        </div>
    `;
   
    menuOptions = document.getElementById('menu-options').children;
    Array.from(menuOptions).forEach((option, index) => {
        option.addEventListener('click', () => handleMenuSelection(index));
        option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
    });
   
    selectedMenuIndex = 0;
    updateMenuSelectionUI('menu-options', selectedMenuIndex);
}

// FIX: Unified selection function
function updateMenuSelectionUI(containerId, selectedIndex, type = 'menu') {
    // Store globally
    if (type === 'menu') selectedMenuIndex = selectedIndex;
    else selectedUpgradeIndex = selectedIndex;
   
    // FIX: Use the globally defined menuOptions (which is a NodeList)
    // The check for containerId is a fallback for the upgrade menu
    let optionsToUpdate;
    if (type === 'upgrade' && containerId) {
        const container = document.getElementById(containerId);
        if(container) optionsToUpdate = container.children;
        else optionsToUpdate = menuOptions; // Failsafe
    } else {
        optionsToUpdate = menuOptions; // This is the NodeList
    }
   
    Array.from(optionsToUpdate).forEach((child, index) => {
        child.classList.remove('menu-selected');
        if (index === selectedIndex) { child.classList.add('menu-selected'); }
    });
}

function handleMenuSelection(index) {
    if (!menuOptions[index]) return;
    const selection = menuOptions[index].getAttribute('data-action');
   
    // Get mode if we are in the settings menu
    const mode = window.currentGameModeSelection;
   
    if (selection === 'select-mode-1v1') {
        drawGameSettingsMenu('1v1 Multiplayer');
    }
    else if (selection === 'select-mode-2v2') {
        drawGameSettingsMenu('2v2 Multiplayer');
    }
    else if (selection === 'start-forever') {
        startGame('Vs Computer', 'forever');
    }
    // New game start actions from settings menu
    else if (selection === 'start-timed-1') { timeLimitSeconds = 60; startGame(mode, 'timed'); }
    else if (selection === 'start-timed-2') { timeLimitSeconds = 120; startGame(mode, 'timed'); }
    else if (selection === 'start-timed-5') { timeLimitSeconds = 300; startGame(mode, 'timed'); }
    else if (selection === 'start-points-3') { targetScore = 3; startGame(mode, 'points'); }
    else if (selection === 'start-points-5') { targetScore = 5; startGame(mode, 'points'); }
    else if (selection === 'start-points-10') { targetScore = 10; startGame(mode, 'points'); }
   
    // FIX: Handle (disabled) online button
    else if (selection === 'play-online') {
        // Do nothing, it's disabled
        console.log("Online mode not implemented.");
    }
   
    // FIX: Handle Restart
    else if (selection === 'restart') {
        // Need to re-call-start game with the *current* settings
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        // gameMode and endConditionType are already set
        // For timed/points modes, timeLimitSeconds and targetScore are also set
        startGame(gameMode, endConditionType);
    }
   
    // General actions
    else if (selection === 'main-menu') {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        gameState = 'menu'; // Explicitly set state
        drawMainMenu();
    }
    // FIX: Resume functionality
    else if (selection === 'resume') {
        togglePause();
    }
}

function handleUpgradeSelection(index) {
    if (!upgradeOptions[index]) return;
    const upgrade = upgradeOptions[index];
   
    if (upgrade.id === 'reroll' || upgrade.id === 'rerollPlus') {
        // FIX: Increment reroll counter
        if (upgrade.id === 'reroll') {
            upgradeRerollsUsed++;
        }
        rerollUpgradeOptions();
    } else {
        applyUpgrade(upgrade);
        exitUpgradePicker();
    }
}

function startGame(mode, endType='timed') {
    gameMode = mode; endConditionType = endType; scoreLeft = 0; scoreRight = 0;
    aiDifficulty = 1;
    let initialAICount = 1;
   
    if(endType === 'forever') {
        timeLimitSeconds = 99999;
        targetScore = 999; // Set a high score target for forever
        initialAICount = 1;
        playerLevel = 0; // FIX: Start at 0
        playerUpgrades = {};
        playerAbilities = [];
        pendingUpgradePick = false; // Reset
    }
    else {
        // timeLimitSeconds = 120; // This is now set by handleMenuSelection
        // targetScore = 5; // This is now set by handleMenuSelection
        playerUpgrades = {};
        playerAbilities = [];
        initialAICount = (mode === '1v1 Multiplayer') ? 0 : (mode === '2v2 Multiplayer') ? 0 : 1;
    }
   
    gameTimer = timeLimitSeconds;
    setupGameObjects(mode, initialAICount);
   
    // FIX: Start in upgrade state for forever mode
    if (endType === 'forever') {
        gameState = 'upgrading';
        overlay.classList.add('hidden'); // Hide overlay *before* drawing upgrade menu
        requestUpgradePicker();
        // Game loop will be started by exitUpgradePicker
    } else {
        gameState = 'playing';
        overlay.classList.add('hidden');
        pauseBtn.classList.remove('hidden');
        updateUI();
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

function togglePause() {
    if (gameState === 'playing') {
        gameState = 'paused';
        pauseBtn.innerHTML = '<span class="mr-2">‚ñ∂Ô∏è</span> Resume (P)';
        overlay.classList.remove('hidden');
       
        // FIX: Add rules for forever mode
        let foreverRules = '';
        if (endConditionType === 'forever') {
            foreverRules = `
                <div class="text-left bg-gray-800 p-4 rounded-lg mt-6 border border-gray-600">
                    <h3 class="font-bold text-lg text-cyan-400 mb-2">Forever Mode Rules:</h3>
                    <ul class="list-disc list-inside text-sm text-gray-300 space-y-1">
                        <li>Get an upgrade every 5 levels (goals).</li>
                        <li>A new AI opponent appears every 10 levels (max 6).</li>
                        <li>After 6 AI, they get faster and smarter.</li>
                        <li>You lose if the AI is 5 points ahead!</li>
                    </ul>
                </div>
            `;
        }

        overlay.innerHTML = `
            <div class="text-center bg-gray-700 p-8 rounded-xl shadow-2xl w-full max-w-md">
                <h1 class="text-5xl font-extrabold mb-8 text-red-400">GAME PAUSED</h1>
                <div id="menu-options" class="space-y-4 text-xl">
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="resume">Resume Game</div>
                    <!-- FIX: Added Restart Button -->
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="restart">Restart Game</div>
                    <div class="p-3 bg-gray-600 rounded-lg hover:bg-gray-500 transition duration-150" data-action="main-menu">Back to Main Menu</div>
                </div>
                ${foreverRules}
                <!-- FIX: Removed navigation help text -->
            </div>
        `;
        menuOptions = document.getElementById('menu-options').children;
        Array.from(menuOptions).forEach((option, index) => {
            option.addEventListener('click', () => handleMenuSelection(index));
            option.addEventListener('mouseenter', () => updateMenuSelectionUI('menu-options', index));
        });
        selectedMenuIndex = 0;
        updateMenuSelectionUI('menu-options', selectedMenuIndex);
       
    } else if (gameState === 'paused') {
        gameState = 'playing';
        overlay.classList.add('hidden');
        pauseBtn.innerHTML = '<span class="mr-2">‚è∏Ô∏è</span> Pause (P)';
       
        // Reset lastTime to avoid deltaTime spike
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

// --- Keyboard Listeners ---
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
   
    if (gameState === 'menu' || gameState === 'paused' || gameState === 'finished') {
        let containerId = 'menu-options';
        if (e.code === 'ArrowDown') { selectedMenuIndex = (selectedMenuIndex + 1) % menuOptions.length; }
        else if (e.code === 'ArrowUp') { selectedMenuIndex = (selectedMenuIndex - 1 + menuOptions.length) % menuOptions.length; }
        else if (e.code === 'Enter') {
            if (menuOptions[selectedMenuIndex]) {
                // Trigger click to handle 'a' tags and 'div' tags
                menuOptions[selectedMenuIndex].click();
            }
        }
        else return; // Don't prevent default if not a menu key
       
        updateMenuSelectionUI(containerId, selectedMenuIndex);
        e.preventDefault();
       
    } else if (gameState === 'upgrading') {
        let containerId = 'upgrade-options';
        if (e.code === 'ArrowRight') { selectedUpgradeIndex = (selectedUpgradeIndex + 1) % menuOptions.length; }
        else if (e.code === 'ArrowLeft') { selectedUpgradeIndex = (selectedUpgradeIndex - 1 + menuOptions.length) % menuOptions.length; }
        else if (e.code === 'Enter') {
            if (menuOptions[selectedUpgradeIndex]) {
                menuOptions[selectedUpgradeIndex].click();
            }
        }
        else return; // Don't prevent default if not a menu key
       
        updateMenuSelectionUI(containerId, selectedUpgradeIndex, 'upgrade');
        e.preventDefault();
       
    } else if (gameState === 'playing' && e.code === 'KeyP') {
        togglePause();
    }
});
window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

// --- Initial load ---
window.onload = function () {
    canvas.width = DEFAULT_WIDTH;
    canvas.height = DEFAULT_HEIGHT;
    // Set viewport wrapper to initial size
    document.getElementById('game-viewport').style.width = canvas.width + 'px';
    document.getElementById('game-viewport').style.height = canvas.height + 'px';
   
    drawMainMenu();
    // Don't start game loop, drawMainMenu handles the state
}
</script>
</body>
</html>
